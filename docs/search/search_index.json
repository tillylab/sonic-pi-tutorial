{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"1 Willkommen bei Sonic Pi Willkommen in Sonic Pi! Hoffentlich bist du ebenso gespannt darauf zu lernen, wie man mit Sonic Pi verr\u00fcckte Kl\u00e4nge machen kann, wie ich gespannt darauf bin es dir zu zeigen. Es wird eine wirklich unterhaltsame Reise werden, bei der du alles \u00fcber Musik, Synthese, Programmieren, Komposition, Auff\u00fchrung (Performance) lernen wirst - und mehr. Aber halt, wie unh\u00f6flich von mir! Darf ich mich vorstellen? Ich bin Sam Aaron der Typ, der Sonic Pi entwickelt hat. Du kannst mich unter @samaaron auf Twitter finden, und ich w\u00fcrde mich sehr freuen dich dort begr\u00fc\u00dfen zu k\u00f6nnen. Vielleicht interessierst du dich auch f\u00fcr meine Live-Coding-Performances , wo ich meine Musik mit Sonic Pi direkt vor Publikum schreibe. Wenn du irgendwelche Vorschl\u00e4ge oder Ideen zur Verbesserung von Sonic Pi hast \u2013 bitte schreibe sie mir \u2013 eure Kommentare sind sehr hilfreich. Es w\u00e4re ja schlie\u00dflich auch m\u00f6glich, dass deine Idee zu der n\u00e4chsten gro\u00dfen Funktion in Sonic Pi wird! Dieses Tutorial ist in Abschnitte aufgeteilt, die nach Themen gruppiert sind. Auch wenn ich es so geschrieben habe, dass du damit vom Anfang bis zum Ende einfach lernen kann, kannst du ebenso gut an jeder anderen Stelle einsteigen, und wieder aussteigen, ganz wie es dir gef\u00e4llt. Wenn du etwas im Tutorial vermisst, lass es mich wissen, und ich werde \u00fcberlegen, wie ich das in zuk\u00fcnftige Versionen einbauen kann. Anderen beim Live-Coding zuzusehen ist eine wirklich gro\u00dfartige Art zu lernen. Ich streame regelm\u00e4\u00dfig live auf http://youtube.com/samaaron . Also schau gerne vorbei, sag Hallo und stell' mir jede Menge Fragen :-) Ok, legen wir los \u2026 1.1 Live-Coding Einer der aufregendsten Aspekte von Sonic Pi ist, dass du Code live schreiben und ver\u00e4ndern kannst, um Musik zu machen. Ganz so wie du auch mit einer Gitarre auftreten w\u00fcrdest. Mit anderen Worten: Wenn du etwas \u00dcbung hast, kannst du Sonic Pi mit auf die B\u00fchne nehmen und jammen. Mach den Kopf frei Bevor wir in diesem Tutorial in die ernsten Details von Sonic Pi eintauchen, m\u00f6chte ich dir erst einmal zeigen, wie sich das anf\u00fchlt live Musik zu programmieren. Keine Sorge, wenn du nicht alles (oder auch nur irgend etwas davon) verstehst. Das macht nichts. Versuch' an deinem Platz zu bleiben - und genie\u00dfe ... Ein Live-Loop Lass uns loslegen. Kopiere den folgenden Code in einen leeren Puffer: live_loop :flibble do sample :bd_haus, rate: 1 sleep 0.5 end Jetzt klicke die Ausf\u00fchren -Schaltfl\u00e4che und du wirst eine sch\u00f6ne Bass-Drum h\u00f6ren, die schnell vor sich hin h\u00e4mmert. Mit einem Klick auf den Stopp -Schaltfl\u00e4che h\u00f6rt die Musik wieder auf. Aber klicke bitte noch nicht gleich darauf ... probiere stattdessen die folgenden Schritte aus: Lass den Bass-Drum-Sound weiter laufen Setze den Wert von sleep von 0.5 auf einen h\u00f6heren Wert, etwa 1 . Klicke wieder die Ausf\u00fchren -Schaltfl\u00e4che Achte darauf, wie die Geschwindigkeit des Bass-Drum-Beats sich ver\u00e4ndert hat. Und schlie\u00dflich, merke dir diesen Moment ! Dies war das erste Mal, dass du mit Sonic Pi live Programm-Code geschrieben hast. Und es ist wahrscheinlich, dass es nicht das letzte Mal gewesen sein wird \u2026 Ok, das war einfach. F\u00fcgen wir etwas anderes hinzu. \u00dcber sample :bd_haus f\u00fcge die Zeile sample :ambi_choir, rate: 0.3 ein. Dein Programm-Code sollte dann so aussehen: live_loop :flibble do sample :ambi_choir, rate: 0.3 sample :bd_haus, rate: 1 sleep 1 end So, jetzt spiele damit herum. Ver\u00e4ndere die Werte f\u00fcr rate: \u2013 was passiert, wenn du hohe, niedrige oder negative Zahlen eintr\u00e4gst? Achte darauf, wie sich eine sehr kleine \u00c4nderung des rate: -Wertes auf das :ambi_choir -Sample auswirkt (z. B. 0.29)? Was passiert wenn du einen wirklich kleinen sleep -Wert eintr\u00e4gst? Probiere aus, ob du es so schnell machen kannst, dass du einen Stopp und eine Fehlermeldung deines Computers ausl\u00f6st, weil er nicht mehr hinterher kommt. (Wenn das geschieht, nimm einfach wieder einen gr\u00f6\u00dferen Wert f\u00fcr sleep und klicke wieder auf Ausf\u00fchren ). Versuche eine Zeile mit dem sample -Code auszukommentieren, indem du ein # an ihren Anfang schreibst: live_loop :flibble do sample :ambi_choir, rate: 0.3 # sample :bd_haus, rate: 1 sleep 1 end Beachte wie das Zeichen den Computer anweist die Zeile zu ignorieren - wir h\u00f6ren das Ergebnis des Befehls in dieser Zeile nicht mehr. Was hinter einem # steht ist ein Kommentar. Wir k\u00f6nnen dieses Zeichen in Sonic Pi benutzen, um Dinge schnell aus dem Mix zu entfernen und sp\u00e4ter wieder hinzuzuzuf\u00fcgen. Abschlie\u00dfend m\u00f6chte ich dir etwas unterhaltsames zum Spielen geben. Nimm den Code unten und kopiere ihn in einen freien Puffer. Versuche nicht mehr davon zu verstehen, als dass da zwei Loops sind \u2013 zwei Schleifen, die gleichzeitig laufen und sich endlos wiederholen. Jetzt tue, was du am besten kannst - experimentiere und spiele damit herum. Hier ein paar Vorschl\u00e4ge: \u00c4ndere die blauen Werte hinter rate: und achte darauf, wie sich das Sample ver\u00e4ndert. \u00c4ndere die sleep -Zeiten, und achte darauf, wie die beiden Schleifen mit unterschiedlicher Geschwindigkeit aneinander vorbei laufen. Versuche die auskommentierte Sample-Zeile zu aktivieren (entferne das # ) und genie\u00dfe den Klang einer umgekehrt abgespielten Gitarre. Probiere, die blauen Werte f\u00fcr mix: auf Werte zwischen 0 (nicht im Mix) und 1 (voll im Mix) zu \u00e4ndern. Denke daran Ausf\u00fchren zu klicken, dann h\u00f6rst du sofort beim n\u00e4chsten Durchlauf eines Loops deine \u00c4nderungen. Wenn irgendwas schiefgeht \u2013 macht nichts! Klicke auf Stopp , l\u00f6sche den kaputten Code im Puffer und fange mit einer frischen Kopie noch einmal von vorn an zu jammen. Am schnellsten lernst du, wenn du Fehler machst\u2026 live_loop :guit do with_fx :echo, mix: 0.3, phase: 0.25 do sample :guit_em9, rate: 0.5 end # sample :guit_em9, rate: -0.5 sleep 8 end live_loop :boom do with_fx :reverb, room: 1 do sample :bd_boom, amp: 10, rate: 1 end sleep 8 end Spiele solange herum und experimentiere, bis deine Neugierde einsetzt und du dich fragst, wie das hier alles eigentlich wirklich funktioniert, und was man noch so alles damit anstellen kann. Du bist jetzt bereit f\u00fcr den Rest dieses Tutorials. Also, worauf wartest du\u2026 1.2 Die Programmoberfl\u00e4che von Sonic Pi Sonic PI hat eine sehr einfache Oberfl\u00e4che f\u00fcr das Programmieren von Musik. Schauen wir sie uns einmal genauer an. A - Wiedergabe-Steuerung B - Editor-Steuerung C - Info und Hilfe D - Code-Editor E - Einstellungen F - Protokoll-Fenster G - Hilfe-System H - Oszilloskop F - Protokoll-Fenster A. Wiedergabe-Steuerung Mittels diesen pinkfarbenen Schaltfl\u00e4chen kannst du Kl\u00e4nge abspielen und stoppen. Die Ausf\u00fchren -Schaltfl\u00e4che startet den Programm-Code im Editor, Stopp h\u00e4lt den laufenden Programm-Code an, Speichern schreibt den Code in eine Datei und Aufnehmen nimmt die Kl\u00e4nge, die gerade zu h\u00f6ren sind (in einer WAV-Datei) auf. B. Editor-Steuerung Diese orangenen Schaltfl\u00e4chen erlauben dir, den Code-Editor zu manipulieren. Mit den Size + und Size - Kn\u00f6pfen kannst du den Text vergr\u00f6\u00dfern oder verkleinern. C. Information und Hilfe Die blauen Schaltfl\u00e4chen bieten dir Zugriff auf Informationen, die Hilfe und die Voreinstellungen. Der Info -Schalter \u00f6ffnet ein Fenster mit Informationen \u00fcber Sonic Pi selbst - das Entwickler-Team, Geschichte, Mitwirkende und Community. Der Help -Schalter zeigt/verbirgt das eingebaute Hilfesystem ( F ) und Prefs zeigt/verbirgt das Fenster, wo du einige grunds\u00e4tzliche Einstellungen vornehmen kannst. D. Code-Editor In diesem Bereich schreibst du deinen Code und komponierst und f\u00fchrst deine Musik auf. Es ist ein einfacher Texteditor, in dem du Code schreiben, l\u00f6schen, ausschneiden und einf\u00fcgen kannst u.s.w. Stelle es dir als sehr einfache Version von Word oder Google Docs vor. Der Editor f\u00e4rbt bestimmte Begriffe automatisch ein, je nachdem, welche Bedeutung sie innerhalb des Codes haben. Am Anfang mag dir das vielleicht ein wenig merkw\u00fcrdig erscheinen, aber du wirst es bald sehr n\u00fctzlich finden. Zum Beispiel erkennst du Zahlen sofort daran, dass sie blau sind. E. Einstellungen Sonic Pi enth\u00e4lt eine Reihe von ver\u00e4nderbaren Einstellungen, die \u00fcber den Prefs -Schalter im Info- und Hilfe-Men\u00fc erreicht werden k\u00f6nnen. In den Einstellungen sind einige Optionen verf\u00fcgbar, die ge\u00e4ndert werden k\u00f6nnen, darunter z. B.: Wechsel in den Mono-Modus, Tauschen der Stereokan\u00e4le, Einstellung der Ausf\u00fchrlichkeit der Protokoll-Ausgabe und ein Volumen-Regler. Auf einem Raspberry Pi kannst du hier auch das Ausgabemodul f\u00fcr den Ton ausw\u00e4hlen. F. Protokoll-Fenster Wenn du deinen Programm-Code laufen l\u00e4sst, siehst du im Protokoll-Fenster, was das Programm gerade tut. Standardm\u00e4\u00dfig siehst du eine Nachricht f\u00fcr jeden erzeugten Klang und die exakte Zeit, wann der Klang ausgel\u00f6st wurde. Bei der Suche nach Fehlern (Debugging) in deinem Programm-Code kann das sehr hilfreich sein, und du verstehst schneller, was dein Code macht. G. Hilfe-System Eines der wichtigsten Elemente des Sonic Pi Programmfensters ist das Hilfe-System, das am unteren Ende des Fensters auftaucht. Du kannst es ein- und ausblenden, indem du den blauen Hilfe -Schalter klickst. Das Hilfe-System zeigt Hilfe und Informationen zu allen Aspekten von Sonic Pi an, einschlie\u00dflich dieses Tutorials, einer Liste der mitgelieferten Synthesizer, Samples, Beispiele, Effekte (FX) sowie eine komplette Liste aller Funktionen (Sprachbefehle), die Sonic Pi zum Coden von Musik bereitstellt. H. Oszilloskop Das Oszilloskop kann dir die T\u00f6ne die du h\u00f6rst, anzeigen. Du kannst leicht erkennen, dass die S\u00e4gezahnwelle wie eine S\u00e4ge aussieht und der Beep wie eine kurvige Sinus-Welle. Du kannst auch den Unterschied zwischen lauten und leisen T\u00f6nen anhand der Gr\u00f6\u00dfe der Linien erkennen. Es gibt drei Oszilloskope, mit denen du spielen kannst. Standard ist ein aus dem linken und rechten Kanal kombiniertes Oszilloskop, es gibt daneben ein Stereo-Oszilloskop, das beide Kan\u00e4le einzeln anzeigt. Und zu guter Letzt gibt es das Lissajous-Oszilloskop, das dir die Phasen-Beziehung zwischen dem linken und rechten Kanal anzeigt - es erm\u00f6glicht dir auch das Zeichnen von Bildern mit Kl\u00e4ngen (https://de.wikipedia.org/wiki/Lissajous-Figur). I. Protokoll-Fenster Alle internen und externen Ereignisse (in Sonic Pi Cues genannt) werden automatisch im Cue-Protokoll angezeigt. Bet\u00e4tigst du zum Beispiel einen verbundenen MIDI-Controller, erscheint die Bezeichnung des bet\u00e4tigten Schalters/Reglers und des Controllers im Protokoll. Sobald du die Grundlagen der Erzeugung und Hervorbringung von Kl\u00e4ngen gemeistert hast, wirst du auch Cues f\u00fcr Kl\u00e4nge oder ganze Abschnitte von Kl\u00e4ngen mit diesen Mitteln steuern wollen. Cue-Ereignisse (cue events) sind Indikatoren daf\u00fcr, dass etwas geschehen ist. Zum Beispiel schickt ein Live-Loop jedes Mal wenn er eine Runde ausf\u00fchrt ein solches Cue-Ereignis, das im Cue-Protokoll angezeigt wird. Auch externe Ereignisse, wie MIDI-Signale von angeschlossenen MIDI-Ger\u00e4ten, und OSC-Signale von anderen Programmen und Computern werden im Cue-Protokoll angezeigt. Zudem ist es auch m\u00f6glich mithilfe der cue -Funktion Eintr\u00e4ge im Protokoll zu generieren. In den Abschnitten 10 bis 12 lernst du im einzelnen, wie du Protokoll-Eintr\u00e4ge als Trigger (Ausl\u00f6ser) f\u00fcr andere Abl\u00e4ufe benutzen kannst. 1.3 Lernen durch Spielen Sonic Pi ermutigt dich etwas \u00fcber Computer und Musik zu lernen - durch Spielen und Experimentieren. Das aller Wichtigste ist, dass du Spa\u00df hast, und bevor du es \u00fcberhaupt bemerkst, wirst du zuf\u00e4llig gelernt haben Code zu schreiben, Musik zu komponieren und aufzuf\u00fchren. Es gibt keine Fehler Wo wir gerade dabei sind, m\u00f6chte ich dir noch einen Rat geben, etwas das ich in den Jahren, in denen ich Musik live programmiert habe gelernt habe - es gibt keine Fehler, nur Gelegenheiten . Ich habe das oft im Bezug auf Jazz geh\u00f6rt, aber es trifft ebenso gut auf Live-Coding zu. Es spielt keine Rolle, wie viel Erfahrung du hast, ob du ein absoluter Anf\u00e4nger oder ein erfahrender Live-Coder bist. Du wirst Code laufen lassen, der vollkommen unerwartete Ergebnisse hervorbringt. Kann sein, dass es unglaublich cool klingt - dann mache da weiter. Wie dem auch sei, kann sein, dass es schrecklich klingt und vollkommen fehl am Platz ist. Es ist egal, wenn das passiert, wichtig ist, was du dann damit als N\u00e4chstes tust. Nimm den Klang, bearbeite ihn und verwandle ihn in etwas Tolles. Die Menge wird durchdrehen . Beginne einfach Wenn du lernst, willst du die tollen Sachen vielleicht am liebsten sofort machen. Halte solche Gedanken fest, aber sieh sie als ein Ziel an, welches du etwas sp\u00e4ter erreichen wirst. Denke zun\u00e4chst erst einmal an die einfachste Sache, die du schreiben kannst, die dir Spa\u00df machen w\u00fcrde und dir lohnend erscheint; diese Sache ist ein kleiner Schritt auf dem Weg zu den faszinierenden Dingen, die dir im Kopf herum gehen. Wenn dir die Idee zu diesem einfachen Schritt klar ist, versuche ihn umzusetzen, spiele damit herum und finde heraus, auf was f\u00fcr neue Ideen du dadurch kommst. Du wirst bald sehr viel Spa\u00df daran haben und echte Fortschritte machen. Stelle sicher, dass du deine Werke mit anderen teilst! 2 Synthesizer Ok, genug der Einf\u00fchrung - lasst uns Kl\u00e4nge machen. In diesem Abschnitt behandeln wir die Grundlagen des Triggerns (Ausl\u00f6sen) und Manipulierens von Synths. Synth ist die Kurzform von Synthesizer - dem genauen Wortlaut f\u00fcr etwas, das Kl\u00e4nge erzeugt. Typischerweise sind Synths ziemlich kompliziert im Gebrauch, vor allem analoge Synths wie Eurorack-Module, untereinander verbunden mit einem Durcheinander von Kabeln. Sonic Pi gibt dir eine Vielzahl solcher M\u00f6glichkeiten auf eine einfache und gut zug\u00e4ngliche Art. Lass dich nicht t\u00e4uschen von der einfachen Programmoberfl\u00e4che von Sonic Pi. Wenn du willst, kannst du damit sehr tief in sehr ausgekl\u00fcgelte Klangmanipulationen eintauchen. Also festhalten... 2.1 Deine ersten Beeps Sieh dir den folgenden Code an: play 70 Damit f\u00e4ngt alles an. Leg los, kopiere und setze das in das Code-Fenster oben im Programm ein (der gro\u00dfe wei\u00dfe Bereich unter der Ausf\u00fchren-Schaltfl\u00e4che). Nun klicke auf Ausf\u00fchren... Beep! Stark. Klicke die Schaltfl\u00e4che nochmal. Und nochmal. Und nochmal... Wow, verr\u00fcckt, ich bin sicher, du k\u00f6nntest das den ganzen Tag lang machen. Aber halt, bevor du dich in einem endlosen Strom von Piepst\u00f6nen verlierst, versuche es mit einer anderen Zahl: play 75 H\u00f6rst du den Unterschied? Nimm eine kleinere Zahl: play 60 Also, niedrigere Zahlen machen tiefere T\u00f6ne und h\u00f6here Zahlen h\u00f6here T\u00f6ne. Wie bei einem Klavier erzeugen, von links nach rechts gesehen, die niedrigeren Tasten weiter links tiefere T\u00f6ne als die h\u00f6heren Tasten weiter rechts, die h\u00f6here T\u00f6ne erzeugen. Es ist gut zu wissen, dass das C in der vierten Oktave mit der Zahl 60 bezeichnet wird. play 60 spielt also ein C der vierten Oktave. Um den n\u00e4chsth\u00f6heren Ton rechts davon auf der Klaviatur zu spielen, musst du 1 zu 60 addieren und play 61 schreiben. Das ist dann die schwarze Taste rechts vom C, ein Cis (oder C# in englischer Schreibweise). Um nun ein D, den n\u00e4chst h\u00f6heren Ton rechts davon, zu spielen, schreibe play 62 . Keine Sorge , wenn du keine Ahnung hast, was das alles bedeutet. Mir ging es genauso als ich anfing. F\u00fcr den Beginn reicht es v\u00f6llig zu wissen, niedrigere Zahlen bedeuten tiefere Kl\u00e4nge und h\u00f6here Zahlen bedeuten h\u00f6here Kl\u00e4nge . Akkorde Eine Note zu spielen kann ganz lustig sein, aber mehrere zur selben Zeit zu spielen ist noch besser. Versuche es: play 72 play 75 play 79 Jazzig! Wenn du also mehrere play s hinschreibst, spielen sie alle zur selben Zeit. Probiere selbst aus - welche Nummern klingen gut zusammen? Welche klingen f\u00fcrchterlich? Experimentiere, erforsche und finde es f\u00fcr dich selbst heraus. Melodie Einzelne Noten und Akkorde zu spielen macht Spa\u00df - aber wie w\u00e4re es mit einer Melodie? Was, wenn du eine Note nach der anderen spielen wolltest und nicht alle zur selben Zeit? Also, das ist ganz einfach, du brauchst nur ein sleep zwischen den Noten: play 72 sleep 1 play 75 sleep 1 play 79 Wie h\u00fcbsch, ein kleines Arpeggio. Was bedeutet die 1 in sleep 1 ? Sie gibt die Dauer von sleep an. Tats\u00e4chlich bedeutet das: Schlafe f\u00fcr einen Schlag. Aber vorl\u00e4ufig k\u00f6nnen wir uns vorstellen, dass es bedeutet: Schlafe f\u00fcr eine Sekunde. Wie k\u00f6nnten wir unser Arpeggio schneller ablaufen lassen? Dazu brauchen wir k\u00fcrzere Werte f\u00fcr sleep. Wie w\u00e4re es z. B. mit der H\u00e4lfte, also 0.5 : play 72 sleep 0.5 play 75 sleep 0.5 play 79 Achte darauf, wie die Melodie nun schneller spielt. Probiere es f\u00fcr dich selbst aus, \u00e4ndere die Zeiten - verwende unterschiedliche Zeiten und Noten. Versuche einmal Zwischennoten wie play 52.3 und play 52.63 . Es gibt \u00fcberhaupt keinen Grund, nur ganze Zahlen zu verwenden. Spiel damit herum und hab Spa\u00df dabei. Beachte dabei, dass Computer grunds\u00e4tzlich die englische Schreibweise f\u00fcr Zahlen verwenden - setze also stets einen Punkt vor die Nachkommastellen (sic!), kein Komma! Traditionelle Notennamen Beachte f\u00fcr das folgende, dass Sonic Pi die englischen Notennamen verwendet, Fis ist F sharp oder auch F# und Fes ist F flat bzw. Fb . Die Note H hei\u00dft im Englischen B . F\u00fcr die unter euch, die die musikalische Notation schon ein wenig kennen (keine Sorge, wenn nicht - du brauchst es nicht unbedingt) - vielleicht m\u00f6chtet ihr eine Melodie mit Notennamen anstelle von Zahlen schreiben, also C oder F#. Auch das geht mit Sonic Pi. Du kannst folgendes machen: play :C sleep 0.5 play :D sleep 0.5 play :E Denk daran, direkt vor den Notennamen einen Doppelpunkt : zu stellen, sodass dieser sich Pink f\u00e4rbt. Du kannst ebenfalls die Oktave festlegen, indem du eine Zahl direkt hinter den Notennamen schreibst: play :C3 sleep 0.5 play :D3 sleep 0.5 play :E4 Wenn du eine Note um einen Halbton erh\u00f6hen willst, f\u00fcge ein s hinzu, also play :Fs3 . Und wenn du eine Note um einen Halbton verringern m\u00f6chtest, f\u00fcge ein b an, also play :Eb3 . Es gibt auch eine praktische Abk\u00fcrzung f\u00fcr eine Pause (eine musikalische Art zu sagen, dass anstelle einer Note nichts gespielt werden soll) mit :r , :rest oder nil . Jetzt spiel' verr\u00fcckt und baue dir deine eigenen Melodien. 2.2 Synth-Optionen Genauso wie es dich steuern l\u00e4sst, welche Noten du erzeugst und welche Samples du abspielst, bietet dir Sonic Pi eine ganzen Bandbreite von Optionen, um die Kl\u00e4nge zu gestalten und zu steuern. Wir werden viele davon in diesem Tutorial behandeln, und f\u00fcr jede Option gibt es eine ausf\u00fchrliche Dokumentation im Hilfe-Fenster. F\u00fcr den Moment werden wir uns zun\u00e4chst zwei der n\u00fctzlichsten ansehen: Amplitude (Lautst\u00e4rke) und Pan (Panorama). Aber vorher will ich kurz erkl\u00e4ren, was Optionen eigentlich sind. Optionen Die Synths von Sonic Pi lassen sich \u00fcber verschiedene Optionen (oder kurz: Opts) ver\u00e4ndern. Opts sind Regler, die an play oder sample \u00fcbergeben werden; sie ver\u00e4ndern und steuern unterschiedliche Aspekte der Kl\u00e4nge, die du h\u00f6rst. Jeder Synth hat seinen eigenen Satz Opts, um den Klang fein einzustellen. Es gibt auch Opts, die f\u00fcr viele Kl\u00e4nge identisch sind, z.B. amp: und H\u00fcllkurven-Opts (die wir in einer anderen Sektion besprechen). Opts bestehen aus zwei Teilen, ihrem Namen (der Name des Reglers) und ihrem Wert (der Wert, auf den du den Regler setzten m\u00f6chtest). Zum Beispiel k\u00f6nntest du eine Option mit dem Namen cheese: haben, der du den Wert 1 geben m\u00f6chtest. Opts werden den Aufrufen von play und sample nach einem Komma , \u00fcbergeben, dem der Name der Option folgt, etwa amp: (vergiss den Doppelpunkt : nicht), dann eine Leerstelle und schlie\u00dflich der Wert der Option. Zum Beispiel: play 50, cheese: 1 ( cheese: ist keine g\u00fcltige Option, wir nehmen sie hier nur als Beispiel). Du kannst mehrere Opts hintereinander schreiben, indem du sie jeweils mit einem weiteren Komma abtrennst: play 50, cheese: 1, beans: 0.5 Die Reihenfolge der Opts spielt keine Rolle, so dass die folgende Zeile h\u00e4tte dasselbe Ergebnis: play 50, beans: 0.5, cheese: 1 Opts, die der Synth nicht kennt, ignoriert er einfach. (wie cheese und beans , die ja nun wirklich alberne Namen f\u00fcr Optionen sind!) Wenn du aus Versehen zweimal dieselbe Opt mit unterschiedlichen Werten benutzt, gewinnt die letzte. Im folgenden Beispiel wird beans den Wert 2 bekommen und nicht 0.5: play 50, beans: 0.5, cheese: 3, eggs: 0.1, beans: 2 Viele Dinge in Sonic Pi akzeptieren Optionen, also verbringe ein wenig Zeit damit zu lernen, wie du sie einsetzen kannst, und du wirst bald startklar sein! Spielen wir mal mit unserer ersten Opt: amp: . Amplitude Die Amplitude ist wie der Computer die Lautheit eines Klangs repr\u00e4sentiert. Eine hohe Amplitude bringt einen lauten Klang hervor , und eine niedrige Amplitude ergibt einen leisen Klang . So wie Sonic Pi Zahlen dazu benutzt, um Zeit und T\u00f6ne darzustellen, bildet es auch die Lautst\u00e4rke mit Hilfe von Zahlen ab. Eine Amplitude von 0 bedeutet Stille (du wirst nichts h\u00f6ren), eine Amplitude von 1 steht f\u00fcr normale Lautst\u00e4rke. Du kannst die Amplitude aufdrehen auf 2, 10, 100. Aber Vorsicht: Wenn die Amplitude aller gemeinsamen Kl\u00e4nge zu hoch wird, setzt Sonic Pi einen so genannten Kompressor ein, der sie zusammen quetscht, damit die Kl\u00e4nge nicht zu laut f\u00fcr dein Ohr werden. Oft klingt das dann matschig und schr\u00e4g. Verwende also lieber niedrige Amplituden, das hei\u00dft im Bereich zwischen 0 und 0.5, um Kompression zu verhindern. Amp aufdrehen Um die Amplitude eines Klangs zu \u00e4ndern, setze die Opt amp: ein. Um zum Beispiel mit halber Amplitude abzuspielen \u00fcbergebe 0.5: play 60, amp: 0.5 F\u00fcr die doppelte Amplitude \u00fcbergebe 2: play 60, amp: 2 Die amp: -Opt beeinflusst nur den Aufruf von play , mit der sie unmittelbar zusammenh\u00e4ngt. Das hei\u00dft, in dem folgenden Beispiel wird der erste Aufruf von play mit halber Lautst\u00e4rke gespielt und der zweite wieder mit der Standardlautst\u00e4rke (1): play 60, amp: 0.5 sleep 0.5 play 65 Nat\u00fcrlich kannst du f\u00fcr jeden Aufruf von play andere Werte f\u00fcr amp: festlegen: play 50, amp: 0.1 sleep 0.25 play 55, amp: 0.2 sleep 0.25 play 57, amp: 0.4 sleep 0.25 play 62, amp: 1 Panning Eine weitere interessante Opt ist pan: . Ihr Wert gibt an, aus welcher Richtung der Klang kommt, wenn wir in Stereo h\u00f6ren. Panning nach links bedeutet, dass du denKlang aus dem linken Lautsprecher und Panning nach rechts, dass du ihn aus dem rechten Lautsprecher h\u00f6rst. F\u00fcr unsere Werte benutzen wir -1 , um den Klang ganz nach links zu schieben, 0 steht f\u00fcr die Mitte und mit 1 schieben wir den Klang ganz nach rechts. Nat\u00fcrlich k\u00f6nnen wir jeden Wert zwischen -1 und 1 verwenden, um die Kl\u00e4nge exakt im Stereofeld zu positionieren. Lasst uns einen Beep nur aus dem linken Lautsprecher abspielen: play 60, pan: -1 Jetzt aus dem rechten Lautsprecher: play 60, pan: 1 Nun wollen wir den Klang aus der Mitte zwischen beiden Lautsprechern herauskommen lassen (die Standardposition): play 60, pan: 0 Jetzt leg' einfach los und ver\u00e4ndere die Amplitude und das Panning deiner Kl\u00e4nge! 2.3 Synths wechseln Bisher hatten wir viel Spa\u00df damit Piept\u00f6ne zu erzeugen. Aber wahrscheinlich langweilt es dich langsam, immer wieder denselben Klang zu h\u00f6ren. Ist das alles, was Sonic Pi zu bieten hat? Live-Coding kann doch sicher mehr als nur einen einfachen Piepton zu spielen? Aber klar doch! In diesem Abschnitt schauen wir uns die aufregende Vielfalt der Kl\u00e4nge, die uns Sonic Pi bietet, an. Synthesizer Sonic Pi verf\u00fcgt \u00fcber eine ganze Palette unterschiedlicher Instrumente, die es Synths nennt (kurz f\u00fcr Synthesizer - Klangerzeuger ). Wohingegen Samples bereits aufgenommene Kl\u00e4nge sind. Synths erzeugen neue Kl\u00e4nge, je nachdem, wie du sie steuerst (was wir sp\u00e4ter in diesem Tutorial untersuchen werden). Die Synths in Sonic Pi sind sehr kraftvoll und ausdrucksstark, und du wirst viel Spa\u00df damit haben sie zu erforschen und damit zu spielen. Lass uns zuerst lernen, wie ein Synth ausgew\u00e4hlt wird, um ihn zu verwenden. Brummende S\u00e4gen und Propheten Ein lustiger Klang ist die S\u00e4gezahn-Welle - probieren wir es mal aus: use_synth :saw play 38 sleep 0.25 play 50 sleep 0.25 play 62 Nehmen wir einen anderen Klang - den Prophet : use_synth :prophet play 38 sleep 0.25 play 50 sleep 0.25 play 62 Wie w\u00e4re es beide Kl\u00e4nge zu verbinden? Zuerst nacheinander: use_synth :saw play 38 sleep 0.25 play 50 sleep 0.25 use_synth :prophet play 57 Jetzt mehrere T\u00f6ne gleichzeitig (keine Pausen mit sleep zwischen aufeinander folgenden Aufrufen von play ): use_synth :tb303 play 38 use_synth :dsaw play 50 use_synth :prophet play 57 Achte darauf, wie das use_synth -Kommando nur die nachfolgenden play -Kommandos beeinflusst. Stell dir das wie einen gro\u00dfen Schalter vor - neue Aufrufe von play werden immer den Synth benutzen, auf den der Schalter gerade zeigt. Du kannst diesen Schalter mit use_synth auf einen anderen Synth umschalten. Synths entdecken Um zu entdecken welche Synths Sonic Pi f\u00fcr dich zum Spielen bereith\u00e4lt, schau im Synths-Option im Men\u00fc links unten im Hilfe-Fenster nach (gleich neben FX ). Es gibt \u00fcber 20 zur Auswahl. Hier sind einige meiner Favoriten: :prophet :dsaw :fm :tb303 :pulse Spiele ein bisschen herum und wechsle die Synths, w\u00e4hrend du spielst . Kombiniere unterschiedliche Synths, um neue Kl\u00e4nge zu erzeugen, oder setze sie f\u00fcr unterschiedliche Sektionen in deinem St\u00fcck ein. 2.4 Dauer bei H\u00fcllkurven In einem fr\u00fcheren Abschnitt haben wir gesehen, wie wir mit dem sleep -Kommando steuern k\u00f6nnen, dass unsere Kl\u00e4nge ausgel\u00f6st (getriggert) werden. Bislang konnten wir aber noch nicht die Dauer unserer K\u00e4nge steuern. Daf\u00fcr uns einfache und doch m\u00e4chtige Mittel zur Steuerung der Dauer unserer Kl\u00e4nge zu geben, verwendet Sonic Pi den Begriff der ADSR-H\u00fcllkurve (wir werden sp\u00e4ter in diesem Abschnitt die genaue Bedeutung von ADSR behandeln). Eine H\u00fcllkurve bietet f\u00fcr die Steuerung zwei praktische Eigenschaften: Steuerung der Dauer eines Klanges Steuerung der Lautst\u00e4rke eines Klanges Dauer Die Dauer beschreibt, wie lange ein Klang anh\u00e4lt. Eine l\u00e4ngere Dauer bedeutet, dass du den Klang l\u00e4nger h\u00f6ren kannst. Alle Kl\u00e4nge in Sonic Pi haben eine steuerbare H\u00fcllkurve, und die gesamte Dauer dieser H\u00fcllkurve bestimmt die Dauer des Klanges. Daher steuerst du mit der Dauer der H\u00fcllkurve die Dauer des Klanges. Amplitude Die ADSR-H\u00fcllkurve steuert nicht nur die Dauer, sondern erm\u00f6glicht dir auch eine genaue Kontrolle \u00fcber den Verlauf der Lautst\u00e4rke eines Klanges . Alle h\u00f6rbaren Kl\u00e4nge beginnen und enden mit Stille; alles was dazwischen liegt, ist nicht still. H\u00fcllkurven erlauben es dir, die Lautst\u00e4rke der h\u00f6rbaren Anteile des Klanges zu verschieben, zu verl\u00e4ngern und zu verk\u00fcrzen. Es ist so, als w\u00fcrdest du eine andere Person anweisen, wie sie mit dem Lautst\u00e4rkeregler einen Gitarren-Verst\u00e4rker lauter und leiser drehen soll. Du k\u00f6nntest sie z. B. bitten, \"fang mit Stille an, dreh die Lautst\u00e4rke langsam bis zum Anschlag hoch, lasse es eine Weile so und blende dann schnell runter, so dass es wieder still wird\". Genau diese Anweisungen zu geben erlaubt dir Sonic Pi mit H\u00fcllkurven. Wie wir bereits gesehen haben, bedeutet eine Amplitude von 0 Stille und eine Amplitude von 1 entspricht normaler Lautst\u00e4rke. Nun lasst uns auch einen Blick auf jeden einzelnen Teil einer H\u00fcllkurve werfen. Release-Zeit Der einzige Teil der H\u00fcllkurve den Sonic Pi standardm\u00e4\u00dfig einsetzt ist die Release-Zeit. Das ist die Dauer mit der ein Synth-Klang ausklingt. Alle Synths haben eine Release-Zeit von 1, was bedeutet, dass sie eine Dauer von 1 Beat haben (beim Standard-BPM-Wert 60 entspricht das genau 1 Sekunde): play 70 Diesen Ton wirst du 1 Sekunde lang h\u00f6ren. Probiere es aus und stoppe die Zeit :-) Dies ist die Kurzform der etwas l\u00e4ngeren, ausf\u00fchrlichen Variante: play 70, release: 1 Achte darauf, wie dieser Ton exakt gleich klingt (der Klang ist eine Sekunden lang zu h\u00f6ren). Aber jetzt ist es sehr einfach die Dauer \u00fcber die release: -Option zu ver\u00e4ndern: play 60, release: 2 Wir k\u00f6nnen den Synth mit einer sehr kurzen Release-Zeit sehr kurz klingen lassen: play 60, release: 0.2 Die Dauer des Ausklingens eines Klangs wird Release-Zeit ( release phase ) genannt. Standardm\u00e4\u00dfig bedeutet dies ein lineares Ausklingen (das entspricht einer gerade Linie). Das folgende Diagramm zeigt diesen \u00dcbergang: Die senkrechte Linie ganz links im Bild zeigt, dass der Klang mit einer Amplitude von 0 startet, jedoch sofort auf die volle H\u00f6he geht (das ist die Attack-Zeit, die wir gleich behandeln werden). Wenn die volle H\u00f6he erreicht ist, geht die Amplitude in einer geraden Linie bis auf Null zur\u00fcck, wobei dies so lange dauert, wie es mit release festgelegt wurde. Lange Release-Zeiten erzeugen ein langes Ausklingen des Synths. Du kannst daher mit der Release-Zeit die Dauer eines Klanges \u00e4ndern. Spiele damit - f\u00fcge deiner Musik unterschiedlichen Release-Zeiten hinzu. Attack-Zeit Standardm\u00e4\u00dfig ist die Attack-Zeit f\u00fcr alle Synths 0, das bedeutet, die Amplitude geht unmittelbar von 0 auf 1. Daher setzt der Synth mit einem perkussiven Klang ein. Du m\u00f6chtest den Klang vielleicht hingegen einblenden. Dies kann mit der attack -Opt erreicht werden. Versuche einige Kl\u00e4nge einzublenden: play 60, attack: 2 sleep 3 play 65, attack: 0.5 Du kannst mehrere Opts zur gleichen Zeit anwenden. Versuche zum Beispiel f\u00fcr eine kurze Attack-Zeit und eine lange Release-Zeit: play 60, attack: 0.7, release: 4 Diese H\u00fcllkurve mit einer kurzen Attack-Zeit und langer Release-Zeit sieht so aus: Du kannst es nat\u00fcrlich auch anders herum machen. Probiere eine lange Attack-Zeit und eine kurze Release-Zeit aus: play 60, attack: 4, release: 0.7 Letztlich kannst du auch eine kurze Attack- und Release-Zeit verwenden - f\u00fcr k\u00fcrzere Kl\u00e4nge. play 60, attack: 0.5, release: 0.5 Sustain-Zeit Zus\u00e4tzlich zu Attack- und Release-Zeiten kannst du auch eine Sustain-Zeit bestimmen. Diese ist die Zeitdauer, \u00fcber die der Klang anh\u00e4lt, wenn er die eingestellte Lautst\u00e4rke erreicht hat, also zwischen der Attack- und den Release-Phase. play 60, attack: 0.3, sustain: 1, release: 1 Die Sustain-Zeit ist n\u00fctzlich f\u00fcr wichtige Kl\u00e4nge, die du in einem Mix hervorheben willst, bevor sie eine optionale Release-Phase erreichen. Nat\u00fcrlich ist es ebenso m\u00f6glich sowohl den Wert f\u00fcr attack: als auch den f\u00fcr release: auf 0 zu setzen und nur den Sustain zu gebrauchen - ohne Ein- und Ausblendung. Aber Achtung, eine Release-Zeit von 0 kann h\u00f6rbare Klickger\u00e4usche verursachen, und es ist meist besser einen sehr kleinen Wert wie z. B. 0.2 zu verwenden. Decay-Zeit Auf einer weiteren Ebene kannst du auch eine Decay-Zeit festlegen. Das ist eine Phase innerhalb der H\u00fcllkurve, die zwischen der Attack- und der Release-Phase liegt. Die Decay-Zeit legt die Dauer der Phase fest, in der die Amplitude abf\u00e4llt - von attack_level: zu decay_level: (welches zun\u00e4chst den gleichen Wert hat wie sustain_level: , solange du den Wert f\u00fcr decay_level: nicht ausdr\u00fccklich vorgibst). Standardm\u00e4\u00dfig steht die Opt decay: auf 0, und sowohl Attack- als auch das Sustain-Level stehen auf 1. Damit die Decay-Zeit einen h\u00f6rbaren Effekt hat, musst du diese Pegel (Level) festlegen: play 60, attack: 0.1, attack_level: 1, decay: 0.2, sustain_level: 0.4, sustain: 1, release: 0.5 Decay-Level Ein weiterer Trick besteht darin, auch die Option decay_level: ausdr\u00fccklich auf einen anderen Wert zu setzen, da decay_level: ansonsten automatisch den Wert von sustain_level: erh\u00e4lt. So erlangst du die vollst\u00e4ndige Kontrolle \u00fcber die H\u00fcllkurve. Du kannst nun H\u00fcllkurven wie die folgende erzeugen: play 60, attack: 0.1, attack_level: 1, decay: 0.2, decay_level: 0.3, sustain: 1, sustain_level: 0.4, release: 0.5 Es ist auch m\u00f6glich f\u00fcr decay_level: ein h\u00f6herer Wert als f\u00fcr sustain_level: zu setzen: play 60, attack: 0.1, attack_level: 0.1, decay: 0.2, decay_level: 1, sustain: 0.5, sustain_level: 0.8, release: 1.5 ADSR-H\u00fcllkurven Fassen wir zusammen: Die ADSR-H\u00fcllkurven von Sonic Pi bestehen aus den folgenden Phasen: Attack - die Zeit in der die Amplitude von 0 zu attack_level \u00fcbergeht, Decay - die Zeit in der die Amplitude von attack_level zu sustain_level \u00fcbergeht, Sustain - die Zeit in der die Amplitude von decay_level zu sustain_level \u00fcbergeht, Release - die Zeit in der die Amplitude von sustain_level auf 0 \u00fcbergeht Es ist wichtig festzuhalten, dass die Dauer eines Klanges der Summe der Zeiten jeder einzelnen dieser Phasen entspricht. Daher hat der folgende Klang eine Dauer von 0.5 + 1 + 2 + 0.5 = 4 Schl\u00e4gen (Beats): play 60, attack: 0.5, attack_level: 1, decay: 1, sustain_level: 0.4, sustain: 2, release: 0.5 Nun leg los und spiele ein wenig damit herum deinen Kl\u00e4ngen H\u00fcllkurven hinzuzuf\u00fcgen... 3 Samples Eine weitere gro\u00dfartige M\u00f6glichkeit deine Musik zu entwickeln stellt die Verwendung bereits aufgenommener Kl\u00e4nge dar. In der gro\u00dfen Tradition des Hip-Hop nennen wir diese aufgenommenen Kl\u00e4nge auch Samples . Wenn du mit einem Mikrophon nach drau\u00dfen gehst und den zarten Klang von Regentropfen aufnimmst, die auf ein Zeltdach fallen - dann hast du ein Sample hergestellt. Mit Samples kannst du in Sonic Pi viele spa\u00dfige Sachen machen. Es hat nicht nur \u00fcber 130 freie Samples mit an Bord, mit denen du sofort jammen kannst, du kannst auch eigene Samples verwenden und manipulieren. Legen wir damit los... 3.1 Samples ansteuern Bleeps zu spielen ist nur der Anfang. Was auch eine Menge Spa\u00df macht, ist mit aufgenommenen Samples zu spielen. Probier's mal: sample :ambi_lunar_land Sonic Pi enth\u00e4lt viele Samples, mit denen du spielen kannst. Du kannst sie genauso benutzen wie du das play -Kommando benutzt. Um mehrere Samples gleichzeitig zu spielen, schreib sie einfach untereinander: play 36 play 48 sample :ambi_lunar_land sample :ambi_drone Wenn du sie \u00fcber die Zeit verteilt spielen willst, verwende den sleep -Befehl: sample :ambi_lunar_land sleep 1 play 48 sleep 0.5 play 36 sample :ambi_drone sleep 1 play 36 Achte darauf, dass Sonic Pi nicht wartet, bis ein Klang beendet ist, bevor es den n\u00e4chsten startet? Der sleep -Befehl beschreibt nur, in welchem Abstand ein Klang erneut getriggert (ausgel\u00f6st) wird. Dies erlaubt dir Kl\u00e4nge in Schichten \u00fcbereinander legen und interessante \u00dcberlappungseffekte herzustellen. Samples entdecken Du kannst die Samples, die Sonic Pi mitbringt, auf zwei Arten entdecken. Erstens kannst du dieses Hilfe-System benutzen. Klicke links unten im Men\u00fc auf Samples , w\u00e4hle eine Kategorie aus und du siehst eine Liste aller darin verf\u00fcgbaren Kl\u00e4nge. Alternativ kannst du das Auto-Completion System (Auto-Vervollst\u00e4ndigung) verwenden. Tippe einfach den Anfang des Namens einer Sample-Kategorie, wie z. B.: sample :ambi_ , dann klappt ein Men\u00fc mit allen dazu passenden Sample-Namen auf. Versuche einen der folgenden Anf\u00e4nge von Kategorie-Namen: :ambi_ :bass_ :elec_ :perc_ :guit_ :drum_ :misc_ :bd_ Jetzt leg los und mixe Samples in deine Kompositionen! 3.2 Sample-Parameter Genauso wie bei den Synths k\u00f6nnen wir unsere Kl\u00e4nge mit Parametern steuern. Samples unterst\u00fctzen genau den selben Parameter-Mechanismus. Besuchen wir unsere Freunde amp: und pan: noch einmal. Samples verst\u00e4rken Du kannst die Amplitude (Lautst\u00e4rke) von Samples genau mit der selben Methode steuern wie bei den Synths: sample :ambi_lunar_land, amp: 0.5 Samples pannen Wir k\u00f6nnen auch den pan: -Parameter auf Samples anwenden. Hier zum Beispiel spielen wir den Amen-Break zun\u00e4chst f\u00fcr das linke und nach der H\u00e4lfte nochmals f\u00fcr das rechte Ohr: sample :loop_amen, pan: -1 sleep 0.877 sample :loop_amen, pan: 1 0.877 ist genau die H\u00e4lfte der Dauer des Amen-Breaks in Sekunden. Beachte: Wenn du mit use_synth_defaults Grundeinstellungen f\u00fcr einen Synth setzt (was wir sp\u00e4ter behandeln werden), werden diese von Samples ignoriert. 3.3 Samples dehnen Jetzt k\u00f6nnen wir schon eine Reihe Synths und Samples spielen, um damit Musik zu machen. Es wird Zeit zu lernen, wie wir diese Synths und Samples ver\u00e4ndern k\u00f6nnen, um unsere Musik einzigartiger und spannender zu gestalten. Als Erstes erkunden wir, wie sich Samples strecken und stauchen lassen. Samples Representation Samples sind aufgenommene Kl\u00e4nge, gespeichert als eine Reihe von Zahlen, die repr\u00e4sentieren wie die Lautsprechermembran sich bewegen muss, um den Klang wiederzugeben. Die Lautsprechermembran kann sich nach innen und nach au\u00dfen bewegen und die Zahlen geben deshalb an, wie weit sich die Membran zu jedem Zeitpunkt nach innen oder au\u00dfen bewegen muss. Um einen Klang als Aufnahme wirklichkeitsgetreu wiederzugeben, muss das Sample f\u00fcr jede Sekunde viele tausend Zahlen speichern! Sonic Pi nimmt diese Zahlenreihe und gibt sie in der richtigen Geschwindigkeit (sample rate) aus, um den Lautsprecher in deinem Computer genau so bewegen, dass der Klang richtig wiedergegeben wird. Es macht aber auch Spa\u00df, die Geschwindigkeit mit der die Zahlen ausgegeben werden zu \u00e4ndern, um den Klang zu ver\u00e4ndern. Geschwindigkeit \u00e4ndern Lass uns mit einem der Ambient-Kl\u00e4nge spielen: :ambi_choir . Um die Standard-Geschwindigkeit zu ver\u00e4ndern kannst du die Opt rate: an sample \u00fcbergeben: sample :ambi_choir, rate: 1 Das Sample wird unver\u00e4ndert mit der Standard-Geschwindigkeit (1) abgespielt, also nichts Besonderes. Aber wir k\u00f6nnen die Zahl jederzeit ver\u00e4ndern. Wie w\u00e4r's mit 0.5 ? sample :ambi_choir, rate: 0.5 Wow! Was ist denn jetzt los? Also, hier passieren zwei Dinge. Erstens braucht das Sample doppelt so lange und zweitens klingt er eine Oktave niedriger. Sehen wir uns das ein bisschen genauer an. Lasst uns stretchen Mit dem Amen-Break-Sample macht das Strecken und Stauchen besonders viel Spa\u00df. Bei normaler Geschwindigkeit w\u00fcrden wir es vielleicht in einem Drum 'n' Bass -Track verwenden: sample :loop_amen Aber mit einer anderen Geschwindigkeit passt es auch zu anderen Stilen. Probiere es aus mit halber Samplerate f\u00fcr Hip-Hop alter Schule : sample :loop_amen, rate: 0.5 Wenn wir es beschleunigen, erreichen wir Jungle -Territorium: sample :loop_amen, rate: 1.5 Und als letzten Party-Trick - schauen wir mal, was passiert, wenn wir eine negative Rate angeben: sample :loop_amen, rate: -1 Wow! Das Sample spielt r\u00fcckw\u00e4rts ! Jetzt probiere mit vielen unterschiedlichen Samples und unterschiedlichen Sampleraten herum. Versuch es mit sehr hohen oder mit verr\u00fcckt langsamen Geschwindigkeiten. Finde heraus, welche spannenden Kl\u00e4nge du produzieren kannst. Eine einfache Erkl\u00e4rung der Samplerate Ein n\u00fctzlicher Weg ist sich Samples als Sprungfedern vorzustellen. Samplerate (auch Abtastrate) ist, als ob man die Sprungfeder zusammendr\u00fcckt oder auseinanderzieht. Wenn du ein Sample mit derRate 2 abspielst, dr\u00fcckst du die Feder zusammen, bis sie nur noch die H\u00e4lfte ihrer normalen L\u00e4nge hat. Das Sample braucht nur die H\u00e4lfte der Abspielzeit, weil es k\u00fcrzer ist. Wenn du das Sample mit halber Rate abspielst, ziehst du die Feder auf ihre doppelte L\u00e4nge auseinander. Das Sample braucht nun doppelt so lange, weil es l\u00e4nger ist. Je mehr Du quetscht (h\u00f6here Rate), desto k\u00fcrzer das Sample, je mehr du streckst (geringere Rate), desto l\u00e4nger das Sample. Wenn du eine Sprungfeder zusammendr\u00fcckt, erh\u00f6hst du ihre Dichte (die Anzahl der Windungen je Zentimeter) - das entspricht einem Sample, das h\u00f6her klingt . Wenn du die Sprungfeder auseinanderziehst, verringerst du ihre Dichte, entspricht das einem, das tiefer klingt . Die Mathematik hinter der Samplerate (Dieser Abschnitt ist f\u00fcr diejenigen gedacht, die an den Details interessiert sind. Er kann gerne \u00fcbersprungen werden...) Wie wir oben gesehen haben, wird ein Sample durch eine lange Reihe von Zahlen dargestellt, die der Lautsprechermembran sagen, wo sie im Verlauf der Zeit sein soll. Wir k\u00f6nnen diese Zahlenreihe nehmen, um eine Kurve zu zeichnen, die ungef\u00e4hr so aussieht: Vielleicht hast du Bilder wie dieses schon einmal gesehen. Das ist die Waveform (Wellenform) eines Samples. Es ist einfach eine Kurve aus Zahlenwerten. Typischerweise besteht eine Kurve wie diese aus 44100 Datenpunkten je Sekunde (das hat mit dem Nyquist-Shannon-Abtasttheorem zu tun). Wenn also das Sample 2 Sekunden dauert, dann wird die Kurve aus 88200 Zahlen gebildet, die wir an den Lautsprecher mit einer Rate von 44100 Datenpunkten pro Sekunde senden. Nat\u00fcrlich k\u00f6nnten wir das Sample mit der doppelten Abtastrate senden, also 88200 Datenpunkten pro Sekunde. Dann w\u00fcrde das Sample nur eine Sekunde lang dauern. Wir k\u00f6nnen es auch mit der halben Rate abspielen; das w\u00e4ren dann 22050 Datenpunkte pro Sekunde und w\u00fcrde 4 Sekunden dauern. Die Dauer des Samples ist abh\u00e4ngig von der Abtastrate: Wird die Abtastrate verdoppelt, halbiert das die Abspielzeit, Wird die Abtastrate halbiert, dann verdoppelt das die Abspielzeit, Eine Abtastrate von einem Viertel vervierfacht die Abspielzeit, Bei Verwendung einer Abtastrate von 1/10 dauert die Abspielzeit 10 mal l\u00e4nger. Wir k\u00f6nnen das in einer Formel abbilden: neue_sample_dauer = (1 / rate) * sample_dauer Eine Ver\u00e4nderung der Samplerate beeinflusst auch die Tonh\u00f6he des Samples. Die Frequenz oder Tonh\u00f6he einer Kurve wird dadurch bestimmt, wie schnell sie hoch und runter geht. Unser Gehirn macht aus schnellen Bewegungen einer Lautsprechermembran hohe T\u00f6ne und aus langsamen tiefe T\u00f6ne. Deshalb kannst du manchmal sogar sehen, wie sich ein gro\u00dfer Basslautsprecher bewegt, wenn er einen sehr tiefen Ton ausgibt - tats\u00e4chlich bewegt er sich dann wesentlich langsamer als ein Lautsprecher, der hohe T\u00f6ne wiedergibt. Wenn du eine Wellenform nimmst und sie zusammendr\u00fcckst, wird sie in jeder Sekunde h\u00e4ufiger hoch und runter gehen. Das l\u00e4sst den Ton h\u00f6her klingen. Es zeigt sich, dass die Tonh\u00f6he sich verdoppelt, wenn die Auf- und Abbewegungen pro Sekunde (Oszillationen) verdoppelt werden. Also, wenn du dein Sample mit doppelter Rate abspielst, wird es auch doppelt so hoch klingen , und anders herum wird eine Halbierung der Rate die Frequenz halbieren . Entsprechend werden auch andere Raten die Tonh\u00f6he beeinflussen. 3.4 Samples mit H\u00fcllkurven Es ist auch m\u00f6glich, die Dauer und Amplitude eines Samples mit einer ADSR-H\u00fcllkurve zu ver\u00e4ndern. Das funktioniert jedoch ein wenig anders als bei den ADSR-H\u00fcllkurven f\u00fcr Synths. Sample-H\u00fcllkurven k\u00f6nnen die Amplitude und die Dauer eines Samples nur verringern - niemals vergr\u00f6\u00dfern. Das Sample wird entweder stoppen, wenn seine normale Laufzeit vorbei ist, oder wenn die H\u00fcllkurve des Samples endet - je nach dem was zuerst passiert. Mit einem sehr langen release: l\u00e4sst sich die Dauer eines Samples nicht verl\u00e4ngern. Amen-H\u00fcllkurven Kommen wir zu unserem vertrauten Freund zur\u00fcck, dem Amen-Break: sample :loop_amen Ohne Opts h\u00f6ren wir das Sample in seiner gesamten L\u00e4nge und mit voller Lautst\u00e4rke. Wenn wir es \u00fcber 1 Sekunde einblenden wollen, k\u00f6nnen wir den attack: -Parameter verwenden: sample :loop_amen, attack: 1 W\u00e4hle f\u00fcr ein k\u00fcrzeres Einblenden einen k\u00fcrzeren Attack-Wert: sample :loop_amen, attack: 0.3 Auto-Sustain Wo sich das Verhalten der ADSR-H\u00fcllkurve von der H\u00fcllkurve f\u00fcr Standard-Synths unterscheidet ist der Sustain -Wert. Bei der H\u00fcllkurve f\u00fcr Standard-Synths steht der Sustain standardm\u00e4\u00dfig auf 0 - solange du den Wert nicht ausdr\u00fccklich setzt. Bei Samples steht der Sustain-Wert standardm\u00e4\u00dfig auf automagical - das ist in jedem Moment die Zeit, die es braucht, bis der Rest des Samples abgelaufen ist. Darum h\u00f6ren wir das Sample komplett, wenn wir keine Default-Werte \u00fcbergeben. Wenn die Werte f\u00fcr Attack, Decay, Sustain und Release alle auf 0 st\u00fcnden, w\u00fcrden wir keinen Pieps h\u00f6ren. Daher berechnet Sonic Pi, wie lange das Sample an sich dauert, zieht jegliche Werte f\u00fcr Attack, Decay und Release davon ab und setzt die restliche Zeit als Sustain-Wert. Wenn die Werte von Attack, Decay und Release zusammengerechnet l\u00e4nger dauern als das gesamte Sample, wird der Sustain-Wert einfach auf 0 gesetzt. Ausblenden Um das auszuprobieren, schauen wir uns den Amen-Break im Detail an. Wenn wir Sonic Pi fragen, wie lang das Sample ist: print sample_duration :loop_amen Wird 1.753310657596372 ausgeben, was der L\u00e4nge des Sample in Sekunden entspricht. Wir runden das zur Vereinfachung auf 1.75 ab. Wenn wir nun den Release-Wert auf 0.75 setzen, wird etwas erstaunliches passieren: sample :loop_amen, release: 0.75 Die erste Sekunde des Sample wird mit voller Lautst\u00e4rke gespielt, danach wird \u00fcber eine Periode von 0.75 Sekunden ausgeblendet. Das ist der Auto-Sustain in Aktion. Standardm\u00e4\u00dfig berechnet Sonic Pi den Release immer vom Ende des Samples aus gesehen. Wenn unser Sample 10.75 Sekunden lang w\u00e4re, w\u00fcrden die ersten 10 Sekunden in voller Lautst\u00e4rke gespielt, bevor \u00fcber 0.75 Sekunden das Ausblenden erfolgt. Merke: Normalerweise blendet release: das Ende des Sample aus. Ein- und Ausblenden Wir k\u00f6nnen beide, attack: und release: , gemeinsam mit dem Auto-Sustain nutzen, um \u00fcber die Dauer des Samples ein- und auszublenden: sample :loop_amen, attack: 0.75, release: 0.75 Da die Gesamtdauer des Sample 1.75s betr\u00e4gt und unsere Attack- und Release-Phasen zusammen 1.5s ergeben, erh\u00e4lt die Sustain-Phase automatisch eine L\u00e4nge von 0.25s. So ist es ganz einfach, das Sample ein- und auszublenden. Ausdr\u00fccklicher Sustain Wir k\u00f6nnen ohne weiteres wieder das normale Synth-ADSR-Verhalten aktivieren, indem wir sustain: auf den Wert 0 setzen: sample :loop_amen, sustain: 0, release: 0.75 Jetzt spielt unser Sample insgesamt nur f\u00fcr 0.75 Sekunden. Mit dem Standardwert 0 f\u00fcr attack: und decay: springt das Sample direkt auf die volle Lautst\u00e4rke, bleibt dort f\u00fcr 0s und f\u00e4llt dann innerhalb der Release-Phase mit einer Dauer von 0.75s auf die Lautst\u00e4rke 0 ab. Perkussive Becken Wir k\u00f6nnen dieses Verhalten gut dazu benutzen, um l\u00e4nger klingende Samples in k\u00fcrzere, perkussivere Versionen zu verwandeln. Sieh dir das Sample :drum_cymbal_open an: sample :drum_cymbal_open Du kannst h\u00f6ren, wie das Becken eine Zeit lang ausklingt. Mit einer leicht ver\u00e4nderten H\u00fcllkurve k\u00f6nnen wir es perkussiver klingen lassen: sample :drum_cymbal_open, attack: 0.01, sustain: 0, release: 0.1 Du kannst den Eindruck eines Anschlagens und Abd\u00e4mpfens des Beckens erzeugen, indem du die Sustain-Phase erh\u00f6hst: sample :drum_cymbal_open, attack: 0.01, sustain: 0.3, release: 0.1 Jetzt versuche H\u00fcllkurven \u00fcber Samples zu legen. Ver\u00e4ndere auch die Samplerate - damit kannst du wirklich interessante Ergebnisse erzielen. 3.5 Teil-Samples Dieser Abschnitt schlie\u00dft unsere Erkundung von Sonic Pi's Sample-Player ab. Fassen wir noch einmal zusammen. Wir haben uns angesehen, wie wir Samples abspielen k\u00f6nnen: sample :loop_amen Dann haben wir gesehen, dass wir die Samplerate \u00e4ndern k\u00f6nnen - etwa um ein Sample mit halber Geschwindigkeit abzuspielen: sample :loop_amen, rate: 0.5 Als n\u00e4chstes haben wir einen Blick darauf geworfen, wie wir ein Sample ein- und ausblenden k\u00f6nnen (z. B. mit halber Geschwindigkeit): sample :loop_amen, rate: 0.5, attack: 1 Wir haben uns auch angeschaut, wie wir einen Sample-Anfang perkussiver klingen lassen k\u00f6nnen, indem wir sustain: ausdr\u00fccklich einen Wert zuweisen, und sowohl Attack als auch Release auf kurze Werte setzen: sample :loop_amen, rate: 2, attack: 0.01, sustain: 0, release: 0.35 W\u00e4re es aber nicht toll, wenn wir ein Sample nicht immer vom Anfang starten lassen m\u00fcssten? W\u00e4re es nicht auch toll, wenn wir das Sample nicht immer erst am Ende stoppen k\u00f6nnten? Einen Startpunkt bestimmen Es ist m\u00f6glich einen beliebigen Startpunkt in einem Sample als Wert zwischen 0 und 1 auszuw\u00e4hlen. Dabei ist 0 der Anfang, 1 das Ende und 0.5 die Mitte des Samples. Versuchen wir also jetzt nur die zweite H\u00e4lfte des Amen Break zu spielen: sample :loop_amen, start: 0.5 Wie w\u00e4re es mit nur dem letzten Viertel des Samples: sample :loop_amen, start: 0.75 Einen Endpunkt bestimmen Auf \u00e4hnliche Weise k\u00f6nnen wir mit einem Wert zwischen 0 und 1 einen beliebigen Endpunkt im Sample festlegen. Beenden wir den Amen-Break nach der ersten H\u00e4lfte: sample :loop_amen, finish: 0.5 Start- und Endpunkt bestimmen Nat\u00fcrlich k\u00f6nnen wir diese beiden auch kombinieren, um so einen beliebigen Abschnitt des Samples abzuspielen. Wie w\u00e4re es mit nur einem kurzen Abschnitt in der Mitte: sample :loop_amen, start: 0.4, finish: 0.6 Was passiert, wenn wir eine Startposition hinter der Endposition ausw\u00e4hlen? sample :loop_amen, start: 0.6, finish: 0.4 Cool! Es spielt r\u00fcckw\u00e4rts! Kombinieren mit Samplerate Wir k\u00f6nnen diese neue F\u00e4higkeit, beliebige Abschnitte eines Klangs zu spielen, unserem Freund rate: kombinieren. Zum Beispiel k\u00f6nnen wir einen sehr kurzen Abschnitt des Amen-Breaks sehr langsam spielen: sample :loop_amen, start: 0.5, finish: 0.7, rate: 0.2 Kombinieren mit H\u00fcllkurven Und schlie\u00dflich k\u00f6nnen wir all dies mit unseren ADSR-H\u00fcllkurven kombinieren, um interessante Ergebnisse hervorzubringen: sample :loop_amen, start: 0.5, finish: 0.8, rate: -0.2, attack: 0.3, release: 1 Jetzt leg los und vermansche Samples mit all diesem spa\u00dfigen Zeug... 3.6 Externe Samples W\u00e4hrend die mitgelieferten Samples die schnell an den Start bringen und loslegen lassen, m\u00f6chtest du vielleicht aber mit anderen aufgenommenen Kl\u00e4ngen in deiner Musik experimentieren. Sonic Pi unterst\u00fctzt das ausdr\u00fccklich. Lass uns aber zun\u00e4chst \u00fcber die \u00dcbertragbarkeit deines St\u00fccks sprechen. \u00dcbertragbarkeit Wenn du dein St\u00fcck nur basierend auf den eingebauten Synths und Samples komponierst, braucht es nur den Code, um deine Musik originalgetreu wiederzugeben. Denke einen Augenblick dar\u00fcber nach - das ist erstaunlich! Ein einfaches St\u00fcck Text, das du per E-Mail herumschicken oder in einem Gist ablegen kannst, repr\u00e4sentiert alles, was du brauchst, um deine Kl\u00e4nge zu reproduzieren. Das macht es sehr einfach mit deinen Freunden zu teilen. Sie brauchen nur den Code von dir. Wie auch immer, wenn du anf\u00e4ngst selbst aufgenommene Samples zu verwenden, verlierst du diese \u00dcbertragbarkeit. Das liegt daran, dass die Leute, um deine Musik zu reproduzieren nicht nur den Code, sondern auch deine Samples ben\u00f6tigen. Das schr\u00e4nkt die M\u00f6glichkeit f\u00fcr andere ein, mit deiner Arbeit zu experimentieren, sie zu ver\u00e4ndern, sie zu vermanschen (mash-up). Nat\u00fcrlich sollte dich das nicht davon abhalten deine eigenen Samples zu verwenden, es ist nur etwas, das du in deine \u00dcberlegungen einbeziehen solltest. Lokale Samples Wie geht das nun, eine beliebige WAV-, AIFF- oder FLAC-Datei von deinem Computer abzuspielen? Alles was du daf\u00fcr tun musst ist sample den Pfad zu der Datei zu \u00fcbergeben: # Raspberry Pi, Mac, Linux sample \"/Users/sam/Desktop/my-sound.wav\" # Windows sample \"C:/Users/sam/Desktop/my-sound.wav\" Sonic Pi wird das Sample nun automatisch laden und spielen. Du kannst auch all die Standard-Parameter, die du bereits kennst, an sample \u00fcbergeben: # Raspberry Pi, Mac, Linux sample \"/Users/sam/Desktop/my-sound.wav\", rate: 0.5, amp: 0.3 # Windows sample \"C:/Users/sam/Desktop/my-sound.wav\", rate: 0.5, amp: 0.3 3.7 Sample-Pakete Hinweis: Dieser Abschnitt des Tutorials behandelt das fortgeschrittene Thema der Arbeit mit gro\u00dfen Verzeichnissen deiner eigenen Samples. Dies wird n\u00fctzlich sein, wenn du deine eigenen Sample Packs heruntergeladen oder gekauft hast und diese in Sonic Pi nutzen m\u00f6chtest. \u00dcberspringe diesen Abschnitt, wenn dir die mitgelieferten Samples f\u00fcr die Arbeit ausreichen. Wenn du mit gro\u00dfen Ordnern mit externen Samples arbeitest, kann es m\u00fchselig sein, jedes Mal den vollst\u00e4ndigen Pfad eingeben zu m\u00fcssen, um ein bestimmtes Sample abzuspielen. Sagen wir, du hast zum Beispiel folgenden Ordner auf deinem Computer: /pfad/zu/meinen/samples/ Wenn wir in diesen Ordner schauen, finden wir die folgenden Samples: 100_A#_melody1.wav 100_A#_melody2.wav 100_A#_melody3.wav 120_A#_melody4.wav 120_Bb_guit1.wav 120_Bb_piano1.wav \u00dcblicherweise k\u00f6nnen wir den vollst\u00e4ndigen Pfad nutzen um das Piano-Sample abzuspielen: sample \"/pfad/zu/meinen/samples/120_Bb_piano1.wav\" Wenn wir dann das Gitarren-Sample abspielen wollen, k\u00f6nnen wir ebenfalls den vollst\u00e4ndigen Pfad nutzen: sample \"/pfad/zu/meinen/samples/120_Bb_guit.wav\" Wie auch immer, beide Aufrufe verlangen von uns, dass wir die Namen der Samples innerhalb des Verzeichnisses kennen . Was, wenn wir einfach nur schnell die einzelnen Samples nacheinander abh\u00f6ren wollen? Sample-Packs indizieren Wenn wir das erste Sample in einem Verzeichnis abspielen wollen, m\u00fcssen wir nur den Verzeichnisnamen an sample und den Index 0 eingeben. Folgenderma\u00dfen: sample \"/pfad/zu/meinen/samples/\", 0 Wir k\u00f6nnen sogar eine Verkn\u00fcpfung zu unserem Verzeichnispfad anlegen, indem wir eine Variable nutzen: samps = \"/pfad/zu/meinen/samples/\" sample samps, 0 Wenn wir nun das zweite Sample in unserem Verzeichnis abspielen wollen, m\u00fcssen wir lediglich 1 zu unserem Index hinzuf\u00fcgen: samps = \"/pfad/zu/meinen/samples/\" sample samps, 1 Beachte, dass wir nicht mehr die Namen der Samples im Verzeichnis kennen m\u00fcssen - wir m\u00fcssen nur das Verzeichnis selbst kennen (oder eine Verkn\u00fcpfung dort hin). Wenn wir nach einer Index-Zahl fragen, die gr\u00f6\u00dfer ist als die Anzahl an Samples, f\u00e4ngt die Liste einfach von vorne an - wie bei Ringen. Also egal welche Index-Zahl wir nutzen, es ist garantiert, dass wir eines der Samples aus dem Verzeichnis bekommen. Sample-Packs filtern Gew\u00f6hnlich reicht das Indizieren aus, aber manchmal ben\u00f6tigen wir machtvollere Mittel, um unsere Samples zu organisieren. Gl\u00fccklicherweise packen viele Sample-Packs n\u00fctzliche Informationen in die Dateinamen. Lass uns einen weiteren Blick auf die Dateinamen der Samples in unserem Verzeichnis werfen: 100_A#_melody1.wav 100_A#_melody2.wav 100_A#_melody3.wav 120_A#_melody4.wav 120_Bb_guit1.wav 120_Bb_piano1.wav Achte darauf, dass In diesen Dateinamen einiges an Informationen enthalten ist. Zuerst haben wir die BPM (\"beats per minute\") des Samples am Beginn. D.h. das Piano-Sample ist in 120 BPM und unsere ersten drei Melodien sind in 100 BPM. Au\u00dferdem steht in den Sample-Namen die Tonart. Das Gitarren-Sample ist in Bb, und die Melodien sind in A#. Diese Information ist f\u00fcr das Mixen der Samples mit unserem Code sehr wichtig. Zum Beispiel wissen wir, dass wir das Piano-Sample nur mit Code verwenden k\u00f6nnen, der 120 BPM und die Tonart Bb hat. Es stellt sich heraus, dass wir dies spezielle Namensgebung unserer Sample-Sets im Code nutzen k\u00f6nnen, um die Samples herauszufiltern, die wir wollen. Wenn wir zum Beispiel mit 120 BPM arbeiten, k\u00f6nnen wir mit folgendem Code alle Samples filtern, deren Name den String \"120\" enth\u00e4lt: samps = \"/pfad/zu/meinen/samples/\" sample samps, \"120\" Dieser Code wird uns das erste passende Sample abspielen. Wenn wir das zweite passende Sample abspielen wollen, m\u00fcssen wir nur eine Index-Zahl nutzen: samps = \"/pfad/zu/meinen/samples/\u201c sample samps, \"120\", 1 Wir k\u00f6nnen sogar mehrere Filter gleichzeitig nutzen. Wenn wir ein Sample wollen, dessen Name sowohl den String \"120\" als auch den String \"A#\" enth\u00e4lt, k\u00f6nnen wir das leicht mit dem folgenden Code erreichen: samps = \"/pfad/zu/meinen/samples/\" sample samps, \"120\", \"A#\" Schlie\u00dflich k\u00f6nnen wir auch noch unsere \u00fcblichen Optionen dem sample -Aufruf anh\u00e4ngen: samps = \"/pfad/zu/meinen/samples/\" sample samps, \"120\", \"Bb\", 1, lpf: 70, amp: 2 Quellen Das Filter-System f\u00fcr Samples versteht zwei Typen von Informationen: Quellen und Filter. Quellen sind Informationen, um eine Liste m\u00f6glicher Kandidaten zu versammeln. Eine Quelle kann in zwei Formen angegeben werden: \"/pfad/zu/samples\" - eine Zeichenkette (string), die einen g\u00fcltigen Pfad zu einem Verzeichnis angibt \"/pfad/zu/samples/foo.wav\" - eine Zeichenkette (string), die einen g\u00fcltigen Pfad zu einem Sample angibt Die sample -Funktion sammelt alle Quellen und erzeugt daraus eine lange Liste von Kandidaten. F\u00fcr diese Liste durchsucht die Funktion zun\u00e4chst alle g\u00fcltigen Verzeichnispfade und f\u00fcgt dann alle darin enthaltenen Dateien in den Formaten .flac , .aif , .aiff , .wav , .wave hinzu. Schau Dir z. B. den folgenden Code an: samps = \"/pfad/zu/meinen/samples/\" samps2 = \"/pfad/zu/meinen/samples2/\" path = \"/pfad/zu/meinen/samples3/foo.wav\" sample samps, samps2, path, 0 Hier kombinieren wir alle Samples aus zwei Verzeichnissen und f\u00fcgen noch ein einzelnes Sample hinzu. Wenn \"/pfad/zu/meinen/samples/\" 3 Samples und \"/path/to/my/samples2/\" 12 Samples enthielte, h\u00e4tten wir insgesamt 16 m\u00f6gliche Samples, die wir indexieren und filtern k\u00f6nnen (3 + 12 + 1). Standardm\u00e4\u00dfig werden nur die Sample-Dateien des angegebenen Verzeichnisses in der Kandidatenliste gesammelt. Manchmal m\u00f6chtest du vielleicht eine ganze Reihe ineinander verschachtelter Ordner mit Samples durchsuchen und filtern. Das kannst du mit einer rekursiven Suche nach allen Samples in allen Unterordnern erreichen, indem du ** an das Ende des Pfads h\u00e4ngst: samps = \"/path/to/nested/samples/**\" sample samps, 0 Beachte jedoch, dass eine Suche \u00fcber viele Verzeichnisse hinweg viel Zeit in Anspruch nehmen kann. Allerdings wird der Inhalt aller Ordner, die du als Quellen angegeben hast, zwischengespeichert - die Verz\u00f6gerung wird also nur bei der ersten Suche auftreten. Ein wichtiger Punkt zum Abschluss: Die Quelle muss als erstes angegeben werden . Wenn keine Quelle angegeben wird, werden die mitgelieferten Samples als die Standardliste der Kandidaten ausgew\u00e4hlt, mit denen du dann weiter arbeitest. Filter Wenn du erst einmal eine Kandidatenliste hast, kannst du die folgenden Filtertypen nutzen, um die Auswahl weiter einzugrenzen: \"foo\" filtert alle Dateinamen, in denen diese Zeichenkette vorkommt (abz\u00fcglich des Verzeichnispfades und der Dateiendung). /fo[oO]/ filtert alle Dateinamen, die diesem regul\u00e4ren Ausdruck entsprechen (abz\u00fcglich des Verzeichnispfades und der Dateiendung). :foo - filtert alle Kandidaten, bei denen dieses Schl\u00fcsselwort genau dem Dateinamen entspricht (abz\u00fcglich des Verzeichnispfades und der Dateiendung). lambda{|a| ... } - Procs mit einem Argument werden als Filter f\u00fcr Kandidaten oder Generator-Funktionen behandelt. Diesem wird die Liste der aktuellen Kandidaten \u00fcbergeben, und er gibt eine neue Liste von Kandidaten zur\u00fcck (eine Liste g\u00fcltiger Pfade zu Sample-Dateien). 1 - Zahlen w\u00e4hlen direkt den Kandidaten aus, dessen Indexposition dieser Zahl entspricht (wenn n\u00f6tig wird wie bei einem Ring von vorne begonnen). Wir k\u00f6nnen z. B. alle Samples in einem Verzeichnis herausfiltern, deren Dateinamen die Zeichenkette \"foo\" enthalten, und davon das erste passende Sample mit halber Geschwindigkeit spielen: sample \"/path/to/samples\", \"foo\", rate: 0.5 Sieh' dir die Hilfe zu sample an, sie enth\u00e4lt viele detaillierte Anwendungsbeispiele. Achte darauf, welche Rolle die Sortierung der Filter spielt. Verb\u00fcnde Abschlie\u00dfend sei gesagt, dass du Listen \u00fcberall verwenden kannst, wo du eine Quelle oder einen Filter einsetzt. Die Liste wird automatisch eingebettet und ihre Inhalte behandelt wie normale Quellen- oder Filterangaben. Daher sind die folgenden Aufrufe von sample alle gleichbedeutend: sample \"/path/to/dir\", \"100\", \"C#\" sample [\"/path/to/dir\", \"100\", \"C#\"] sample \"/path/to/dir\", [\"100\", \"C#\"] sample [\"/path/to/dir\", [\"100\", [\"C#\"]]] Zum Abschluss Das war ein fortgeschrittener Abschnitt f\u00fcr Leute, die machtvollere M\u00f6glichkeiten ben\u00f6tigen, um mit Sample-Paketen zu hantieren und sie zu nutzen. Wenn vieles davon f\u00fcr dich im Moment noch wenig Sinn ergeben hat, keine Sorge. Es ist gut m\u00f6glich, dass du vieles davon jetzt noch nicht brauchst. Dennoch, du wirst merken, wann du es brauchst, und du kannst zur\u00fcckkommen und den Abschnitt noch einmal lesen, wenn du anf\u00e4ngst mit umfangreicheren Sample-Sammlungen zu hantieren. 4 Zuf\u00e4lligkeit Eine tolle M\u00f6glichkeit deine Musik interessant zu gestalten ist die Nutzung von Zufallszahlen. Sonic Pi bietet einige tolle Funktionen, um deiner Musik Zuf\u00e4lligkeiten hinzuzuf\u00fcgen. Aber bevor wir damit anfangen, musst du noch eine schockierende Wahrheit erfahren: In Sonic Pi bedeutet zuf\u00e4llig nicht wirklich zuf\u00e4llig . Was zum Teufel soll das hei\u00dfen? Nun, das werden wir sehen. Wiederholbarkeit Eine wirklich n\u00fctzliche Zufallsfunktion ist rrand . Sie liefert dir einen zuf\u00e4lligen Wert zwischen zwei Zahlen - einem Minimal- und einem Maximalwert - ( rrand ist ein K\u00fcrzel f\u00fcr ranged random , also eine Zufallszahl aus einem bestimmten Zahlenbereich). Versuchen wir mal eine zuf\u00e4llig ausgew\u00e4hlte Note zu spielen: play rrand(50, 95) Oh, es hat eine zuf\u00e4llige Note gespielt. Es hat Note 83.7527 gespielt. Eine nette zuf\u00e4llige Note zwischen 50 und 100. Aber halt, habe ich gerade diese angeblich zuf\u00e4llige Note exakt bestimmt? Da ist doch etwas nicht ganz sauber. Lasse den Programm-Code noch einmal laufen. Wie bitte? Es hat wieder 83.7527 gew\u00e4hlt? Das kann kein Zufall sein! Die Antwort ist, es ist nicht wirklich zuf\u00e4llig, es ist pseudo-zuf\u00e4llig. Sonic Pi liefert dir zufalls\u00e4hnliche Zahlen, die sich wiederholen. Das ist sehr n\u00fctzlich, um sicherzustellen, dass die Musik die du auf deinem Rechner erzeugst, auf jedem anderen Rechner identisch klingt - auch dann, wenn du Zuf\u00e4lligkeiten in deiner Komposition verwendest. Klar, wenn es, in einem bestimmten Musikst\u00fcck, jedes Mal 'zuf\u00e4llig' die 83.7527 w\u00e4hlen w\u00fcrde, dann w\u00e4re das nicht besonders interessant. Aber das tut es auch nicht. Probiere folgendes: loop do play rrand(50, 95) sleep 0.5 end Ja! Jetzt klingt es zuf\u00e4llig. Innerhalb eines gegebenen Programmlaufes liefern weitere Aufrufe von Zufallsfunktionen auch zuf\u00e4llige Werte. Trotzdem wird der n\u00e4chste Programmlauf genau die selbe Abfolge von Zufallswerten liefern und entsprechend auch genau gleich klingen. Es ist als ob Sonic Pi Code immer an denselben Zeitpunkt zur\u00fcckspringt, wenn der Ausf\u00fchren-Schalter geklickt wird. Das ist der Murmeltier-Tag der musikalischen Synthese! Gesiterglocken Ein sch\u00f6nes Beispiel von Zuf\u00e4lligkeit in Aktion ist das Geisterglocken-Beispiel, in dem das :perc_bell -Sample mit einer zuf\u00e4lligen Samplerate und Pausenzeit zwischen den Glockenkl\u00e4ngen abgespielt wird: loop do sample :perc_bell, rate: (rrand 0.125, 1.5) sleep rrand(0.2, 2) end Zuf\u00e4llige Begrenzung Ein anderes unterhaltsames Beispiel f\u00fcr Zuf\u00e4lligkeit ist, einen Synth-Klang zuf\u00e4llig in der Tonh\u00f6he zu begrenzen. Ein toller Synth um das auszuprobieren ist der :tb303 -Emulator: use_synth :tb303 loop do play 50, release: 0.1, cutoff: rrand(60, 120) sleep 0.125 end Zufallsstartpunkte Was, wenn dir eine bestimmte Zufallsabfolge, die Sonic Pi liefert, dir nicht gef\u00e4llt? Nun, mit use_random_seed l\u00e4sst sich sehr gut ein anderer Startpunkt f\u00fcr diese Zufallsabfolge w\u00e4hlen. Der Standard-Startpunkt ist die 0, w\u00e4hle also einen anderen Startpunkt, und du machst eine andere Zufallserfahrung! Sieh dir folgenden Code an: 5.times do play rrand(50, 100) sleep 0.5 end Jedes Mal, wenn du diesen Programm-Code laufen l\u00e4sst, h\u00f6rst du dieselbe Folge von 5 Noten. Um eine andere Folge zu bekommen, setze einen anderen Startpunkt: use_random_seed 40 5.times do play rrand(50, 100) sleep 0.5 end Nun produziert Sonic Pi eine andere Folge aus 5 T\u00f6nen. Indem du den Startpunkt \u00e4nderst und dir die Ergebnisse anh\u00f6rst, kannst du eine Folge finden, die dir gef\u00e4llt - und wenn du den Code an andere weitergibst, werden sie genau das h\u00f6ren, was auch du geh\u00f6rt hast. Schauen wir uns noch einige andere n\u00fctzliche Zufallsfunktionen an. Ausw\u00e4hlen Eine Sache, die sehr h\u00e4ufig gemacht wird, ist aus einer Liste bekannter Elemente eines zuf\u00e4llig auszuw\u00e4hlen. Zum Beispiel m\u00f6chte ich vielleicht einen Ton aus der folgenden Liste spielen: 60, 65 oder 72. Das kann ich mit choose erreichen, das mich ein Element aus einer Liste w\u00e4hlen l\u00e4sst. Zuerst musst ich meine Zahlen in eine Liste packen, indem ich sie, durch Kommas getrennt, in eckige Klammern setze. Danach muss ich sie einfach nur an choose \u00fcbergeben: choose([60, 65, 72]) H\u00f6ren wir uns das mal an: loop do play choose([60, 65, 72]) sleep 1 end rrand Wir haben rrand schon kennengelernt, aber sehen wir uns das noch einmal genauer an. Es liefert eine zuf\u00e4llige Zahl zwischen zwei Werten - ausschlie\u00dflich dieser Werte selbst. Das bedeutet, dass weder der minimale noch der maximale Wert jemals ausgegeben werden, immer nur was zwischen den beiden liegt. Diese Zahl wird immer eine Gleitkommazahl (floating point number) sein - also keine ganze Zahl, sondern eine Bruchzahl (Erinnere dich: Computer verwenden f\u00fcr Rechenoperationen stets die englische Schreibweise - daher Punkt, nicht Komma!). Hier Beispiele f\u00fcr Gleitkommazahlen beim Aufruf von rrand(20, 110) : 87.5054931640625 86.05255126953125 61.77825927734375 rrand_i Gelegentlich wirst du jedoch eine ganze Zahl wollen, keine Gleitkommazahl. Hier kommt rrand_i ( i f\u00fcr englisch integer, ganze Zahl) zur Hilfe. Es funktioniert \u00e4hnlich wie rrand , kann jedoch auch den minimalen oder maximalen Wert als m\u00f6gliche Zufallszahl liefern. (was bedeutet, dass es einschlie\u00dflich der begrenzenden Werte funktioniert und nicht ausschlie\u00dflich). Beispiele w\u00e4ren die Werte, die von rand_i(20,110) ausgeben werden: 88 86 62 rand Dies wird eine zuf\u00e4llige Gleitkommazahl zwischen 0 (inklusiv) und einem von dir spezifizierten Maximalwert (exklusiv) zur\u00fcckgeben. Standardm\u00e4\u00dfig wird ein Wert zwischen 0 und 1 ausgegeben. Daher ist es n\u00fctzlich f\u00fcr eine Auswahl zuf\u00e4lliger Werte f\u00fcr amp: : loop do play 60, amp: rand sleep 0.25 end rand_i \u00c4hnlich wie im Verh\u00e4ltnis von rrand_i zu rrand , wird rand_i eine zuf\u00e4llige ganze Zahl zwischen 0 und dem angegebenen Maximalwert zur\u00fcckgeben. dice Manchmal wirst du so tun wollen, als w\u00fcrdest du w\u00fcrfeln (dice) - dies ist ein Sonderfall von rrand_i , bei dem der kleinste Wert immer die 1 ist. Ein Aufruf von dice verlangt von dir die Anzahl von Seiten zu bestimmen, die der W\u00fcrfel haben soll. Ein normaler W\u00fcrfel hat 6 Seiten, dice(6) wird dem entsprechend einen der Werte 1, 2, 3, 4, 5 oder 6 zur\u00fcckgeben. Wie auch immer, in einem Rollenspiel w\u00fcrdest auch Nutzen in einem 4-seitigen W\u00fcrfel sehen, oder einem 12-seitigen, oder einem 20-seitigen, vielleicht sogar in einem 120-seitigem! one_in Schlie\u00dflich k\u00f6nnte es noch so sein, dass du so tun willst, als ob du beim W\u00fcrfeln mit einem Standardw\u00fcrfel eine 6 hast - also den h\u00f6chsten Wert. one_in gibt daf\u00fcr mit einer Wahrscheinlichkeit von 1 im Verh\u00e4ltnis zur Anzahl W\u00fcrfelseiten den Wert wahr (true) zur\u00fcck. Daher wird one_in(6) mit einer Wahrscheinlichkeit von 1 zu 6 wahr, ansonsten falsch (false). Wahr- und Falsch-Werte sind sehr n\u00fctzlich bei if -Anweisungen, welche wir in einem sp\u00e4teren Abschnitt dieses Tutorials behandeln werden. Jetzt los, bringe deinen Code mit ein wenig Zuf\u00e4lligkeit durcheinander! 5 Programmstrukturen Jetzt, da du die Grundlagen f\u00fcr die Erzeugung von Kl\u00e4ngen mit play und sample und die Erzeugung von Melodien und Rhythmen durch den Einsatz von sleep zwischen den Kl\u00e4ngen gelernt hast, fragst du dich vielleicht, was dir die Welt des Codes dar\u00fcber hinaus zu bieten hat... Nun, ich denke, da kommen noch einige aufregende Sachen auf dich zu! Es ist n\u00e4mlich so, dass grundlegende Programmstrukturen wie Schleifen (loops), Bedingungen (conditionals), Funktionen (functions) und Str\u00e4nge (threads) unglaublich machtvolle Werkzeuge sind, um deine musikalischen Ideen auszudr\u00fccken. Sehen wir uns die Grundlagen eingehender an... 5.1 Bl\u00f6cke Eine Struktur, der du in Sonic Pi h\u00e4ufig begegnen wirst, ist der Block. Bl\u00f6cke erlauben uns, mit gr\u00f6\u00dferen Abschnitten von Programm-Code n\u00fctzliche Dinge zu tun. Z. B. konnten wir bisher mit Synth- und Sample-Parametern etwas ver\u00e4ndern, das in einer einzelnen Zeile des Codes geschah. Manchmal aber m\u00f6chten wir etwas Sinnvolles mit einer ganzen Abfolge von Code-Zeilen anstellen. Zum Beispiel m\u00f6chten wir diese in einer Schleife ablaufen lassen, Hall hinzuf\u00fcgen, sie nur 1 von 5 Malen ablaufen lassen etc. Sieh dir folgenden Code an: play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 Um etwas auf einen mehrzeiligen Code-Abschnitt anzuwenden, m\u00fcssen wir Sonic Pi sagen, wo der Code-Block anf\u00e4ngt , und wo er aufh\u00f6rt . Wir verwenden do f\u00fcr den Anfang und end f\u00fcr das Ende. So zum Beispiel: do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end Das ist aber noch nicht vollst\u00e4ndig und wird nicht funktionieren (versuche es, und du wirst eine Fehlermeldung erhalten), weil wir Sonic Pi noch nicht gesagt haben, was wir mit diesem do/end-Block anstellen wollen. Wir teilen es Sonic Pi mit, indem wir noch einen speziellen Ausdruck vor das do setzen. Wir werden sp\u00e4ter in diesem Tutorial noch eine Reihe solcher Ausdr\u00fccke kennenlernen. F\u00fcr den Moment ist wichtig zu wissen, dass, wenn du deinen Code zwischen do und end zusammenfasst, dies Sonic Pi sagt, dass du mit diesem Codeabschnitt etwas Bestimmtes machen willst. 5.2 Wiederholung und Schleifen Bislang haben wir viel Zeit damit verbracht, uns die unterschiedliche Kl\u00e4nge anzusehen, die du mit play - und sample -Bl\u00f6cken erzeugen kannst. Wir haben auch gelernt, wie wir das Triggern dieser Kl\u00e4nge mit sleep steuern k\u00f6nnen. Du hast ja wahrscheinlich herausgefunden, dass du mit diesen Grundbausteinen schon viel Spa\u00df haben kannst. Eine ganz neue Dimension er\u00f6ffnet sich jedoch, wenn du anf\u00e4ngst die Macht des Programm-Codes zu nutzen, um deine Musiken und Kompositionen zu strukturieren. In den n\u00e4chsten Abschnitten sehen wir uns einige wirkungsvolle neue Werkzeuge daf\u00fcr an. Als erstes kommen Iterationen (wiederholte Abl\u00e4ufe) und Schleifen (Loops) dran. Wiederholung M\u00f6chtest du Code, den du geschrieben hast, einige Male wiederholen? Vielleicht hast du z. B. so etwas: play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 Was, wenn du das drei Male wiederholen wolltest? Nun, wir k\u00f6nnten etwas ganz Einfaches tun, es kopieren und dreimal hintereinander einf\u00fcgen: play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 Nun, das ist eine Menge Code! Was w\u00e4re, wenn du das Sample in :elec_plip \u00e4ndern wolltest? Du m\u00fcsstest alle Stellen mit :elec_blub finden und sie \u00e4ndern. Und dar\u00fcber hinaus: Was, wenn du den urspr\u00fcnglichen Code-Block 50 oder 1000 Mal wiederholen wolltest? Das w\u00e4re wirklich eine Menge Code, und eine Menge Zeilen, die du bearbeiten m\u00fcsstest, wenn du etwas \u00e4ndern wolltest. Iteration Tats\u00e4chlich, Programm-Code wiederholt ablaufen zu lassen sollte so einfach sein wie zu sagen, mache das drei Mal . Nun, so ist es auch in etwa. Erinnere dich an unseren Freund, den Code-Block? Wir k\u00f6nnen damit den Anfang und das Ende des Codes markieren, den wir drei Mal wiederholen wollen. Daf\u00fcr benutzen wir den speziellen Ausdruck 3.times . Anstelle von mache das drei Mal schreiben wir 3.times do - das ist nicht besonders schwer. Denke daran an das Ende des Codes, den du wiederholen m\u00f6chtest, end zu schreiben: 3.times do play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 end Na, ist das nicht viel eleganter als zu kopieren und einzuf\u00fcgen? Wir k\u00f6nnen dies verwenden um viele sch\u00f6ne sich wiederholende Strukturen zu erzeugen: 4.times do play 50 sleep 0.5 end 8.times do play 55, release: 0.2 sleep 0.25 end 4.times do play 50 sleep 0.5 end Iterationen verschachteln Wir k\u00f6nnen Iterationen in anderen Iterationen verpacken, um interessante Muster zu erzeugen. Zum Beispiel: 4.times do sample :drum_heavy_kick 2.times do sample :elec_blip2, rate: 2 sleep 0.25 end sample :elec_snare 4.times do sample :drum_tom_mid_soft sleep 0.125 end end Schleifen abspielen Wenn du etwas sehr oft wiederholen m\u00f6chtest, k\u00f6nnte es sein, dass du mit sehr hohen Zahlen arbeiten musst, wie zum Beispiel 1000.times do . In einem solchen Fall ergibt es m\u00f6glicherweise mehr Sinn Sonic Pi zu bitten, den Code endlos zu wiederholen (zumindest, bis du auf die Stopp-Schaltfl\u00e4che klickst!). Lass uns den Amen-Break unendlich oft wiederholen: loop do sample :loop_amen sleep sample_duration :loop_amen end Eine wichtige Sache bei Schleifen (Loops) ist, dass es sich mit ihnen f\u00fcr den Code wie mit schwarzen L\u00f6chern verh\u00e4lt. Wenn der Code einmal in einer Schleife abl\u00e4uft, kann er diese nicht verlassen, bis du auf Stopp klickst - ansonsten wird er f\u00fcr immer in dieser Schleife weiterlaufen. Das bedeutet, wenn hinter deiner Schleife noch weiterer Code steht, wirst du diesen nie h\u00f6ren. Zum Beispiel wird das Becken hinter dieser Schleife niemals spielen: loop do play 50 sleep 1 end sample :drum_cymbal_open Jetzt fang an und strukturiere deinen Code mit Iterationen und Schleifen! 5.3 Bedingungen Was du dir wahrscheinlich w\u00fcnschen wirst, ist nicht einfach nur eine zuf\u00e4llige Note zu spielen (siehe auch den letzten Abschnitt \u00fcber Zuf\u00e4lligkeit), sondern auch eine zuf\u00e4llige Entscheidung treffen zu k\u00f6nnen, und je nachdem wie diese ausf\u00e4llt, den einen oder den anderen Code ablaufen zu lassen. Zum Beispiel k\u00f6nnte es sein, dass du einer Zuf\u00e4lligkeit folgend entweder eine Trommel oder ein Becken abspielen m\u00f6chtest. Das k\u00f6nnen wir mit einem if -Ausdruck erreichen. Eine M\u00fcnze werfen Werfen wir also ein M\u00fcnze: Bei Kopf, spiele eine Trommel, bei Zahl, ein Becken. Das ist leicht. Wir k\u00f6nnen den M\u00fcnzwurf mit unserer one_in -Funktion nachbilden (eingef\u00fchrt im Kapitel \u00fcber Zuf\u00e4lligkeit), indem wir eine Wahrscheinlichkeit von 1 aus 2 angeben: one_in(2) . Das Ergebnis dieser Berechnung k\u00f6nnen wir nutzen, um zwischen zwei Code-Abschnitten auszuw\u00e4hlen, entweder den Code, um die Trommel zu spielen oder den Code, um das Becken zu spielen: loop do if one_in(2) sample :drum_heavy_kick else sample :drum_cymbal_closed end sleep 0.5 end Merke dir, dass if -Anweisungen drei Teile haben: Die Frage, die gestellt wird Die Auswahl von Programm-Code, der laufen soll (wenn die Antwort auf die Frage ein Ja ist) Die zweite Auswahl von Programm-Code, der laufen soll (wenn die Antwort auf die Frage ein Nein ist) In Programmiersprachen steht typischerweise f\u00fcr das Ja der Ausdruck true und f\u00fcr das Nein der Ausdruck false . Also m\u00fcssen wir eine Frage finden, auf die wir eine Antwort erhalten, die entweder true (wahr) oder false (falsch) ist. Das ist genau das, was one_in tut. Beachte, wie hier die erste Wahl zwischen dem if und dem else und die zweite Wahl zwischen dem else und dem end eingeschlossen wird. So wie bei den do/end-Bl\u00f6cken kannst du beliebig viele Codezeilen an beiden Stellen einf\u00fcgen. Zum Beispiel: loop do if one_in(2) sample :drum_heavy_kick sleep 0.5 else sample :drum_cymbal_closed sleep 0.25 end end Dieses Mal lassen wir den Code unterschiedlich lange schlafen, je nachdem welche Auswahl getroffen wird. Einfaches if Manchmal m\u00f6chtest du wahlweise nur eine Code-Zeile ausf\u00fchren. Das ist m\u00f6glich, indem du ein if setzt und dahinter die Frage an das Ende, zum Beispiel: use_synth :dsaw loop do play 50, amp: 0.3, release: 2 play 53, amp: 0.3, release: 2 if one_in(2) play 57, amp: 0.3, release: 2 if one_in(3) play 60, amp: 0.3, release: 2 if one_in(4) sleep 1.5 end Dieses Beispiel spielt Akkorde, bestehend aus verschiedenen Noten, wobei die Chance gespielt zu werden f\u00fcr die einzelnen Noten jeweils eine andere Wahrscheinlichkeit hat. 5.4 Threads Nun hast du also eine Killer-Basslinie und einen krassen Beat gebaut. Wie kannst du beide zur selben Zeit spielen lassen? Eine M\u00f6glichkeit ist, beide Sounds per Hand miteinander zu verweben - spiele erst den Bass ein bisschen, dann das Schlagzeug, dann den Bass etwas mehr... Beides zeitlich aufeinander abzustimmen wird jedoch gedanklich bald immer schwieriger, vor allem, wenn noch mehr Kl\u00e4nge dazukommen sollen. Was, wenn Sonic Pi Kl\u00e4nge automatisch f\u00fcr dich miteinander verweben k\u00f6nnte? Nun, das kann es, und zwar erreichst du das mit einem besonderen Ding, welches Thread ( Strang ) genannt wird. Unendliche Schleifen Damit dieses Beispiel nicht zu kompliziert wird, musst du dir einfach vorstellen, dass dies deine Killer-Basslinie und dein krasser Beat sind: loop do sample :drum_heavy_kick sleep 1 end loop do use_synth :fm play 40, release: 0.2 sleep 0.5 end Wir haben das fr\u00fcher schon besprochen, Schleifen sind wie schwarze L\u00f6cher f\u00fcr ein Programm. L\u00e4uft es einmal in die Schleife kommt es da nicht mehr raus, bis du auf Stopp klickst. Wie also k\u00f6nnen wir beide Schleifen zur selben Zeit abspielen? Wir m\u00fcssen Sonic Pi sagen, dass wir einen bestimmten Abschnitt gleichzeitig mit dem Rest des Codes starten m\u00f6chten. Hierbei helfen uns Reihenfolgen (threads). Threads als Rettung in_thread do loop do sample :drum_heavy_kick sleep 1 end end loop do use_synth :fm play 40, release: 0.2 sleep 0.5 end Indem wir die erste Schleife in einen in_thread -do/end-Block hinein packen, sagen wir Sonic Pi, es soll den Inhalt dieses do/end-Blocks genau zur selben Zeit wie n\u00e4chste Anweisung nach dem do/end-Block ausf\u00fchren (und das ist in diesem Fall die zweite Schleife). Probiere es aus, und du wirst den Beat und die Basslinie miteinander verwoben h\u00f6ren! Mal angenommen, wir wollten dar\u00fcber noch einen Synth hinzuf\u00fcgen. Ungef\u00e4hr so: in_thread do loop do sample :drum_heavy_kick sleep 1 end end loop do use_synth :fm play 40, release: 0.2 sleep 0.5 end loop do use_synth :zawa play 52, release: 2.5, phase: 2, amp: 0.5 sleep 2 end Jetzt haben wir das gleiche Problem wie vorhin. Die erste Schleife wird durch das in_thread zur selben Zeit wie die zweite gespielt. Aber die dritte Schleife wird nie erreicht . Also brauchen wir einen weiteren Thread: in_thread do loop do sample :drum_heavy_kick sleep 1 end end in_thread do loop do use_synth :fm play 40, release: 0.2 sleep 0.5 end end loop do use_synth :zawa play 52, release: 2.5, phase: 2, amp: 0.5 sleep 2 end Ausf\u00fchren als Thread Was dich vielleicht erstaunt: Wenn du auf Ausf\u00fchren klickst, erzeugst du eigentlich einen neuen Thread, innerhalb dessen der Programm-Code abl\u00e4uft. Deshalb entstehen immer neue Klangschichten, wenn du wiederholt auf Ausf\u00fchren klickst. Weil diese Abl\u00e4ufe jeweils f\u00fcr sich Threads sind, werden sie automatisch die Kl\u00e4nge f\u00fcr dich miteinander verweben. Bereich W\u00e4hrend du Sonic Pi besser zu meistern lernst, wirst du auch herausfinden, dass Threads die wichtigsten Bausteine f\u00fcr deine Musik sind. Eine der wichtigen Aufgaben die sie ausf\u00fchren, ist die aktuellen Einstellungen , die f\u00fcr einen Thread gelten, von anderen Threads zu isolieren. Was genau bedeutet das? Nun, wenn du etwa einen Synth mit use_synth durch einen anderen ersetzt, dann ver\u00e4nderst du den Synth lediglich f\u00fcr den aktuellen Thread - bei keinem anderen der laufenden Threads wird der Synth ersetzt. Sehen wir uns das mal in Aktion an: play 50 sleep 1 in_thread do use_synth :tb303 play 50 end sleep 1 play 50 Bemerke, wie sich der mittlere Klang von den anderen beiden unterschieden hat? Die use_synth -Anweisung hat sich nur auf den Thread ausgewirkt, in dem sie auch stand, aber nicht auf den \u00e4u\u00dferen ausf\u00fchrenden Thread. Vererbung Wenn du einen neuen Thread mit in_thread erzeugst, wird der neue Thread alle Einstellungen automatisch vom vorherigen Thread erben. Sehen wir uns das an: use_synth :tb303 play 50 sleep 1 in_thread do play 55 end Achte darauf, dass der zweite Ton mit dem :tb303 -Synth gespielt wird, obwohl er in einem anderen Thread l\u00e4uft? Jede der Einstellungen, vorgenommen mit den unterschiedlichen use_* -Ausdr\u00fccken, wird sich genauso verhalten. Wenn neue Threads erzeugt werden, erben sie alle Einstellungen von ihren Eltern. Aber \u00c4nderungen der Einstellungen innerhalb dieser neuen Threads haben umgekehrt keinen Einfluss auf die Eltern. Threads benennen Und schlie\u00dflich k\u00f6nnen wir unseren Threads auch Namen geben: in_thread(name: :bass) do loop do use_synth :prophet play chord(:e2, :m7).choose, release: 0.6 sleep 0.5 end end in_thread(name: :drums) do loop do sample :elec_snare sleep 1 end end Achte auf das Protokoll-Fenster, wenn du diesen Code laufen l\u00e4sst. Siehst du, wie das Protokoll mit den Nachrichten auch die Namen der Threads ausgibt? [Run 36, Time 4.0, Thread :bass] |- synth :prophet, {release: 0.6, note: 47} Nur ein Thread pro Name erlaubt Eine letzte Anmerkung zu Threads mit Namen: Es kann nur ein Thread gleichen Namens zur selben Zeit laufen. Probieren wir das aus. Sieh dir folgenden Code an: in_thread do loop do sample :loop_amen sleep sample_duration :loop_amen end end Kopiere das einmal in einen Puffer und klicke auf Ausf\u00fchren . Klicke noch ein paar mal darauf. H\u00f6r dir diese Kakophonie mehrerer Amen-Breaks an, die rhythmisch nicht unbedingt passend zueinander ablaufen. Ok, du kannst jetzt Stopp klicken. Dieses Verhalten haben wir bereits \u00f6fter gesehen - wenn du die Ausf\u00fchren -Schaltfl\u00e4che klickst, legen sich Kl\u00e4nge \u00fcber alle bereits laufenden Kl\u00e4nge. Wenn du eine Schleife hast und dreimal auf Ausf\u00fchren klickst, bekommst du drei Ebenen mit Schleifen, die gleichzeitig spielen. Bei benannten Threads jedoch ist das anders: in_thread(name: :amen) do loop do sample :loop_amen sleep sample_duration :loop_amen end end Versuche bei diesem Code den Ausf\u00fchren -Schalter mehrmals zu klicken. Du wirst immer nur eine Amen-Break-Schleife h\u00f6ren. Das kannst Du auch im Protokoll sehen: ==> Skipping thread creation: thread with name :amen already exists. Sonic Pi teilt dir mit, dass ein Thread mit dem Namen :amen bereits l\u00e4uft und es deshalb keinen weiteren erzeugt. Vielleicht erscheint dir dieses Verhalten im Moment noch nicht n\u00fctzlich - aber es wird sehr n\u00fctzlich sein, wenn wir ins Live-Coding einsteigen ... 5.5 Funktionen Wenn du einmal damit angefangen hast gr\u00f6\u00dfere Mengen Programm-Code zu schreiben, dann wirst du nach Wegen suchen, wie du die Dinge organisieren und strukturieren kannst, um sie sauberer und verst\u00e4ndlicher zu machen. Funktionen sind ein sehr wirkungsvoller Weg das zu tun. Sie geben uns die M\u00f6glichkeit, einem Haufen Programm-Code einen Namen zu geben. Sehen wir uns das an. Funktionen definieren define :foo do play 50 sleep 1 play 55 sleep 2 end Hier haben wir eine neue Funktion mit dem Namen foo definiert. Wir machen das mit unserem alten Freund, dem do/end-Block und dem Zauberwort define , gefolgt von dem Namen, den wir unserer Funktion geben m\u00f6chten. Wir m\u00fcssen die Funktion nicht unbedingt foo nennen, wir k\u00f6nnen sie auch irgendwie anders nennen; zum Beispiel bar , baz oder idealerweise einen f\u00fcr dich bedeutsamen Namen wie haupt_sektion oder hintergrund_akkorde . Denke daran, bei der Definition einer Funktion ihrem Namen einen Doppelpunkt : voranzustellen. Funktionen aufrufen Wenn wir unsere Funktion definiert haben, k\u00f6nnen wir sie \u00fcber die Eingabe ihres Namens aufrufen: define :foo do play 50 sleep 1 play 55 sleep 0.5 end foo sleep 1 2.times do foo end Wir k\u00f6nnen foo sogar in Blocks mit Iterationen verwenden - oder \u00fcberall da, wo wir sonst auch play oder sample schreiben w\u00fcrden. Das gibt uns eine sehr weit gehende M\u00f6glichkeit uns auszudr\u00fccken, und k\u00f6nnen sinnvolle Worte einsetzen, um sie in unseren Kompositionen zu verwenden. Funktionen bleiben in Erinnerung Wenn du bisher auf Ausf\u00fchren geklickt hast, ist Sonic Pi jedes Mal aufs Neue ohne irgendwelche Vorgaben gestartet. Es ber\u00fccksichtigt dabei nichts, au\u00dfer dem, was im jeweiligen Puffer steht. Du kannst dich nicht auf irgendwelchen Programm-Code beziehen, der in einem anderen Puffer oder in einem anderen Thread steht. Funktionen \u00e4ndern das jedoch. Wenn du eine Funktion definierst, dann erinnert sich Sonic Pi daran. Probieren wir das aus. L\u00f6sche den gesamten Code in deinem Puffer und ersetze ihn durch: foo Klicke auf Ausf\u00fchren - und h\u00f6re deine Funktion spielen. Wo wurde dieser Code gespeichert? Woher wusste Sonic Pi, was es zu spielen hat? Sonic Pi hat sich deine Funktion einfach gemerkt - sogar, nachdem du den Programm-Code aus dem Puffer gel\u00f6scht hast, wusste Sonic Pi noch, was du geschrieben hattest. Dies funktioniert nur mit Funktionen, die du mit define (und defonce ) erzeugt hast. Funktionen parametrisieren Es wird dich vielleicht interessieren, dass so wie du rrand einen Minimal- und Maximalwert \u00fcbergeben kannst, du auch deinen Funktionen beibringen kannst Argumente zu akzeptieren. Sehen wir uns das an: define :my_player do |n| play n end my_player 80 sleep 0.5 my_player 90 Das ist nicht besonders aufregend, zeigt aber, worum es hier geht. Wir haben unsere eigene Version von play mit dem Namen my_player erschaffen. Diese ist parametrisiert - sie akzeptiert also Argumente. Die Parameter m\u00fcssen hinter dem do des define -do/end-Blocks stehen, umgeben von senkrechten Strichen (pipes) | und durch Kommas , getrennt. Du kannst beliebige W\u00f6rter als Parameternamen verwenden. Die Magie passiert innerhalb des define -do/end-Blocks. Du kannst die Parameternamen so benutzen, als w\u00e4ren sie wirkliche Werte. In diesem Beispiel spiele ich den Ton n . Du kannst die Parameter als eine Art Versprechen ansehen, dass wenn der Programm-Code l\u00e4uft, sie durch wirkliche Werte ersetzt werden. Du machst das, indem du der Funktion beim Aufruf einen Parameter mitgibst. Ich tue das hier mit my_player 80 , um die Note 80 zu spielen. Innerhalb der Funktionsdefinition wird n nun durch 80 ersetzt, sodass play n sich in play 80 verwandelt. Wenn ich die Funktion erneut mit my_player 90 aufrufe, wird n durch 90 ersetzt, sodass sich jetzt play n in play 90 verwandelt. Sehen wir uns ein interessanteres Beispiel an: define :chord_player do |root, repeats| repeats.times do play chord(root, :minor), release: 0.3 sleep 0.5 end end chord_player :e3, 2 sleep 0.5 chord_player :a3, 3 chord_player :g3, 4 sleep 0.5 chord_player :e3, 3 Hier habe ich repeats so benutzt, als ob es eine Zahl in der Zeile repeats.times do w\u00e4re. Zus\u00e4tzlich habe ich roots so verwendet, als ob es ein Notenname in meinem Aufruf von play w\u00e4re. Sieh dir an, wie wir hier etwas sehr Ausdrucksstarkes und leicht zu Lesendes schreiben konnten, indem wir vieles von unserer Programmlogik in Funktionen verschieben! 5.6 Variablen Beim Programmieren ist es sehr n\u00fctzlich, Namen f\u00fcr Dinge zu vergeben. Sonic Pi vereinfacht dies sehr: Du schreibst den Namen, den du verwenden m\u00f6chtest, dann ein Gleichheitszeichen ( = ) und dann das Ding, welches du dir merken m\u00f6chtest: sample_name = :loop_amen Hier haben wir uns das Symbol :loop_amen mit der Variablen sample_name gemerkt . Wir k\u00f6nnen nun sample_name \u00fcberall da verwenden, wo wir auch loop_amen verwenden w\u00fcrden. Zum Beispiel: sample_name = :loop_amen sample sample_name Es gibt drei wesentliche Gr\u00fcnde Variablen in Sonic Pi zu nutzen: Bedeutung vermitteln, Wiederholung steuern und Ergebnisse erfassen und speichern. Bedeutung vermitteln Wenn du Programm-Code schreibst, ist es leicht zu denken, dass du dem nur Computer sagst, wie er etwas tun soll - solange der Computer das versteht, ist das in Ordnung. Vergiss aber nicht, dass nicht nur der Computer deinen Code lesen wird. Andere Leute k\u00f6nnten den Code auch lesen und versuchen zu verstehen, was da vor sich geht. Es ist m\u00f6glich, dass du den Code sp\u00e4ter auch selbst noch einmal lesen wirst und verstehen willst, was er bedeutet. Obwohl dir jetzt alles noch ganz offensichtlich erscheint - wahrscheinlich ist es f\u00fcr andere nicht ganz so offensichtlich und vielleicht auch nicht f\u00fcr dich in der Zukunft! Ein Weg um andere darin zu unterst\u00fctzen deinen Programm-Code zu verstehen, ist das Schreiben von Kommentaren (wie wir im vorherigen Abschnitt gesehen haben). Ein andererr besteht darin sinnvolle Namen f\u00fcr deine Variablen verwenden. Sie dir diesen Code an: sleep 1.7533 Warum steht hier die Zahl 1.7533 ? Woher kommt diese Zahl? Was bedeutet sie? Sieh dir zum Vergleich diesen Code an: loop_amen_duration = 1.7533 sleep loop_amen_duration Nun, es ist viel klarer, was 1.7533 bedeutet: Es ist die Dauer des Samples :loop_amen ! Nat\u00fcrlich k\u00f6nntest du jetzt sagen, warum nicht einfach schreiben: sleep sample_duration(:loop_amen) Was nat\u00fcrlich auch ein sehr guter Weg ist, die Absicht hinter dem Code mitzuteilen. Wiederholungen steuern Oft wirst du in deinem Programm-Code Wiederholungen begegnen, und wenn du eine Sache \u00e4ndern willst, musst du das an vielen Stellen tun. Schau dir diesen Code an: sample :loop_amen sleep sample_duration(:loop_amen) sample :loop_amen, rate: 0.5 sleep sample_duration(:loop_amen, rate: 0.5) sample :loop_amen sleep sample_duration(:loop_amen) Wir machen hier eine ganze Menge mit dem :loop_amen ! Was w\u00e4re, wenn wir es mit einem anderen Loop-Sample h\u00f6ren wollten, wie zum Beispiel :loop_garzul ? Wir m\u00fcssten alle :loop_amen suchen und mit :loop_garzul ersetzen. Das mag in Ordnung sein, wenn du viel Zeit hast - aber was, wenn du gerade auf der B\u00fchne stehst und performst? Manchmal hast du nicht den Luxus der Zeit - vor allem dann nicht, wenn du willst, dass die Leute weiter tanzen. Was w\u00e4re, wenn du den Code so geschrieben h\u00e4ttest: sample_name = :loop_amen sample sample_name sleep sample_duration(sample_name) sample sample_name, rate: 0.5 sleep sample_duration(sample_name, rate: 0.5) sample sample_name sleep sample_duration(sample_name) Das tut genau dasselbe wie der Code weiter oben (probiere es aus). Und es gibt uns auch die M\u00f6glichkeit, dass wir nur eine Zeile von sample_name = :loop_amen in sample_name = :loop_garzul \u00e4ndern - und damit zugleich an vielen anderen Stellen durch die Magie der Variablen. Ergebnisse speichern Schlie\u00dflich, eine gute Motivation Variablen zu verwenden ist die Ergebnisse von etwas festzuhalten. Z. B. m\u00f6chtest du vielleicht irgendetwas mit der Dauer eines Samples anstellen: sd = sample_duration(:loop_amen) Wir k\u00f6nnen nun sd \u00fcberall dort einsetzen, wo wir die L\u00e4nge von :loop_amen brauchen. Vielleicht noch wichtiger, erlaubt uns eine Variable das Ergebnis eines Aufrufs von play oder sample zu speichern: s = play 50, release: 8 Jetzt haben wir s als Variable festgehalten und gespeichert, das erlaubt es uns einen Synth zu steuern, w\u00e4hrend er l\u00e4uft: s = play 50, release: 8 sleep 2 control s, note: 62 Wir werden uns die Steuerung von Synths in einem sp\u00e4teren Abschnitt noch detaillierter ansehen. Warnung: Variablen und Threads W\u00e4hrend Variablen sehr gut dazu geeignet sind, Dingen Namen zu geben oder ein Ergebnis festzuhalten, ist es wichtig zu wissen, dass sie typischerweise nur im lokalen Kontext eines Threads verwendet werden sollten. Zum Beispiel, tu das hier nicht : a = (ring 6, 5, 4, 3, 2, 1) live_loop :sorted do a = a.sort sleep 0.5 puts \"sorted: \", a end live_loop :shuffled do a = a.shuffle sleep 0.5 end In dem Beispiel oben weisen wir einen Ring aus Zahlen einer Variablen a zu und verwenden sie dann in zwei separaten live_loop . Innerhalb der ersten Schleife sortieren wir alle 0.5 Sekunden den Ring (zu (ring 1, 2, 3, 4, 5, 6) ) und geben dies im Protokoll aus. Wenn du nun den Code ausf\u00fchrst, wirst du bemerken, dass die ausgegebene Liste nicht immer sortiert ist! . Das k\u00f6nnte dich \u00fcberraschen - insbesondere, da manchmal die Liste sortiert ist und manchmal nicht. Dies wird als nicht-vorhersagbares Verhalten bezeichnet, und ist das Ergebnis eines eher \u00fcblen Problems, 'Race-Condition' genannt. Das Problem resultiert aus der Tatsache, dass die zweite Schleife ebenfalls die Liste ver\u00e4ndert (in diesem Fall wird sie gemischt) und zum Zeitpunkt der Ausgabe die Liste manchmal sortiert und manchmal gemischt ist. Beide Schleifen befinden sich im Wettlauf miteinander die selbe Variable zu ver\u00e4ndern, und es gewinnt manchmal die eine und manchmal die andere. Hierzu gibt es zwei L\u00f6sungen: Zun\u00e4chst, verwende nie die gleiche Variable in mehreren Live-Loops oder Threads . Beispielsweise gibt der folgende Code die Liste immer richtig sortiert aus, da jeder Live-Loop eine eigene Variable verwendet: live_loop :shuffled do a = (ring 6, 5, 4, 3, 2, 1) a = a.shuffle sleep 0.5 end live_loop :sorted do a = (ring 6, 5, 4, 3, 2, 1) a = a.sort sleep 0.5 puts \"sorted: \", a end Allerdings wollen wir manchmal auch Werte zwischen verschiedene Threads teilen, zum Beispiel die aktuelle Tonart, BPM , den aktuellen Synth etc. In diesen F\u00e4llen ist die beste L\u00f6sung Sonic Pi spezielles Thread-Safe-State-System mit Hilfe der Funktionen get und set zu verwenden. Dies werden wir etwas sp\u00e4ter in Abschnitt 10 behandeln. 5.7 Threads synchronisieren Sobald du ausreichend vertraut damit bist, mit mehreren gleichzeitig ablaufenden Funktionen und Threads live zu programmieren, wirst du bemerken, dass es ziemlich leicht ist in einem einzelnen Thread einen Fehler zu machen, der ihn zum Absturz bringt. Das ist nicht weiter schlimm, da du den Thread ja mit einem Klick auf Ausf\u00fchren einfach neu starten kannst. Wenn du den Thread aber neu startest, dann l\u00e4uft er nicht mehr im Takt mit den anderen Threads. Vererbte Zeit Wie wir bereits vorher gesehen haben, erben neue Threads die mit in_thread erzeugt werden alle ihre Einstellungen von einem Eltern-Thread. Das schlie\u00dft auch die aktuelle Zeit mit ein. Das bedeutet, dass Threads immer miteinander im Takt sind, wenn sie gleichzeitig gestartet werden. Wenn du aber einen Thread f\u00fcr sich alleine startest, spielt dieser in seinem eigenen Takt, der wahrscheinlich nicht mit irgendeinem der anderen gerade laufenden Threads synchron ist. Cue und Sync Sonic Pi bietet mit den Funktionen cue und sync eine L\u00f6sung f\u00fcr dieses Problem. cue erlaubt es uns, mit einem Taktgeber regelm\u00e4\u00dfig Signale an alle anderen Threads zu versenden. Normalerweise zeigen die anderen Threads an solchen Takt-Signalen kein Interesse und ignorieren sie. Mit der sync -Funktion kann du jedoch erreichen, dass ein anderer Thread Interesse zeigt. Wichtig ist dabei sich dar\u00fcber bewusst zu sein, dass sync \u00e4hnlich wie sleep funktioniert, indem es den aktuellen Thread f\u00fcr eine bestimmte Dauer anh\u00e4lt. Allerdings legst du bei sleep fest, wie lange du warten willst, w\u00e4hrend du bei sync nicht wei\u00dft, wie lange gewartet werden wird - da sync auf den n\u00e4chsten cue eines anderen Threads wartet - was eine k\u00fcrzere oder l\u00e4ngere Dauer sein kann. Sehen wir uns das im Detail an: in_thread do loop do cue :tick sleep 1 end end in_thread do loop do sync :tick sample :drum_heavy_kick end end Hier haben wir zwei Threads - einer arbeitet wie ein Metronom, er spielt nichts, aber sendet bei jedem Schlag das Taktgeber-Signal :tick . Der zweite Thread synchronisiert sich mit den tick -Signalen, und wenn er ein Signal erh\u00e4lt, erbt er dadurch den Takt vom cue -Thread und l\u00e4uft weiter. Im Ergebnis h\u00f6ren wir das :drum_heavy_kick -Sample genau dann, wenn der andere Thread das :tick -Signal sendet, auch dann wenn die Ausf\u00fchrung beider Threads gar nicht zur selben Zeit gestartet war: in_thread do loop do cue :tick sleep 1 end end sleep(0.3) in_thread do loop do sync :tick sample :drum_heavy_kick end end Der dreiste Aufruf von sleep w\u00fcrde normalerweise den zweiten Thread gegen\u00fcber dem ersten aus dem Takt bringen. Da wir jedoch cue und sync verwenden, synchronisieren wir beide Threads automatisch und umgehen dabei ungewollte Abweichungen in der Zeit. Cue-Namen Du kannst deine cue -Signale benennen, wie du willst - nicht nur mit :tick . Du musst nur sicherstellen, dass jegliche anderen Threads, die sich mit sync synchronisieren, auch diesen Namen verwenden - ansonsten werden sie endlos warten (oder zumindest so lange bis du auf Stopp klickst). Lass uns mit ein paar Namen f\u00fcr cue spielen: in_thread do loop do cue [:foo, :bar, :baz].choose sleep 0.5 end end in_thread do loop do sync :foo sample :elec_beep end end in_thread do loop do sync :bar sample :elec_flip end end in_thread do loop do sync :baz sample :elec_blup end end Hier haben wir eine taktgebende cue -Schleife, die auf Zufallsbasis einen der drei Taktgeber-Namen :foo , :bar oder :baz aussendet. Wir haben au\u00dferdem drei Schleifen-Threads, die sich unabh\u00e4ngig voneinander, jeder f\u00fcr sich, mit einem der Namen synchronisieren und dann jeweils ein anderes Sample spielen. Im Endeffekt h\u00f6ren wir jeden halben Schlag einen Klang, da jeder der sync -Threads mit dem cue -Thread auf Zufallsbasis synchronisiert ist und entsprechend sein Sample abspielt. Das funktioniert nat\u00fcrlich auch, wenn du die Reihenfolge der Threads umkehrst, da die sync -Threads einfach dasitzen und auf den n\u00e4chsten cue warten. 6 Effekte Einer der lohnendsten und unterhaltsamsten Aspekte von Sonic Pi ist, dass du deinen Kl\u00e4ngen sehr einfach Studio-Effekte hinzuf\u00fcgen kannst. Zum Beispiel m\u00f6chtest du vielleicht Teilen deines St\u00fcckes etwas Hall (Reverb) hinzuf\u00fcgen, oder etwas Echo, oder vielleicht sogar deine Basslinien verzerren (Distortion) oder wabern lassen (Wobble). Sonic Pi bietet einen sehr einfachen aber m\u00e4chtigen Weg Effekte hinzuzuf\u00fcgen. Es erlaubt dir sogar sie miteinander verketten (so dass du einen Klang durch Verzerrung, dann Echo und dann Hall schicken kannst) und auch jeden Effekt einzeln mit Parametern zu steuern (ganz \u00e4hnlich wie Parameter an Synths und Samples \u00fcbergeben werden). Du kannst die Parameter eines Effektes sogar \u00e4ndern, w\u00e4hrend er noch l\u00e4uft. Zum Beispiel k\u00f6nntest du so den Hall auf deiner Basslinie im Verlauf des St\u00fcckes anheben ... Gitarren-Pedale Wenn sich das alles etwas kompliziert anh\u00f6ren sollte, keine Sorge! Wenn du ein wenig damit herumspielst, wird dir das alles ziemlich klar erscheinen. Aber bevor du loslegst: Ein einfacher Vergleich ist der mit Effektpedalen f\u00fcr Gitarren. Es gibt viele Arten solcher Effektpedale. Manche f\u00fcgen Hall hinzu, andere verzerren etc. Eine Gitarristin oder ein Gitarrist w\u00fcrde ihre bzw. seine Gitarre an ein Effektpedal anstecken - z. B. einen Verzerrer - und dann ein weiteres Kabel nehmen und noch ein Hall-Effektpedal verbinden (verketten). Der Ausgang des Hall-Effektpedals kann dann an einen Verst\u00e4rker angesteckt werden: Gitarre -> Verzerrer -> Hall -> Verst\u00e4rker So etwas nennt sich Effektkette. Und das ist genau das, was Sonic Pi unterst\u00fctzt. Zus\u00e4tzlich haben Effektpedale oftmals einige Drehkn\u00f6pfe und Schieberegler, die dir erlauben zu steuern, wieviel Verzerrung, Hall, oder Echo hinzugef\u00fcgt werden sollen. Sonic Pi unterst\u00fctzt auch diese Art der Steuerung. Und abschlie\u00dfend stell dir einmal, wie eine Person Gitarre spielt, w\u00e4hrend eine andere die Effekte steuert, w\u00e4hrend sie spielt. Sonic Pi unterst\u00fctzt das auch - aber anstatt f\u00fcr die Effekt-Steuerung auf eine andere Person angewiesen zu sein, springt hier der Computer ein. Lass uns Effekte ausprobieren! 6.1 Effekte hinzuf\u00fcgen In diesem Abschnitt sehen wir uns zwei Effekte an: Hall und Echo. Wir werden sehen, wie diese Effekte verwendet werden, wie ihre Parameter gesteuert werden, und wie sie verketten werden. Das Effekt-System von Sonic Pi verwendet so genannte Code-Bl\u00f6cke. Falls du Abschnitt 5.1 des Tutorials noch nicht gelesen hast, wirf einen kurzen Blick darauf und komme dann hierher zur\u00fcck. Hall Um den Hall-Effekt zu benutzen schreiben wir with_fx :reverb als speziellen Programm-Code zu unserem Code-Block. Und zwar so: with_fx :reverb do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end F\u00fchre diesen Code-Block aus, und du wirst ihn mit Hall h\u00f6ren. H\u00f6rt sich gut an, nicht wahr! t Mit Hall h\u00f6rt sich alles recht h\u00fcbsch an. Lass uns schauen, was passiert, wenn wir Programm-Code au\u00dferhalb des do/end-Blocks hinzuf\u00fcgen: with_fx :reverb do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end sleep 1 play 55 Beachte wie das letzte play 55 nicht mit Hall abgespielt wird. Der Grund daf\u00fcr ist, dass es sich au\u00dferhalb des do/end-Blocks befindet und deshalb nicht von unserem Hall erfasst wird. Entsprechend werden Kl\u00e4nge, die du vor dem do/end-Block einf\u00fcgst, auch nicht von dem Hall-Effekt erfasst: play 55 sleep 1 with_fx :reverb do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end sleep 1 play 55 Echo Es stehen viele Effekte zur Auswahl. Wie w\u00e4re es mit etwas Echo? with_fx :echo do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end Einer der machtvollen Aspekte von Effekt-Bl\u00f6cken in Sonic PI ist, dass wir ihnen opts \u00fcbergeben k\u00f6nnen, genauso wie wir es schon bei play und sample gesehen haben. Ein spannender Echo-Parameter ist zum Beispiel phase: , der die Dauer des Echos in Beats darstellt. Lass uns das Echo langsamer machen: with_fx :echo, phase: 0.5 do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end Lass uns das Echo auch schneller machen: with_fx :echo, phase: 0.125 do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end Lassen wir nun das Echo langsamer ausschwingen, indem wir den decay: -Wert auf 8 Schl\u00e4ge setzen: with_fx :echo, phase: 0.5, decay: 8 do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end Effekte verschachteln Einer der m\u00e4chtigsten Aspekte von Effekt-Bl\u00f6cken ist, dass du sie verschachteln kannst. Das erlaubt dir Effekte ganz einfach aneinanderzuh\u00e4ngen. Was, zum Beispiel, wenn du einen Code-Block zuerst mit Echo und dann mit Hall versehen willst? Ganz einfach, verschachtele die Code-Bl\u00f6cke ineinander: with_fx :reverb do with_fx :echo, phase: 0.5, decay: 8 do play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 end end Stell dir das was du h\u00f6rst, als etwas vor, das von innen nach au\u00dfen flie\u00dft. Der Klang aus dem gesamten Programm-Code im inneren do/end-Block, wie play 50 , wird zuerst zu dem Echo-Effekt gesendet, und der Echo-Effekt danach zu dem Hall-Effekt. Wir k\u00f6nnen sehr tiefe Verschachtelungen verwenden und verr\u00fcckte Ergebnisse erzielen. Aber sei gewarnt, die Effekte k\u00f6nnen eine Menge Ressourcen verbrauchen, und wenn du sie verschachtelst, l\u00e4sst du effektiv mehrere Effekte gleichzeitig laufen. Sei also sparsam bei deinem Gebrauch von Effekten, besonders auf nicht so kraftvollen Plattformen wie dem Raspberry Pi. Effekte entdecken Sonic Pi bringt eine Vielzahl von Effekten mit, die du verwenden kannst. Um herauszufinden, welche verf\u00fcgbar sind, klicke links unten im Men\u00fc des Hilfe-Fensters auf FX, und du siehst eine Liste der verf\u00fcgbaren Optionen. Hier eine Liste einiger meiner Favoriten: Wobble, Reverb, Echo, Distortion, Slicer Nun werde wild und f\u00fcge \u00fcberall Effekte hinzu - f\u00fcr ein paar tolle neue Kl\u00e4nge! 6.2 Praktische Anwendung von Effekten Auch wenn sie \u00e4u\u00dferlich sehr einfach aussehen, sind Effekte in Sonic Pi doch h\u00f6chst komplexe Gebilde. Ihre anscheinende Einfachheit verleitet Leute oft dazu, zu viele Effekte in ihren St\u00fccken zu verwenden. Das mag Spa\u00df machen, wenn du \u00fcber einen sehr starken Computer verf\u00fcgst. Aber falls du - so wie ich - einen Raspberry Pi zum Jammen benutzt, musst du darauf achten, wieviel Arbeit du der Maschine abverlangst, wenn du sicher gehen willst, dass die Beats weiter im Takt laufen. Sieh dir den folgenden Programm-Code an: loop do with_fx :reverb do play 60, release: 0.1 sleep 0.125 end end In diesem Programm-Code spielen wir die Note 60 mit einer sehr kurzen Release-Zeit und erzeugen somit einen kurze Note. Wir wollen au\u00dferdem einen Hall-Effekt, also haben wir ihn in einen Reverb-Block gepackt. Soweit ist alles gut, abgesehen von ... Lass uns ansehen, was der Code hier macht. Zun\u00e4chst haben wir einen loop -Befehl, was bedeutet, dass alles darin f\u00fcr immer in einer Schleife wiederholt wird. Dann haben wir einen with_fx: -do/end-Block. Das bedeutet, dass wir mit jeder Wiederholung der Schleife einen neuen Hall-Effekt erzeugen. Und das ist so, als ob wir f\u00fcr jedes Mal, wenn wir eine Gitarrenseite spielen, ein zus\u00e4tzliches Hall-Effekt-Pedal an die Effektkette h\u00e4ngen w\u00fcrden. Es ist cool, dass du das machen kannst, aber es ist m\u00f6glicherweise nicht das, was du eigentlich willst. So wird zum Beispiel dieser Programm-Code Schwierigkeiten haben fl\u00fcssig auf einem Raspberry Pi zu laufen. Die gesamte Arbeit den Hall zu erzeugen und dann abzuwarten, bis er gestoppt und entfernt werden muss, wird von with_fx: f\u00fcr dich erledigt - daf\u00fcr werden Prozessor-Ressourcen ben\u00f6tigt, die vielleicht anderweitig wertvoll w\u00e4ren. Wie k\u00f6nnen wir einen Code-Block schreiben, der einem traditionellen Aufbau entspricht, bei dem die Gitarre nur ein Hall-Effekt-Pedal benutzt, durch das der gesamte Klang geschickt wird? Einfach: with_fx :reverb do loop do play 60, release: 0.1 sleep 0.125 end end Wir haben unsere Schleife ins Innere des with_fx: -Blocks gepackt. So erzeugen wir nur noch einen einzelnen Hall-Effekt f\u00fcr alle Noten, die in der Schleife gespielt werden. Dieser Programm-Code ist sehr viel effizienter und w\u00fcrde auch auf einem Raspberry Pi gut funktionieren. Ein Kompromiss ist with_fx: \u00fcber eine Iteration innerhalb einer Schleife zu verwenden: loop do with_fx :reverb do 16.times do play 60, release: 0.1 sleep 0.125 end end end Somit wird die with_fx: -Funktion aus dem Inneren Teil der Schleife geholt, und der Programm-Code erzeugt jetzt nur noch alle 16 Noten einen neuen Hall-Effekt. Dieser Muster taucht so h\u00e4ufig auf, dass with_fx eine Option akzeptiert, die erlaubt genau dies zu tun, ohne den 16.times -Block zu schreiben: loop do with_fx :reverb, reps: 16 do play 60, release: 0.1 sleep 0.125 end end Beide, das reps: 16 - und das 16.times do -Beispiel verhalten sich identisch. reps: 16 wiederholt den Programm-Code im do/end -Block 16 mal, sodass du beide Ausdr\u00fccke austauschbar verwenden und den ausw\u00e4hlen kannst, der sich am besten f\u00fcr dich anf\u00fchlt. Denke daran, es gibt keine Fehler, nur M\u00f6glichkeiten! Wie auch immer, einige dieser Ans\u00e4tze werden sich klanglich unterscheiden und auch unterschiedlich verhalten. Spiel also herum, und verwende den Ansatz, der f\u00fcr dich am besten klingt und zugleich innerhalb der Beschr\u00e4nkungen deiner Plattform funktioniert. 7 Steuerung Bisher haben wir uns angesehen, wie du Synths und Samples starten und ihre Standard-Parameter wie Lautst\u00e4rke, Position im Stereofeld, H\u00fcllkurven und so weiter anpassen kannst. Jeder gespielte Klang ist im Grunde genommen ein eigener Klang mit einer eigenen Liste an Optionen, gesetzt f\u00fcr die Dauer, w\u00e4hrend der er klingt. W\u00e4re es nicht auch cool, wenn du die Parameter eines Klanges ver\u00e4ndern k\u00f6nntest - noch w\u00e4hrend er erklingt - etwa so, wie du an einer Gitarrensaite ziehen w\u00fcrdest, w\u00e4hrend sie noch schwingt? Gl\u00fcck gehabt - dieser Abschnitt wird dir zeigen, wie du genau das tun kannst. 7.1 Steuerung laufender Synths Bisher haben wir uns nur damit befasst neue Kl\u00e4nge und Effekte zu triggern. Mit Sonic Pi kannst du aber laufende Kl\u00e4nge auch steuern und ver\u00e4ndern. Um das zu tun, fassen wir eine Referenz zu einem Synth in einer Variable: s = play 60, release: 5 Jetzt haben wir eine lokal ausgef\u00fchrte Variable s , die einen Synth repr\u00e4sentiert, der die Note 60 spielt. Beachte, dass sie lokal ausgef\u00fchrt wird - das bedeutet, du kannst nicht von andere Ausf\u00fchrungen, wie z. B. Funktionen auf sie zugreifen. Sobald wir s gesetzt haben, k\u00f6nnen wir es mit der control -Funktion steuern: s = play 60, release: 5 sleep 0.5 control s, note: 65 sleep 0.5 control s, note: 67 sleep 3 control s, note: 72 Wichtig zu bemerken ist hier, dass wir nicht 4 verschiedene Synths starten - wir starten nur einen Synth und \u00e4ndern dann seine Tonh\u00f6he dreimal im Nachhinein, w\u00e4hrend er noch spielt. Wir k\u00f6nnen jeden der Standard-Parameter an die control -Funktion \u00fcbergeben, so kannst du Dinge wie amp: , cutoff: oder pan: steuern. Nicht-steuerbare Parameter Manche der Optionen k\u00f6nnen nach dem Start des Synths nicht mehr kontrolliert werden. Das ist der Fall bei allen ADSR-H\u00fcllkurven-Parametern. Welche Opts steuerbar sind, kannst du herausfinden, indem du ihre Dokumentation im Hilfe-Fenster ansiehst. Wenn dort steht Can not be changed once set , dann wei\u00dft du, dass es nicht m\u00f6glich ist diese Option zu steuern, nachdem der Synth gestartet ist. 7.2 Steuerung von Effekten Es ist auch m\u00f6glich Effekte zu steuern, allerdings funktioniert das ein wenig anders: with_fx :reverb do |r| play 50 sleep 0.5 control r, mix: 0.7 play 55 sleep 1 control r, mix: 0.9 sleep 1 play 62 end Anstatt eine Variable zu verwenden, nutzen wir die Parameter zwischen den so genannten Pipes des do/end-Blocks. Innerhalb dieser Pipes | , m\u00fcssen wir einen eindeutigen Namen f\u00fcr unseren laufenden Effekt vergeben, den wir dann innerhalb des do/end-Blocks verwenden. Dieses Verhalten ist das gleiche wie bei parametrisierten Funktionen. Jetzt los - steuere ein paar Synths und Effekte! 7.3 Gleitende Parameter W\u00e4hrend du die Synth- und Effekt-Optionen erforscht hast, ist dir vielleicht aufgefallen, dass einige von ihnen auf _slide enden. Vielleicht hast du sogar ausprobiert sie aufzurufen und keinen Effekt bemerkt. Das liegt daran, dass dies keine normalen Parameter sind, sie sind besondere Opts, die nur dann funktionieren, wenn du Synths steuerst, wie im letzten Abschnitt beschrieben. Schau dir das folgende Beispiel an: s = play 60, release: 5 sleep 0.5 control s, note: 65 sleep 0.5 control s, note: 67 sleep 3 control s, note: 72 Hier kannst du h\u00f6ren, wie sich die Tonh\u00f6he des Synth unmittelbar bei jedem Aufruf von control \u00e4ndert. Vielleicht m\u00f6chtest du aber, dass die Tonh\u00f6he sich gleitend zwischen den Aufrufen ver\u00e4ndert. Wenn wir die Opt note: verwenden, m\u00fcssen wir, um gleitende \u00dcberg\u00e4nge zu erhalten, den note_slide: -Parameter des Synth setzen: s = play 60, release: 5, note_slide: 1 sleep 0.5 control s, note: 65 sleep 0.5 control s, note: 67 sleep 3 control s, note: 72 Nun h\u00f6ren wir, wie die Noten zwischen den control -Aufrufen gezogen werden. H\u00f6rt sich gut an, oder? Mit einer k\u00fcrzeren Dauer wie beispielsweise note_slide: 0,2 kannst du den \u00dcbergang beschleunigen, oder ihn mit einer l\u00e4ngeren Slide-Dauer verlangsamen. Jeder steuerbare Parameter hat einen entsprechenden _slide -Parameter, mit dem du spielen kannst. Gleiten ist klebrig Nachdem du einmal einen _slide Parameter auf einem laufenden Synth gesetzt hast, wird er erinnert - und er wird jedes mal genutzt, wenn du den dazu geh\u00f6renden Parameter nutzt. Um das Gleiten zu stoppen, musst du den _slide Wert vor dem n\u00e4chsten control -Aufruf auf 0 setzen. Gleitende Effekt-Parameter Es ist ebenso m\u00f6glich, Effekt-Opts gleiten zu lassen: with_fx :wobble, phase: 1, phase_slide: 5 do |e| use_synth :dsaw play 50, release: 5 control e, phase: 0.025 end Und jetzt hab Spa\u00df damit die Dinge ein wenig herumgleiten zu lassen - f\u00fcr weiche \u00dcberg\u00e4nge und Steuerung der Abl\u00e4ufe ... 8 Datenstrukturen Ein sehr praktisches Werkzeug im Werkzeugkasten jeder Programmiererin und jedes Programmierers sind Datenstrukturen. Manchmal m\u00f6chtest du mehr als ein einzelnes Ding darstellen oder verwenden. Du k\u00f6nntest z. B. n\u00fctzlich finden, eine Reihe von Noten zu haben und sie dann nacheinander abzuspielen. Programmiersprachen verwenden Datenstrukturen f\u00fcr genau diesen Zweck. Es gibt einige aufregende und exotische Datenstrukturen die Programmiererinnen und Programmierern zur Verf\u00fcgung stehen - und es werden immer noch weitere erfunden. F\u00fcr unsere Zwecke jedoch ben\u00f6tigen wir vorerst nur eine, sehr einfache, Datenstruktur - die Liste. Lass uns das im Detail ansehen. Wir werden uns die Grundform einer Liste anschauen und wie man sie verwendet, um Skalen und Akkorde abzubilden. 8.1 Listen In diesem Abschnitt werden wir uns eine sehr n\u00fctzliche Datenstruktur ansehen - die Liste. Wir hatten schon einmal in dem Abschnitt \u00fcber Zuf\u00e4lligkeit kurz mit ihr zu tun, als wir die zu spielenden Noten zuf\u00e4llig aus einer Liste ausgew\u00e4hlt haben: play choose([50, 55, 62]) In diesem Abschnitt erforschen wir, wie wir Akkorde und Skalen mit Listen darstellen k\u00f6nnen. Zuerst rufen wir uns wieder in Erinnerung, wie wir einen Akkord spielen k\u00f6nnten. Erinnere dich, dass ohne sleep alle T\u00f6ne zur gleichen Zeit gespielt werden: play 52 play 55 play 59 Lass uns weitere M\u00f6glichkeiten ansehen diesen Programm-Code zu schreiben. Abspielen einer Liste Eine M\u00f6glichkeit ist, alle Noten aus einer Liste heraus abzuspielen: [52, 55, 59] . Unsere freundliche Funktion play ist schlau genug, um zu wissen, wie man eine Liste von Noten abspielt. Probiere es aus: play [52, 55, 59] Oh, das l\u00e4sst sich schon viel besser lesen. Eine Liste von Noten abzuspielen hindert dich nicht daran, alle Parameter so zu verwenden wie sonst auch: play [52, 55, 59], amp: 0.3 Nat\u00fcrlich kannst du auch die traditionellen Notennamen anstelle der MIDI-Nummern verwenden: play [:E3, :G3, :B3] Die Gl\u00fccklichen unter euch, die ein wenig Musiktheorie gelernt haben, haben den Akkord vielleicht erkannt: Es ist E-Moll , gespielt in der 3. Oktave. Auf Listen zugreifen Ein weiteres sehr n\u00fctzliches Merkmal von Listen ist, dass man die in ihnen enthaltenen Informationen auslesen kann. Das klingt vielleicht etwas eigenartig, aber es ist nicht komplizierter, als eine Person zu bitten Seite 23 in einem Buch aufzuschlagen. Eine Liste fragst du einfach, was das Element mit der Indexnummer 23 ist. Das einzig seltsame in diesem Fall ist , dass beim Programmieren Indizes \u00fcblicherweise bei 0 beginnen - nicht bei 1. Listen-Indizes z\u00e4hlen wir also nicht 1, 2, 3 ... sondern 0, 1 ,2 ... Lass uns das im Detail ansehen. Sieh dir diese Liste an: [52, 55, 59] Nichts besonders Be\u00e4ngstigendes. Was ist das zweite Element in dieser Liste? Nat\u00fcrlich, es ist 55 . Das war einfach. Lass uns sehen, ob wir nicht auch den Computer dazu bringen k\u00f6nnen, die Frage f\u00fcr uns zu beantworten: puts [52, 55, 59][1] OK, das sieht etwas seltsam aus, wenn du so etwas noch nie gesehen hast. Aber vertrau mir, es ist nicht allzu schwer. Die Zeile oben besteht aus drei Teilen: dem Wort puts , unserer Liste 52, 55, 59 und unserem Index [1] . Zuerst sagen wir puts , weil wir wollen, dass Sonic Pi die Antwort f\u00fcr uns ins Protokoll schreibt. Als n\u00e4chstes \u00fcbergeben wir unsere Liste, und am Ende fragen wir mit dem Index nach dem zweiten Element in der Liste. Den Index m\u00fcssen wir mit eckigen Klammern umschlie\u00dfen, und da das Z\u00e4hlen mit 0 beginnt, ist die Index-Zahl f\u00fcr das zweite Element 1 . Schau: # indexes: 0 1 2 [52, 55, 59] Versuche mal, den Programm-Code puts [52, 55, 59][1] auszuf\u00fchren, dann wirst du sehen, dass 55 im Protokoll erscheint. \u00c4ndere den Index 1 in andere Indizes, probiere l\u00e4ngere Listen aus - und denke dar\u00fcber nach, wie du Listen einsetzen k\u00f6nntest, wenn du demn\u00e4chst Code live programmieren und damit jammen willst. Zum Beispiel, welche musikalischen Strukturen k\u00f6nnten als eine Reihe von Zahlen geschrieben werden ... 8.2 Akkorde Sonic Pi bietet dir auch Unterst\u00fctzung dabei, dir den Namen eines Akkords in eine Liste seiner T\u00f6ne zu \u00fcbersetzen. Probiere es selbst aus: play chord(:E3, :minor) Damit kommen wir nun wirklich weiter. Das sieht schon viel besser aus als einfache Listen (und es ist f\u00fcr andere viel leichter zu lesen). Welche Akkordaufl\u00f6sungen unterst\u00fctzt Sonic Pi noch? Naja, viele . Probiere ein paar hiervon aus: chord(:E3, :m7) chord(:E3, :minor) chord(:E3, :dim7) chord(:E3, :dom7) Arpeggios Wir k\u00f6nnen Akkorde leicht in Arpeggios umwandeln, indem wir die Funktion play_pattern verwenden: play_pattern chord(:E3, :m7) Ok, that's not so fun - it played it really slowly. play_pattern will play each note in the list with a call to sleep 1 after each call to play . We can use another function play_pattern_timed to specify our own timings and speed things up: play_pattern_timed chord(:E3, :m7), 0.25 Wir k\u00f6nnen sogar eine Liste von Zeiten \u00fcbergeben, die nacheinander verwendet und wiederholt werden: play_pattern_timed chord(:E3, :m13), [0.25, 0.5] Das bedeutet das gleiche wie: play 52, sustain: 0.25 sleep 0.25 play 55, sustain: 0.5 sleep 0.5 play 59, sustain: 0.25 sleep 0.25 play 62, sustain: 0.5 sleep 0.5 play 66, sustain: 0.25 sleep 0.25 play 69, sustain: 0.5 sleep 0.5 play 73, sustain: 0.25 sleep 0.25 Was w\u00fcrdest du lieber schreiben? Note that play_pattern and play_pattern_timed alter the sustain of the notes to fill the times. You can remove this behavior by setting the sustain: opt to 0 : play_pattern_timed chord(:E3, :m13), [0.25, 0.5], sustain: 0 8.3 Skalen Sonic Pi unterst\u00fctzt weite Auswahl von Tonleitern. Wie w\u00e4re es mit einer C3-Dur-Skala? play_pattern_timed scale(:c3, :major), 0.125, release: 0.1 Wir k\u00f6nnen sie auch \u00fcber mehrere Oktaven spielen lassen: play_pattern_timed scale(:c3, :major, num_octaves: 3), 0.125, release: 0.1 Und wie w\u00e4re es mit allen Noten einer pentatonischen Skala? play_pattern_timed scale(:c3, :major_pentatonic, num_octaves: 3), 0.125, release: 0.1 Zuf\u00e4llige Noten Akkorde und Skalen sind gute Methoden, um eine zuf\u00e4llige Auswahl auf etwas Bedeutungsvolles einzugrenzen. Spiele einmal mit diesem Beispiel, das zuf\u00e4llig Noten aus dem E-Moll-Akkord in der 3. Oktave ausw\u00e4hlt: use_synth :tb303 loop do play choose(chord(:E3, :minor)), release: 0.3, cutoff: rrand(60, 120) sleep 0.25 end Probiere auch verschiedene Akkord-Namen und Cut-Off-Bereiche aus. Akkorde und Skalen entdecken Um herauszufinden, welche Skalen und Akkorde Sonic Pi unterst\u00fctzt, klicke einfach auf die Codes -Schaltfl\u00e4che unten links in diesem Tutorial und w\u00e4hle entweder chord (Akkord) oder scale (Skala, Tonleiter) aus der API-Liste. Im Info-Bereich im Hauptfenster scrolle nach unten, bist du eine lange Liste von Akkorden oder Skalen findest (je nach dem auf welches Fenster du gerade schaust). Viel Spa\u00df und nicht vergessen: Es gibt keine Fehler, nur M\u00f6glichkeiten. 8.4 Ringe Eine interessanter Dreh bei einfachen Listen sind Ringe. Wenn du ein bisschen Programmiererfahrung hast, bist du vielleicht schon einmal auf Ring-Buffer (Ringspeicher) oder Ring-Arrays gesto\u00dfen. Wir nennen sie hier - kurz und einfach - Ring. Im vorherigen Abschnitt \u00fcber Listen haben wir gesehen, wie wir \u00fcber den Index-Mechanismus Elemente aus einer Liste holen k\u00f6nnen: puts [52, 55, 59][1] Was passiert jetzt wohl, wenn du den Index 100 abfragen willst? Nun, es gibt offensichtlich kein Element mit dem Index 100, da die Liste nur drei Elemente enth\u00e4lt. Also gibt Sonic Pi nil zur\u00fcck, das steht f\u00fcr 'nichts'. Stell dir jedoch vor, du hast einen Z\u00e4hler, wie den aktuellen Beat (Schlag), der kontinuierlich w\u00e4chst. Lass uns damit unseren Z\u00e4hler und unsere Liste anlegen: counter = 0 notes = [52, 55, 59] Wir k\u00f6nnen jetzt unseren Z\u00e4hler verwenden, um auf eine Note in unserer Liste zuzugreifen: puts notes[counter] Super, da kam 52 heraus. Nun Lass uns den Z\u00e4hler erh\u00f6hen (increment) und auf eine andere Note zugreifen: counter = (inc counter) puts notes[counter] Gut, jetzt kommt 55 und beim folgenden Mal 59 heraus. Wenn wir das jedoch noch einmal machen, werden wir keine Zahlen mehr in unserer Liste haben, und wir bekommen nil zur\u00fcck. Was w\u00e4re, wenn wir in diesem Fall einfach wieder vom Anfang der Liste an z\u00e4hlen wollten? Genau daf\u00fcr gibt es Ringe. Ringe erzeugen Wir k\u00f6nnen Ringe auf zwei Arten erzeugen. Entweder wir nutzen die ring -Funktion, mit den gew\u00fcnschten Elementen aus dem Rings als Parameter: (ring 52, 55, 59) Oder wir nehmen eine normale Liste und wandeln sie mit der Nachricht .ring in einen Ring um: [52, 55, 59].ring Ringe indizieren Sobald du einen Ring hast, kannst du ihn genauso verwenden wie du eine normale Liste verwenden w\u00fcrdest, mit einer Ausnahme: Du kannst darauf auch solche Indizes verwenden, die negativ oder gr\u00f6\u00dfer als der Ringinhalt sind - diese machen dann eine Schleife wieder zum Anfang, um immer auf ein Element des Rings zu verweisen: (ring 52, 55, 59)[0] #=> 52 (ring 52, 55, 59)[1] #=> 55 (ring 52, 55, 59)[2] #=> 59 (ring 52, 55, 59)[3] #=> 52 (ring 52, 55, 59)[-1] #=> 59 Ringe verwenden Lass uns annehmen, wir verwenden eine Variable, die stets die aktuelle Schlagzahl abbildet. Wir k\u00f6nnen diese Variable in unserem Ring als Index verwenden, um so Noten, Release-Zeiten oder andere sinnvolle Dinge abzurufen, unabh\u00e4ngig davon bei welcher Schlagzahl wir uns gerade befinden. Skalen und Akkorde sind Ringe Es ist n\u00fctzlich zu wissen, das die Listen, die von scale und chord zur\u00fcckgegeben werden, auch Ringe sind und du so mit beliebigen Indizes auf sie zugreifen kannst. Ring-Konstruktoren Zus\u00e4tzlich zu ring gibt es eine Anzahl weiterer Funktionen, die Ringe f\u00fcr uns erzeugen. range l\u00e4dt dich dazu ein, einen Startpunkt, einen Endpunkt und eine Schrittgr\u00f6\u00dfe festzulegen. bools erlaubt dir 1 en und 0 en als Kurzform f\u00fcr boolesche Werte zu nutzen. knit erlaubt dir, eine Abfolge zu wiederholender Werte zu stricken (to knit). spread erzeugt einen Ring boolescher Werte in euklidischer Verteilung. F\u00fcr weitere Information sieh dir die Dokumentation zur jeweiligen Funktion an. 8.5 Ring-Ketten Neben der Verwendung von Konstruktoren wie range und spread k\u00f6nnen wir neue Ringe auch dadurch erzeugen, das wir bereits existierende Ringe ver\u00e4ndern. Befehle verketten Um dies auszuprobieren, verwende einen einfachen Ring: (ring 10, 20, 30, 40, 50) Was, wenn wir diese Reihe umkehren wollen? Nun, wir verwenden den Verkettungsbefehl .reverse , um den Ring umzudrehen: (ring 10, 20, 30, 40, 50).reverse #=> (ring 50, 40, 30, 20, 10) Ok, und wenn wir nur die ersten 3 Werte aus dem Ring haben wollten? (ring 10, 20, 30, 40, 50).take(3) #=> (ring 10, 20, 30) Und schlie\u00dflich, wenn wir den Ring mischen wollten? (ring 10, 20, 30, 40, 50).shuffle #=> (ring 40, 30, 10, 50, 20) Mehrfache Ketten Auf diese Art haben wir bereits m\u00e4chtige M\u00f6glichkeiten neue Ringe zu erzeugen. Noch m\u00e4chtiger werden sie allerdings, wenn du mehrere dieser Befehle verkettest. Wie w\u00e4re es den Ring zu mischen, das erste Element wegzulassen, und dann die 3 folgenden Elemente zu verwenden? Lass uns das Schritt f\u00fcr Schritt durchgehen: (ring 10, 20, 30, 40, 50) - dein anf\u00e4nglicher Ring (ring 10, 20, 30, 40, 50).shuffle - mischt ihn zu - (ring 40, 30, 10, 50, 20) (ring 10, 20, 30, 40, 50).shuffle.drop(1) - mischt und l\u00e4sst dann das erste Element weg - (ring 30, 10, 50, 20) (ring 10, 20, 30, 40, 50).shuffle.drop(1).take(3) - mischt, l\u00e4sst das erste Element weg und nimmt 3 - (ring 30, 10, 50) Kannst du sehen, wie wir eine lange Kette dieser Methoden einfach dadurch erzeugen k\u00f6nnen, dass wir sie aneinander kleben ? Wir k\u00f6nnen das in jeder beliebigen Reihenfolge tun, und damit haben wir einen extrem m\u00e4chtigen Weg, um neue Ringe aus bereits bestehenden zu erzeugen. Unver\u00e4nderlichkeit Diese Ringe haben eine m\u00e4chtige und wichtige Eigenschaft. Sie sind unver\u00e4nderlich (immutable) - sie k\u00f6nnen nicht ver\u00e4ndert werden. Das bedeutet, dass die Verkettungsmethoden, von denen wir in diesem Abschnitt sprechen, die Ringe nicht ver\u00e4ndern sondern eher neue Ringe erzeugen . Das bedeutet, du kannst Ringe \u00fcber verschiedene Threads hinweg teilen und anfangen sie innerhalb eines Threads zu verketten, ohne dabei irgend einen anderen Thread zu ver\u00e4ndern, der auf den gleichen Ring zugreift. Verf\u00fcgbare Verkettungsmethoden Dies ist eine Liste der Verkettungsmethoden, mit denen du spielen kannst: .reverse - gibt eine umgedrehte Version des Ringes zur\u00fcck .sort - erzeugt eine sortierte Version des Ringes .shuffle - erzeugt eine gemischte Version des Ringes .pick - liefert einen Ring mit den Resultaten wie 1 mal .choose .pick(3) - liefert einen Ring mit den selben Resultaten wie 3 mal .choose .take(5) - liefert einen Ring, der nur die ersten 5 Elemente enth\u00e4lt .drop(3) - liefert einen Ring, der alles au\u00dfer den ersten 3 Elementen enth\u00e4lt .butlast - liefert einen Ring ohne das letzte Element .drop_last(3) - liefert einen Ring ohne die letzten 3 Elemente .take_last(6) - liefert einen Ring, der nur die letzten 6 Elemente enth\u00e4lt .stretch(2) - wiederholt jedes Element im Ring zweimal .repeat(3) - wiederholt den Ring als Ganzes 3 mal .mirror - h\u00e4ngt eine umgekehrte Version des Rings an den Ring an .reflect - wie .mirror , verdoppelt aber nicht den mittleren Wert .scale(2) - liefert einen neuen Ring mit allen Elementen multipliziert mit 2 (setzt voraus, dass der Ring nur Zahlen enth\u00e4lt) Nat\u00fcrlich k\u00f6nnen solche Verkettungsmethoden, die Zahlenparameter annehmen auch andere Werte annehmen. So kannst du anstelle von .drop(3) z. B. auch .drop(5) aufrufen, wenn du die ersten f\u00fcnf Elemente wegfallen lassen willst. 9 Live-Coding Einer der aufregendsten Aspekte von Sonic Pi ist, dass es dir erm\u00f6glicht den Programm-Code f\u00fcr deine Musik live zu schreiben und zu ver\u00e4ndern, ganz so wie wenn du mit einer Gitarre live auftreten w\u00fcrdest. Ein Vorteil dieses Ansatzes ist, dass du mehr R\u00fcckmeldung erh\u00e4ltst, noch w\u00e4hrend du komponierst - bringe eine einfache Schleife (Loop) an den Start und bearbeite sie so lange, bis sie perfekt klingt. Wie auch immer, der eigentliche Vorteil besteht darin, dass du Sonic Pi mit auf die B\u00fchne nehmen und damit einen Auftritt absolvieren kannst. In diesem Abschnitt behandeln wir die Grundlagen davon, wie du deine statischen Programm-Code-Kompositionen in dynamische Performances verwandeln kannst. Halt dich fest ... 9.1 Live-Coding: Grundlagen Inzwischen haben wir genug gelernt, um tats\u00e4chlich mit dem Spa\u00df anzufangen. In diesem Abschnitt verwenden wir alles, was wir in den vorherigen Abschnitten behandelt haben und zeigen dir, wie du damit beginnen kannst, deine Musik live zu komponieren und in eine Performance zu verwandeln. Dazu ben\u00f6tigen wir 3 wesentliche Zutaten: Die F\u00e4higkeit Programm-Code zu schreiben, der Kl\u00e4nge erzeugt - CHECK! Die F\u00e4higkeit Funktionen zu schreiben - CHECK! Die F\u00e4higkeit Threads (mit Namen) zu verwenden - CHECK! Ok, lass uns loslegen. Lass uns unsere ersten Kl\u00e4nge live programmieren. Zuerst brauchen wir eine Funktion, die den abzuspielenden Code enth\u00e4lt. Lass uns einfach beginnen. Au\u00dferdem wollen wir Aufrufe an diese Funktion in einer Schleife in einem Thread ausf\u00fchren: define :my_sound do play 50 sleep 1 end in_thread(name: :looper) do loop do my_sound end end Wenn dir das ein bisschen zu kompliziert vorkommt, lies bitte noch einmal die Abschnitte \u00fcber Funktionen und Threads durch. Es ist nicht mehr so kompliziert, wenn du sie erstmal verstanden hast. Was wir hier haben, ist die Definition einer Funktion, welche einfach die Note 50 spielt und danach einen Schlag lang schl\u00e4ft. Dann definieren wir einen Thread (mit Namen) - wir nennen ihn :looper - und er ruft in einer Schleife my_sound auf. Wenn du diesen Code ausf\u00fchrst, wirst du immer und immer wieder die Note 50 h\u00f6ren... Einen Gang hochschalten Nun, hier f\u00e4ngt der Spa\u00df an. W\u00e4hrend der Code noch l\u00e4uft , \u00e4ndere die 50 in eine andere Zahl, sagen wir 55, und klicke nochmals auf Ausf\u00fchren . Wow! Es hat sich ge\u00e4ndert! Live! Es hat keine neue Ebene hinzugef\u00fcgt, da wir einen benannten Thread verwendet haben und es f\u00fcr jeden Namen nur einen Thread geben kann. Der Klang hat sich ge\u00e4ndert, weil wir die Funktion umdefiniert haben. Wir haben also :my_sound eine neue Definition gegeben. W\u00e4hrend im :looper -Thread die Schleife lief, hat er darin einfach die neue Definition aufgerufen. Ver\u00e4ndere die Definition der Funktion noch einmal, \u00e4ndere die Note, \u00e4ndere die Pausenzeit. Und wie w\u00e4re es eine use_synth -Aussage hinzuzuf\u00fcgen? Z. B. \u00e4ndere die Funktion in: define :my_sound do use_synth :tb303 play 50, release: 0.3 sleep 0.25 end Jetzt klingt es schon ganz interessant, wir k\u00f6nnen es aber noch ein bisschen interessanter machen. Anstatt immer wieder die gleiche Note zu spielen, versuche einen Akkord zu spielen: define :my_sound do use_synth :tb303 play chord(:e3, :minor), release: 0.3 sleep 0.5 end Und wie w\u00e4re es damit, zuf\u00e4llige T\u00f6ne des Akkords zu spielen: define :my_sound do use_synth :tb303 play choose(chord(:e3, :minor)), release: 0.3 sleep 0.25 end Oder einen zuf\u00e4lligen Cut-Off-Wert: define :my_sound do use_synth :tb303 play choose(chord(:e3, :minor)), release: 0.2, cutoff: rrand(60, 130) sleep 0.25 end Und schlie\u00dflich, f\u00fcge etwas Schlagzeug hinzu: define :my_sound do use_synth :tb303 sample :drum_bass_hard, rate: rrand(0.5, 2) play choose(chord(:e3, :minor)), release: 0.2, cutoff: rrand(60, 130) sleep 0.25 end Jetzt wird die Sache langsam aufregend! Wie auch immer, bevor du jetzt aufspringst und anf\u00e4ngst mit Funktionen und Threads live zu programmieren, h\u00f6r mit dem was du gerade machst auf und lies den n\u00e4chsten Abschnitt \u00fcber live_loop - das wird die Art wie du in Sonic Pi programmierst, f\u00fcr immer ver\u00e4ndern ... 9.2 Live-Loops Ok, dieser Abschnitt des Tutorials ist ein echtes Juwel. Wenn du nur einen einzigen Abschnitt lesen w\u00fcrdest, sollte es dieser sein. Wenn du den letzten Abschnitt \u00fcber die Grundlagen von Live-Coding gelesen hast - live_loop ist eine einfache Art genau das gleiche zu tun, aber ohne dass du so viel schreiben musst. Falls du den letzten Abschnitt nicht gelesen hast - live_loop ist der beste Weg, um mit Sonic Pi zu jammen. Lass uns spielen. Schreibe Folgendes in einen neuen Puffer: live_loop :foo do play 60 sleep 1 end Jetzt klicke auf Ausf\u00fchren . Du h\u00f6rst mit jedem Schlag ein einfaches Piepen. Nichts unterhaltsames daran. Klicke aber noch nicht auf Stopp . \u00c4ndere die 60 in 65 und klicke wieder Ausf\u00fchren . Wow! Es hat sich automatisch ge\u00e4ndert ohne einen Schlag auszulassen. Das ist Live-Coding. Warum es nicht ein wenig mehr nach Bass klingen lassen? Aktualisiere deinen Programm-Code, w\u00e4hrend er abl\u00e4uft: live_loop :foo do use_synth :prophet play :e1, release: 8 sleep 8 end Dann klicke auf Ausf\u00fchren . Lassen wir den Cut-Off sich ein wenig bewegen: live_loop :foo do use_synth :prophet play :e1, release: 8, cutoff: rrand(70, 130) sleep 8 end Klicke wieder auf Ausf\u00fchren . F\u00fcge etwas Schlagzeug hinzu: live_loop :foo do sample :loop_garzul use_synth :prophet play :e1, release: 8, cutoff: rrand(70, 130) sleep 8 end Wechsle die Note von e1 zu c1 : live_loop :foo do sample :loop_garzul use_synth :prophet play :c1, release: 8, cutoff: rrand(70, 130) sleep 8 end Nun h\u00f6re nicht weiter mir zu - spiele selbst herum! Viel Spa\u00df! 9.3 Mehrere Live-Loops Sieh dir den folgenden Live-Loop an: live_loop :foo do play 50 sleep 1 end Vielleicht fragst du dich, warum er den Namen :foo braucht. Dieser Name ist wichtig, weil er bedeutet, dass sich dieser Live-Loop von allen anderen Live-Loops unterscheidet. Es kann nie zwei Live-Loops mit dem selben Namen geben, die zur gleichen Zeit laufen . Das bedeutet, wenn wir mehrere Live-Loops gleichzeitig laufen lassen wollen, m\u00fcssen wir ihnen einfach nur verschiedene Namen geben: live_loop :foo do use_synth :prophet play :c1, release: 8, cutoff: rrand(70, 130) sleep 8 end live_loop :bar do sample :bd_haus sleep 0.5 end Du kannst jetzt beide Live-Loops unabh\u00e4ngig voneinander ver\u00e4ndern, und alles funktioniert - einfach so. Live-Loops synchronisieren Du hast vielleicht schon bemerkt, dass Live-Loops automatisch mit dem Thread-Cue-Mechanismus arbeiten, den wir uns bereits angeschaut haben. Mit jedem Mal wenn der Live-Loop einen Durchlauf beginnt, generiert er ein neues Cue-Ereignis, das den Namen des Live-Loops erh\u00e4lt. Wir k\u00f6nnen daher mit diesen Cues in sync bleiben und so sicherstellen, dass unsere Schleifen sich synchronisieren, ohne dass wir etwas anhalten m\u00fcssen. Schau dir diesen schlecht synchronisierten Code an: live_loop :foo do play :e4, release: 0.5 sleep 0.4 end live_loop :bar do sample :bd_haus sleep 1 end Lass uns versuchen das Timing zu korrigieren ohne den Live-Loop zu stoppen. Zuerst lass uns den Live-Loop :foo reparieren, indem wir seine Sleep-Zeit zu einem Divisor von 1 machen - so etwas wie 0.5 wird z. B. funktionieren: live_loop :foo do play :e4, release: 0.5 sleep 0.5 end live_loop :bar do sample :bd_haus sleep 1 end Damit sind wir aber noch nicht ganz fertig - du wirst bemerken, dass die Beats nicht so recht zusammenpassen. Der Grund daf\u00fcr ist, dass die Live-Loops out of phase sind. Lass uns das reparieren, indem wir den einen mit dem anderen synchronisieren: live_loop :foo do play :e4, release: 0.5 sleep 0.5 end live_loop :bar do sync :foo sample :bd_haus sleep 1 end Toll, jetzt passt das Timing perfekt - ohne dass wir die Live-Loops anhalten mussten. Jetzt leg los und programmiere live mit Live-Loops! 9.4 Ticks verwenden Du wirst sehen, dass du beim Live-Coding sehr h\u00e4ufig Ringe in deinen Live-Loops verwenden wirst. Du wirst Noten in Ringen setzen f\u00fcr Melodien, Pausen f\u00fcr Rhythmen, und du wirst aus ihnen Akkordfolgen, Klangvariatonen und \u00e4hnliches generieren. Ticks und Ringe Sonic Pi bietet ein sehr praktisches Werkzeug, um in einem live_loop mit Ringen zu arbeiten. Es nennt sich Tick-System. In dem Abschnitt \u00fcber Ringe haben wir \u00fcber den Counter gesprochen, der etwas fortw\u00e4hrend hochz\u00e4hlt, wie z. B. eine Schlagzahl. Tick hat diese Idee eingebaut. Du kannst damit durch einen Ring ticken . Lass uns ein Beispiel ansehen: counter = 0 live_loop :arp do play (scale :e3, :minor_pentatonic)[counter], release: 0.1 counter += 1 sleep 0.125 end Das ist gleichbedeutend mit: live_loop :arp do play (scale :e3, :minor_pentatonic).tick, release: 0.1 sleep 0.125 end Hier nehmen wir einfach die pentatonische E3-Moll-Skala (Tonleiter) und ticken durch jedes einzelne Element. Daf\u00fcr wird .tick an das Ende der Tonleiter-Deklaration angef\u00fcgt. Dieser Tick gilt nur lokal f\u00fcr diesen Live-Loop, so dass jeder Live-Loop seinen eigenen unabh\u00e4ngigen Tick haben kann: live_loop :arp do play (scale :e3, :minor_pentatonic).tick, release: 0.1 sleep 0.125 end live_loop :arp2 do use_synth :dsaw play (scale :e2, :minor_pentatonic, num_octaves: 3).tick, release: 0.25 sleep 0.25 end Tick Du kannst tick als eine Standard-Funktion abfragen und den Wert als Index verwenden: live_loop :arp do idx = tick play (scale :e3, :minor_pentatonic)[idx], release: 0.1 sleep 0.125 end Aber eigentlich ist es viel einfacher, wenn du .tick am Ende anf\u00fcgst. Die tick -Funktion ist daf\u00fcr gedacht aufwendigere damit Dinge zu machen, oder wenn du Ticks f\u00fcr andere Dinge verwenden m\u00f6chtest, als Werte aus einem Ring zu erhalten. Look Das Magische an Tick ist, dass er nicht nur nach jedem Aufruf einen neuen Index zur\u00fcck gibt (oder den Wert aus dem Ring an diesem Indexpunkt), er stellt auch sicher, dass du beim n\u00e4chsten Aufruf von Tick auch den n\u00e4chsten Wert bekommst. Schau dir im Hilfe-Fenster die Beispiele f\u00fcr .tick an, um die vielen M\u00f6glichkeiten seiner Verwendung zu entdecken. F\u00fcr den Moment jedoch ist es wichtig zu betonen, dass du manchmal nur den aktuellen Tick-Wert sehen willst, ohne den Tick hochzuz\u00e4hlen . Daf\u00fcr gibt es die look -Funktion. Du kannst look als Standard-Funktion aufrufen oder indem du .look an einen Ring anf\u00fcgst. Namen f\u00fcr Ticks Schlie\u00dflich wirst du gelegentlich auch mal mehr als einen Tick pro Live-Loop brauchen. das erreichst du, indem du deinem Tick einen Namen gibst: live_loop :arp do play (scale :e3, :minor_pentatonic).tick(:foo), release: 0.1 sleep (ring 0.125, 0.25).tick(:bar) end In diesem Beispiel verwenden wir zwei Ticks, einen f\u00fcr die Note und einen zweiten Tick f\u00fcr die Pausenwerte. Da beide sich im gleichen Live-Loop befinden, m\u00fcssen wir ihnen zur Unterscheidung eindeutige Namen geben. Das ist exakt das gleiche Prinzip wie bei der Benennung von Live-Loops - wir \u00fcbergeben einfach ein : gefolgt vom Namen. Im obigen Beispiel haben wir einen Tick :foo genannt und den anderen :bar . Auch wenn wir den Tick-Wert mit look nur abfragen wollen, m\u00fcssen wir den Namen \u00fcbergeben. Mache es nicht zu kompliziert Die meisten machtvollen Dinge im Tick-System sind wenig sinnvoll, wenn du gerade erst anf\u00e4ngst. Versuche nicht alles in diesem Abschnitt gleich zu lernen. Konzentriere darauf durch einen einzelnen Ring zu ticken. Das wird dir schon sehr viel von der Freude und der Einfachheit des Tickens in deinen live_loop s bringen. Schau dir die Dokumentation f\u00fcr tick an - es gibt dort viele n\u00fctzliche Beispiele. Viel Spa\u00df beim Ticken! 10 Time-State (Stand der Zeit) Oftmals ist es sinnvoll, Informationen zu haben, die \u00fcber verschiedenen Threads or Live-Loops geteilt werden kann . Beispielsweise m\u00f6chtest du vielleicht die aktuelle Tonart, BPM oder auch abstraktere Konzepte wie z. B. die aktuelle 'Komplexit\u00e4t' (die wiederum in den verschiedenen Threads unterschiedlich interpretiert werden k\u00f6nnte) teilen. Wenn wir dies tun, m\u00f6chten wir aber auch nicht auf die garantierte Bestimmbarkeit von Sonic Pi verzichten. In anderen Worten: Wir m\u00f6chten immer noch Programm-Code mit anderen teilen und sicherstellen k\u00f6nnen, dass wir genau wissen, was sie h\u00f6ren, wenn sie ihn ausf\u00fchren. Am Ende des Abschnitts 5.6. dieses Tutorials haben wir kurz dar\u00fcber gesprochen, warum wir Variablen nicht nutzen sollten, um Informationen zwischen Threads zu teilen , da wir dadurch diese Vorhersagbarkeit verlieren (aufgrund von Race Conditions). Sonic Pi's L\u00f6sung f\u00fcr das Problem auf einfache Art mit globalen Variablen in einer vorhersagbaren Weise zu arbeiten, ist ein neuartiges System, das es Time-State (Stand der Zeit) nennt. Es mag erstmal komplex und schwierig klingen (Programmieren mit mehrfachen Threads und geteiltem Speicher werden normalerweise erst in der Universit\u00e4t behandelt). Allerdings wie du sehen wirst, genau wie beim Spielen deiner ersten Note, macht es dir Sonic Pi unglaublich einfach, einen Zustand \u00fcber mehrere Threads zu teilen und dabei dennoch deine Programme *thread-safe und vorhersagbar\" bleiben zu lassen. Sag Hallo zu get und set ... 10.1 Set und Get Sonic Pi verf\u00fcgt \u00fcber einen globalen Speicherbereich, der Time-State genannt wird. Die beiden wesentliche damit m\u00f6glichen Dinge sind das Setzen von Informationen (Set) und das Holen von Information (Get). Lass uns das genauer ansehen ... Set Um Informationen in den Time-State zu speichern ben\u00f6tigen wir zwei Dinge: die Information, die wir speichern wollen, einen eindeutigen Namen (Schl\u00fcssel) f\u00fcr die Information. Zum Beispiel wollen wir vielleicht die Zahl 3000 unter dem Schl\u00fcsselnamen :intensity speichern. Das ist m\u00f6glich mit der set -Funktion: set :intensity, 3000 Wir k\u00f6nnen f\u00fcr den Schl\u00fcssel einen beliebigen Namen verwenden. Wurde unter diesem Schl\u00fcsselnamen bereits Information gespeichert, wird unser neuer set -Befehl diese \u00fcberschreiben: set :intensity, 1000 set :intensity, 3000 In dem obigen Beispiel haben wir beide Werte unter dem gleichen Schl\u00fcsselnamen abgespeichert, und der letzte set -Befehl 'gewinnt', so dass die Zahl 3000 mit :intensity assoziiert wird, also unser erster set -Befehl damit \u00fcberschrieben wurde. Get Um Informationen aus dem Time-State wiederzuholen, ben\u00f6tigen wir nur den Schl\u00fcssel, den wir bei set verwendet haben, also in unserem Fall :intensity . Wir m\u00fcssen jetzt nur get[:intensity] aufrufen, und das Ergebnis wird uns im Protokoll angezeigt: print get[:intensity] #=> prints 3000 Beachte, dass Aufrufe von get Informationen zur\u00fcckgeben k\u00f6nnen, die bei einem vorherigem Programm-Lauf gesetzt wurden. Wurde eine Information einmal mit Hilfe von set gesetzt, bleibt sie solange verf\u00fcgbar, bis sie entweder \u00fcberschrieben wird (so wie wir den Wert 1000 von intensity mit 3000 vertauscht haben) oder Sonic Pi beendet wird. Mehrere Threads Der wesentliche Vorteil des Time-State-Systems ist, dass es auf sichere Art und Weise zwischen Threads und zwischen Live-Loops verwendet werden kann. Beispielsweise k\u00f6nnte ein Live-Loop Informationen setzen und ein anderer diese auslesen: live_loop :setter do set :foo, rrand(70, 130) sleep 1 end live_loop :getter do puts get[:foo] sleep 0.5 end Das Sch\u00f6ne an der Verwendung von get und set \u00fcber Threads hinweg ist, dass immer das gleiche Ergebnis ausgegeben wird, wenn der Programm-Code gestartet wird. Los, probiere es selbst. Sieh nach, ob dir das Folgende im Protokoll ausgegeben wird: {run: 0, time: 0.0} \u2514\u2500 125.72265625 {run: 0, time: 0.5} \u2514\u2500 125.72265625 {run: 0, time: 1.0} \u2514\u2500 76.26220703125 {run: 0, time: 1.5} \u2514\u2500 76.26220703125 {run: 0, time: 2.0} \u2514\u2500 114.93408203125 {run: 0, time: 2.5} \u2514\u2500 114.93408203125 {run: 0, time: 3.0} \u2514\u2500 75.6048583984375 {run: 0, time: 3.5} \u2514\u2500 75.6048583984375 Starte das Programm einfach mehrmals hintereinander - du siehst, dass das Ergebnis jedes Mal das Gleiche ist. Wir bezeichnen dies als deterministisches (vorhersagbares) Verhalten, und es ist sehr wichtig, wenn wir unsere Musik als Programm-Code weitergeben, zu wissen, dass die Person, die den Code ausf\u00fchrt, genau das h\u00f6ren wird, was wir sie h\u00f6ren lassen wollten (\u00e4hnlich wie beim Abspiel einer MP3 oder beim Streamen f\u00fcr alle H\u00f6rer dasselbe zu h\u00f6ren ist). Ein einfaches deterministisches State-System In Abschnitt 5.6 haben wir dar\u00fcber gesprochen, wie die Nutzung von Variablen \u00fcber verschiedenen Threads hinweg zu zuf\u00e4lligen Resultaten f\u00fchren kann. Das hindert uns daran Programm-Code wie diesen zuverl\u00e4ssig zu reproduzieren: ## Ein Beispiel f\u00fcr ein nicht-deterministisches Verhalten ## (aufgrund von Race Conditions, die durch ## mehrfache Live-Loops ausgel\u00f6st werden, die den Wert ## der selben Variable ver\u00e4ndern). ## ## Wenn du den Code startest, siehst du, ## dass die Liste, die ausgegeben wird, ## nicht immer sortiert ist! a = (ring 6, 5, 4, 3, 2, 1) live_loop :shuffled do a = a.shuffle sleep 0.5 end live_loop :sorted do a = a.sort sleep 0.5 puts \"sorted: \", a end Lass uns sehen, wie wir hier get und set einsetzen k\u00f6nnten: ## Ein Beispiel f\u00fcr deterministisches Verhalten ## (trotz gleichzeitigem Zugriff auf einen geteilten Zustand) ## mit Hilfe des Sonic Pi Time State Systems. ## ## Bei Ausf\u00fchrung dieses Codes, ## wird die Liste immer sortiert ausgegeben! set :a, (ring 6, 5, 4, 3, 2, 1) live_loop :shuffled do set :a, get[:a].shuffle sleep 0.5 end live_loop :sorted do set :a, get[:a].sort sleep 0.5 puts \"sorted: \", get[:a] end Beachte, dass dieser Code fast identisch ist mit dem Code, der eine Variable zum Teilen der Information verwendet hat. Wenn du ihn ausf\u00fchrst verh\u00e4lt er sich allerdings so, wie du es bei jedem typischen Sonic Pi Code erwarten w\u00fcrdest - er verh\u00e4lt sich immer gleich , in diesem Fall dank des Time-State-Systems. Deshalb verwende f\u00fcr ein vorhersagbares und reproduzierbares Verhalten anstelle von Variablen immer get und set , wenn du Daten zwischen Live-Loops und zwischen Threads teilst. 10.2 Synchronisation In Abschnitt 5.7 haben wir die Funktionen cue und sync vorgestellt, f\u00fcr die Synchronisierung von Threads. Was wir dort nicht erkl\u00e4rt haben ist, dass es das Time-State-System ist, das diese Funktionalit\u00e4t bereitstellt. Tats\u00e4chlich ist set eine Variation von cue und baut auf er selben Kernfunktion auf, Informationen im Time-State-System zu hinterlegen. Dar\u00fcber hinaus ist sync so gestaltet, dass es unmittelbar mit Time-State arbeitet - jegliche Information, die wir zuk\u00fcnftig im Time State ablegen wollen, kann auch zur Synchronisierung verwendet werden. Mit anderen Worten - wir synchronisieren auf Ereignisse, die erst noch im Time-State gespeichert werden . Warten auf Ereignisse Lass uns mal ansehen, wie sync verwendet wird, um auf neue Ereignisse zu warten, die dem Time-State hinzugef\u00fcgt werden: in_thread do sync :foo sample :ambi_lunar_land end sleep 2 set :foo, 1 In diesem Beispiel erstellen wir zuerst einen Thread, der darauf wartet, dass ein Ereignis ':foo' dem Time-State hinzugef\u00fcgt wird. Nach dieser Thread-Deklaration schlafen wir f\u00fcr 2 Schl\u00e4ge, und dann setzen wir mit 'set' den Wert f\u00fcr ':foo' auf '1'. Dies entfernt sync , was dann auf die n\u00e4chste Zeile \u00fcbergeht, in der das ':ambi_lunar_land'-Sample getriggert wird. Beachte, dass sync immer auf zuk\u00fcnftige Ereignisse wartet, und dass es den gegenw\u00e4rtigen Thread blockieren wird, w\u00e4hrend es auf ein neues Ereignis wartet. Zus\u00e4tzlich erbt es die logische Zeit des Threads, der es via set oder cue getriggert hat, sodass sich hierdurch auch die Zeit von zwei Threads synchronisieren l\u00e4sst. \u00dcbergabe von Werten an die Zukunft In diesem Beispiel setzen wir ':foo' auf '1', dar\u00fcber hinaus haben wir damit nichts angefangen. Diesen Wert k\u00f6nnen wir im Thread tats\u00e4chlich abfragen ('get'), indem wir sync aufrufen: in_thread do amp = sync :foo sample :ambi_lunar_land, amp: amp end sleep 2 set :foo, 0.5 Beachte, dass Werte die mit Hilfe von set und `cue \u00fcbergeben werden, thread-safe sein m\u00fcssen - dies sind unver\u00e4nderliche Ringe (immutable rings), Zahlen, Symbole oder eingefrorene Zeichenketten (frozen strings). Sonic Pi gibt einen Fehler aus, falls du einen Wert im Time-Store ablegen willst, der nicht g\u00fctig ist. 10.3 Muster-Abgleich Beim Holen und Setzen von Informationen unter Verwendung von Time-State lassen sich komplexere Schl\u00fcssel verwenden als einfache Symbole wie :foo und :bar . Du kannst auch Zeichenketten in der Art von URLs verwenden, wie z.B. \"/foo/bar/baz\" . Sobald wir anfangen mit Pfaden zu arbeiten, k\u00f6nnen wir auch die Vorteile des ausgekl\u00fcgelten Muster-Abgleich-Systems von Sonic Pi nutzen, um get und sync mit '\u00e4hnlichen' und nicht mit 'identischen' Pfaden zu synchronisieren. Lass uns einen Blick darauf werfen. Abgleich mit allen Pfad-Segmenten Lass uns annehmen wir m\u00f6chten auf das n\u00e4chste Ereignis warten, das die folgenden drei Pfad-Segmente enth\u00e4lt: sync \"/*/*/*\" Dieses Muster wird zu jedem Time-State-Ereignis passen, das aus exakt drei Pfadsegmenten besteht, unabh\u00e4ngig von deren Namen. Zum Beispiel: cue \"/foo/bar/baz\" cue \"/foo/baz/quux\" cue \"/eggs/beans/toast\" cue \"/moog/synths/rule\" Allerdings wird es nicht zu Ereignissen mit wenigeren oder mehr Pfad-Segmente passen. Die folgenden w\u00fcrden nicht passen: cue \"/foo/bar\" cue \"/foo/baz/quux/quaax\" cue \"/eggs\" Jeder * bedeutet jeder Inhalt . Das bedeutet, wir k\u00f6nnen Pfade mit nur einem Segment mit /* oder Pfade aus f\u00fcnf Segmenten mit /*/*/*/*/* abgleichen Abgleich mit Teilsegmenten Wenn wir wissen, womit das Segment beginnen oder enden wird, k\u00f6nnen wir ein * zus\u00e4tzlich zum Namen eines Teilsegments verwenden. Zum Beispiel: \"/foo/b*/baz\" passt zu jedem Pfad, der drei Segmente hat, von denen das erste foo , das letzte baz und das mittlere Segment alles sein kann, was mit b beginnt. Also, es w\u00fcrde passen zu: cue \"/foo/bar/baz\" cue \"/foo/baz/baz\" cue \"/foo/beans/baz\" Allerdings w\u00fcrde es nicht zu Folgendem passen: cue \"/foo/flibble/baz\" cue \"/foo/abaz/baz\" cue \"/foo/beans/baz/eggs\" Du kannst das * auch an den Anfang des Segments setzen, um die letzten Zeichen eines Segments anzugeben: \"/foo/*zz/baz\" , wird zu jedem cue or set bestehend aus 3 Segmenten passen, wo das erste Segment foo , das letzte baz ist und das mittlere Segment auf zz endet, so wie \"cue \"/foo/whizz/baz\" . Abgleich mit verschachtelten Pfadsegmenten Manchmal wei\u00dft du nicht, wie viele Pfadsegmente du abgleichen m\u00f6chtest. In diesen F\u00e4llen kannst du den m\u00e4chtigen Doppelstern ** verwenden, wie in \"/foo/**/**/baz\" , das \u00fcbereinstimmt mit: cue \"/foo/bar/baz\" cue \"/foo/bar/beans/baz\" cue \"/foo/baz\" cue \"/foo/a/b/c/d/e/f/baz\" Abgleich mit einzelnen Buchstaben Du kannst das ? verwenden, um mit einem beliebigen einzelnen Zeichen abzugleichen. \"/?oo/bar/baz\" passt zu: cue \"/foo/bar/baz\" cue \"/goo/bar/baz\" cue \"/too/bar/baz\" cue \"/woo/bar/baz\" Abgleich mit mehreren W\u00f6rtern Wenn du wei\u00dft, das ein Segment eines aus einer bestimmten Reihe von W\u00f6rtern ist, kannst du eine Auswahlliste zwischen { und } setzen, so wie \"/foo/{bar,beans,eggs}/quux\" , was nur auf das Folgende passt: cue \"/foo/bar/quux\" cue \"/foo/beans/quux\" cue \"/foo/eggs/quux\" Abgleich mit mehreren Zeichen Schlie\u00dflich kannst du auch noch gegen eine Auswahl von Buchstaben abgleichen, indem du eine Auswahlliste zwischen { und } setzt, so wie \"/foo/[abc]ux/baz\" , was nur passen wird zu: cue \"/foo/aux/baz\" cue \"/foo/bux/baz\" cue \"/foo/cux/baz\" Du kannst mit - auch Buchstabenbereiche angeben. Zum Beispiel \"/foo/[a-e]ux/baz\" , was nur passt zu: cue \"/foo/aux/baz\" cue \"/foo/bux/baz\" cue \"/foo/cux/baz\" cue \"/foo/dux/baz\" cue \"/foo/eux/baz\" Kombination von Abgleichen Wenn du sync oder get aufrufst, kannst du Abgleiche mit Mustern in beliebiger Reihenfolge miteinander kombinieren, um sehr effektiv jedes beliebige Time-State-Ereignis, das durch cue oder set erzeugt wurde, zu erkennen. Lass uns ein verr\u00fccktes Beispiel anschauen: in_thread do sync \"/?oo/[a-z]*/**/ba*/{quux,quaax}/\" sample :loop_amen end sleep 1 cue \"/foo/beans/a/b/c/d/e/bark/quux/\" OSC Musterabgleich For those curious, these matching rules are based on the Open Sound Control pattern matching specification which is explained in detail here: https://opensoundcontrol.stanford.edu/spec-1_0.html 11 MIDI Wenn du es geschafft hast Programm-Code in Musik zu verwandeln, fragst du dich vielleicht - was kommt als n\u00e4chstes? Manchmal sind die Beschr\u00e4nkungen, die darin bestehen nur mit Sonic Pis Syntax und Soundsystem zu arbeiten, aufregend und versetzen dich in eine neue kreative Lage. Manchmal jedoch ist es nochmal etwas grundlegend anderes, aus dem Programm-Code auszubrechen - in die reale Welt. Wir brauchen zwei zus\u00e4tzliche Dinge: Die M\u00f6glichkeit Ereignisse in der realen Welt in Sonic-Pi-Ereignisse umzuwandeln, um damit zu programmieren Die M\u00f6glichkeit Sonic Pis starkes Takt-Modell und Semantik zu nutzen, um Objekte in der realen Welt zu steuern und zu ver\u00e4ndern Gl\u00fccklicherweise gibt es ein Protokoll, das schon seit den 80ern existiert, das genau diese Art von Interaktion m\u00f6glich macht - MIDI. Es gibt eine unglaubliche Anzahl an externen Ger\u00e4ten, unter anderem Keyboards, Controller, Sequencer, und professionelle Audio Software, die alle MIDI unterst\u00fctzen. Wir k\u00f6nnen MIDI nutzen, um Daten zu empfangen und auch um Daten zu senden. Sonic Pi bietet vollst\u00e4ndige Unterst\u00fctzung f\u00fcr das MIDI Protokoll, was es dir erlaubt deinen Live-Code mit der realen Welt zu verbinden. Lass uns das genauer untersuchen ... 11.1 MIDI In In diesem Abschnitt werden wir lernen einen MIDI-Controller anzuschlie\u00dfen, um Ereignisse an Sonic Pi zu senden, mit denen unsere Synths und Kl\u00e4nge steuern. Besorge dir einen MIDI-Controller, wie z. B. ein Keyboard oder eine Controller-Oberfl\u00e4che und lass uns handgreiflich werden! MIDI-Controller verbinden Um Informationen von einem externen MIDI-Ger\u00e4t in Sonic Pi zu bekommen m\u00fcssen wir es zun\u00e4chst an unseren Computer anschlie\u00dfen. Normalerweise wird das mittels einer USB-Verbindung sein, \u00e4ltere Ger\u00e4te hingegen haben einen 5-Pol-DIN-Stecker f\u00fcr den du Hardwareunterst\u00fctzung in deinem Computer brauchst (manche Audio-Interfaces bzw. Soundkarten haben MIDI-DIN-Stecker). Nachdem du dein Ger\u00e4t angeschlossen hast, starte Sonic Pi und wirf einen Blick auf den I/O-Bereich in den Einstellungen. Du solltest dein Ger\u00e4t dort aufgelistet finden. Falls nicht, klicke auf 'MIDI zur\u00fccksetzen' und sieh nach, ob es auftaucht. Wenn du immer noch keinen Eintrag in der Liste findest, ist der n\u00e4chste Schritt zu versuchen in der MIDI-Konfiguration deines Betriebssystems nachzusehen, um zu sehen ob dein Ger\u00e4t erkannt wird. Wenn das alles fehlschl\u00e4gt, kannst du gerne in unserem freundlichen \u00f6ffentlichen Forum Fragen dazu stellen: https://in-thread.sonic-pi.net MIDI-Ereignisse empfangen Sobald dein Ger\u00e4t verbunden ist, wird Sonic Pi automatisch Ereignisse empfangen. Du kannst das selbst nachpr\u00fcfen indem du dein MIDI-Ger\u00e4t bedienst und auf das Cue-Protokoll unten rechts im Anwendungsfenster unterhalb des Protokolls schaust (falls es nicht sichtbar ist, gehe zu Einstellungen->Editor->Ein-/Ausblenden und aktiviere 'Zeige Cue-Protokoll'). Du wirst einen Datenstrom von Ereignissen sehen wie: /midi:nanokey2_keyboard:0:1/note_off [55, 64] /midi:nanokey2_keyboard:0:1/note_on [53, 102] /midi:nanokey2_keyboard:0:1/note_off [57, 64] /midi:nanokey2_keyboard:0:1/note_off [53, 64] /midi:nanokey2_keyboard:0:1/note_on [57, 87] /midi:nanokey2_keyboard:0:1/note_on [55, 81] /midi:nanokey2_keyboard:0:1/note_on [53, 96] /midi:nanokey2_keyboard:0:1/note_off [55, 64] Wenn du einen Strom von Signalen wie diesen siehst, hast du dein MIDI-Ger\u00e4t erfolgreich verbunden. Gl\u00fcckwunsch, lass uns schauen, was wir damit machen k\u00f6nnen! MIDI-Time-State Diese Ereignisse sind in zwei Abschnitte unterteilt. Als Erstes steht da der Name des Ereignisses, wie z. B. /midi:nanokey2_keyboard:0:1/note_on und zum Zweiten gibt es die Werte des Ereignisses wie z. B. [18, 62] . Interessanterweise sind das die zwei Dinge, die wir brauchen, um Ereignisse in Time-State zu speichern. Sonic Pi f\u00fcgt eingehende MIDI-Ereignisse automatisch in Time-State ein . Das bedeutet du kannst auf den letzten MIDI -Wert mit get zugreifen, und auch mit sync auf den n\u00e4chsten MIDI-Wert warten - dabei kannst du alles anwenden, was wir in Abschnitt 10 dieses Tutorials gelernt haben. Programm-Code steuern Nachdem wir jetzt ein MIDI-Ger\u00e4t verbunden haben, dessen Ereignisse im Cue-Protokoll sehen konnten und wissen, dass unsere Kenntnisse \u00fcber Time-State alles sind, was wir zum Arbeiten mit Ereignissen brauchen - k\u00f6nnen wir jetzt anfangen Spa\u00df zu haben. Lass uns ein einfaches MIDI-Piano bauen: live_loop :midi_piano do note, velocity = sync \"/midi:nanokey2_keyboard:0:1/note_on\" synth :piano, note: note end Es passieren einige Dinge im obigen Code, einschlie\u00dflich einiger Probleme. Zun\u00e4chst haben wir da einen einfachen live_loop , der den Code zwischen dem do / end Block unendlich wiederholt. Das wurde im Abschnitt 9.2 behandelt. Danach rufen wir sync auf, um auf das n\u00e4chste Time-State-Ereignis zu warten. Wir benutzen eine Zeichenkette, die das MIDI-Signal repr\u00e4sentiert, nach dem wir suchen (es ist dasselbe, das uns im Cue-Protokoll angezeigt wurde). Achte darauf, wie dir Sonic Pi die vollst\u00e4ndige Zeichenkette mit seinem Autovervollst\u00e4ndigungssystem erstellt, sodass du sie nicht komplett von Hand eintippen musst. Im Protokoll haben wir gesehen, dass es zwei Werte f\u00fcr jedes MIDI-Note-on-Ereignis gab, also weisen wir das Ergebnis zwei separaten Variablen note und velocity zu. Schlie\u00dflich triggern wir den :piano -Synth und \u00fcbergeben unsere Note. Jetzt probiere du es. Gib den obigen Programm-Code ein, ersetzte in sync den Schl\u00fcssel mit einer Zeichenkette, die zu deinem spezifischen MIDI-Ger\u00e4t passt und klicke auf Ausf\u00fchren. Hey, und schon hast du ein funktionierendes Klavier! Wahrscheinlich fallen dir jedoch ein paar Probleme auf: Unabh\u00e4ngig davon wie stark du die Tasten anschl\u00e4gst, klingen die Noten immer gleich laut. Das l\u00e4sst sich leicht dadurch beheben, dass wir den MIDI-Wert f\u00fcr Velocity (Anschlagst\u00e4rke) nutzen und zu Lautst\u00e4rke wandeln. Da MIDI einen Wertebereich von 0-127 hat, m\u00fcssen wir diese Zahl in einen Wert zwischen 0->1 zu konvertieren, indem wir sie einfach durch 127 teilen: live_loop :midi_piano do note, velocity = sync \"/midi:nanokey2_keyboard:0:1/note_on\" synth :piano, note: note, amp: velocity / 127.0 end Aktualisiere deinen Code und klicke nochmals auf Ausf\u00fchren. Jetzt wird der Anschlagst\u00e4rke des Keyboards ber\u00fccksichtigt. Als n\u00e4chstes lass uns diese nervige Pause loswerden. Latenz entfernen Bevor wir die Pause entfernen k\u00f6nnen, m\u00fcssen wir herausfinden, warum sie da ist. Um alle Synths und Effekte auf einer Vielzahl von unterschiedlich starken CPUs gut getaktet zu halten, setzt Sonic Pi Audio-Ereignisse standardm\u00e4\u00dfig 0,5 Sekunden im Voraus an. (Beachte, dass diese zus\u00e4tzliche Latenz \u00fcber die Funktionen set_sched_ahead_time! und use_sched_ahead_time konfiguriert werden kann). Diese 0,5 Sekunden Latenz werden zu unseren :piano Synth-Triggern hinzugef\u00fcgt, so wie bei allen Synths, die von Sonic Pi getriggert werden. Typischerweise wollen wir diese hinzugef\u00fcgte Latenz, weil sie bedeutet, dass alle Synths gut getaktet laufen werden. Das ergibt jedoch nur Sinn bei Synths, die von Programm-Code durch play und sleep getriggert werden. In diesem Fall triggern wir den :piano -Synth jedoch tats\u00e4chlich mit unserem externen MIDI-Ger\u00e4t und m\u00f6chten daher nicht, dass Sonic Pi das Timing f\u00fcr uns steuert. Wir k\u00f6nnen diese Latenz mit dem Befehl use_real_time ausschalten, der f\u00fcr den aktuellen Thread die Latenz ausschaltet. Das bedeutet, dass du den Echtzeitmodus use_real_time f\u00fcr Live-Loops verwenden kannst, die ihr Timing mittels sync mit externen Ger\u00e4ten synchronisieren, und f\u00fcr alle anderen Live-Loops die normale Latenz behalten kannst. Lass mal sehen: live_loop :midi_piano do use_real_time note, velocity = sync \"/midi:nanokey2_keyboard:0:1/note_on\" synth :piano, note: note, amp: velocity / 127.0 end Passe deinen Code entsprechend dem obigen Code an und klicke nochmals auf Ausf\u00fchren. Jetzt haben wir ein Piano mit niedriger Latenz und variabler Anschlagst\u00e4rke mit nur 5 Zeilen programmiert. Wenn das nicht einfach war! Werte erhalten Schlie\u00dflich, da unsere MIDI-Ereignisse direkt in den Time-State gehen, k\u00f6nnen wir die get -Funktion benutzen, um den letzten gesehenen Wert zu erhalten. Dies blockiert nicht den aktuellen Thread und gibt nil zur\u00fcck, wenn es keinen Wert gibt (was du \u00fcberschreiben kannst, indem du einen Standardwert \u00fcbergibst - sieh dir daf\u00fcr die Dokumentation f\u00fcr get an). Erinnere dich, dass du get in jedem Thread und zu jeder Zeit aufrufen kannst, um den letzten passenden Time-State-Wert zu erhalten. Du kannst sogar time_warp benutzen, um in der Zeit zur\u00fcck zu springen und mit get vergangene Events angezeigt zu bekommen ... Jetzt hast du die Kontrolle Das eigentlich Aufregende ist, dass du dieselben Code-Strukturen verwenden kannst, um mittels sync und get MIDI-Informationen mit jedem beliebigen MIDI-Ger\u00e4t zu synchronisieren und du mit diesen Werten tun kannst, was du willst. Jetzt kannst du entscheiden, was dein MIDI-Ger\u00e4t tun wird! 11.2 MIDI-Ausgabe Zus\u00e4tzlich zum Empfangen von MIDI-Ereignissen k\u00f6nnen wir auch MIDI-Ereignisse aussenden, um externe Hardware-Synths, Keyboards und andere Ger\u00e4te zu triggern und zu steuern. Sonic Pi bietet einen vollst\u00e4ndigen Satz von Funktionen zum Senden verschiedener MIDI-Signale wie z. B: Note an - midi_note_on Note aus - midi_note_off Steuerungs\u00e4nderung - midi_cc Tonh\u00f6hen\u00e4nderung - midi_pitch_bend Taktgeber - midi_clock_tick Es gibt noch eine Menge weiterer MIDI-Signale, die unterst\u00fctzt werden \u2013 sieh dir in der API-Dokumentation alle weiteren Funktionen an, die mit midi_ beginnen. Mit einem MIDI-Ger\u00e4t verbinden Um ein MIDI-Signal an ein externes Ger\u00e4t zu senden, muss es zun\u00e4chst angeschlossen sein. F\u00fcr weitere Details sieh dir den Unterabschnitt 'Anschlie\u00dfen eines MIDI-Controllers' in Abschnitt 11.1 an. Beachte, dass, wenn du dich \u00fcber USB mit einem Ger\u00e4t verbindest, an das du sendest (anstatt zu empfangen) die Prozedur jeweils die gleiche ist. Wenn du jedoch die klassischen DIN-Anschl\u00fcsse verwendest, stelle sicher, dass du es mit dem MIDI-Ausgang deines Computers verbindest. Du solltest dein MIDI-Ger\u00e4t in den Einstellungen sehen. MIDI-Ereignisse senden Die vielen midi_* -Funktionen arbeiten ebenso wie play , sample und synth , indem sie ein Signal zur aktuellen (logischen) Zeit schicken . Um zum Beispiel Aufrufe an die midi_* -Funktionen zu verteilen, musst du sleep in der gleichen Weise benutzen wie du es bei play getan hast. Lass uns das ansehen: midi_note_on :e3, 50 Dies sendet ein MIDI-Note-on-Ereignis an das angeschlossene MIDI-Ger\u00e4t mit Anschlagst\u00e4rke 50. (Beachte, dass Sonic Pi Noten in der Form von :e3 automatisch in ihre entsprechenden MIDI-Nummern konvertiert, wie z. B. 52 in diesem Fall.) Wenn dein MIDI-Ger\u00e4t ein Synthesizer ist, solltest du h\u00f6ren k\u00f6nnen, wie er eine Note spielt. Um dies zu deaktivieren verwende midi_note_off : midi_note_off :e3 Auswahl eines MIDI-Ger\u00e4tes Standardm\u00e4\u00dfig wird Sonic Pi jedes MIDI-Signal an alle angeschlossenen Ger\u00e4te auf allen MIDI-Kan\u00e4len senden. Auf diese Art ist es leicht mit einem einzelnen verbundenen Ger\u00e4t zu arbeiten, ohne zuvor etwas einstellen zu m\u00fcssen. Allerdings kann es sein, dass ein MIDI-Ger\u00e4t MIDI-Kan\u00e4le auf spezielle Art handhabt (m\u00f6glicherweise hat jede Note einen eigenen Kanal) - und au\u00dferdem m\u00f6chtest vielleicht mehr als ein MIDI-Ger\u00e4t zur gleichen Zeit anschlie\u00dfen. Und bei etwas komplizierteren Setups, m\u00f6chtest du wahrscheinlich genauer bestimmen, welches Ger\u00e4t welche(s) Signal(e) erh\u00e4lt, und auf welchem Kanal. Wir k\u00f6nnen festlegen an welches Ger\u00e4t wir senden, indem wir die port: -Option verwenden, in der wir den Ger\u00e4tenamen verwenden, wie er in den Einstellungen angezeigt wird: midi_note_on :e3, port: \"moog_minitaur\" Wir k\u00f6nnen ebenfalls angeben, an welchen Kanal gesendet werden soll, indem wir die Option channel: (mit einem Wert im Bereich 1-16) verwenden: midi_note_on :e3, channel: 3 Nat\u00fcrlich k\u00f6nnen wir auch beides zugleich festlegen, um an ein bestimmtes Ger\u00e4t auf einen bestimmten Kanal zu senden: midi_note_on :e3, port: \"moog_minitaur\", channel: 5 MIDI-Studio Und schlie\u00dflich ist es eine wirklich spannende Sache, den Audio-Ausgang deines MIDI-Synthesizers mit einem der Audio-Eing\u00e4nge deiner Soundkarte zu verbinden. So kannst du deinen Synthesizer mit den midi_* Funktionen steuern und gleichzeitig die erzeugten Kl\u00e4nge mit live_audio und Effekten ver\u00e4ndern: with_fx :reverb, room: 1 do live_audio :moog end live_loop :moog_trigger do midi (octs :e1, 3).tick, sustain: 0.1 sleep 0.125 end (Die midi -Funktion ist eine handliche Kurzform, um note on - und note off -Ereignisse mit einem einzigen Befehl zu senden. F\u00fcr weitere Informationen wirf einen Blick in ihre Dokumentation). 12 OSC Es gibt neben MIDI in Sonic Pi noch einen Weg \u00fcber das Netzwerk ein- und ausgehende Informationen zu \u00fcbertragen - das ist OSC - Open-Sound-Control, ein einfaches Netzwerkprotokoll. Es l\u00e4sst dich Signale mit externen Programme austauschen (mit Programmen sowohl auf deinem wie auch auf externen Computern) und erweitert damit die M\u00f6glichkeiten zur Steuerung weit \u00fcber MIDI hinaus, welches durch sein Design aus den 80ern bestimmten Einschr\u00e4nkungen unterliegt. Zum Beispiel k\u00f6nntest du ein Programm in einer anderen Programmiersprache schreiben, welches OSC-Signale sendet und empf\u00e4ngt (es gibt OSC-Bibliotheken f\u00fcr so ziemlich alle gebr\u00e4uchlichen Programmiersprachen) - und direkt mit Sonic Pi zusammenarbeitet. Wof\u00fcr du das einsetzen kannst, wird nur durch deine Vorstellungskraft begrenzt. 12.1 OSC empfangen Standardm\u00e4\u00dfig lauscht Sonic Pi wenn es gestartet wird an Port 4560 auf eingehende OSC-Signale von Programmen auf demselben Computer. Das bedeutet, dass du ohne weitere Konfiguration Sonic Pi ein OSC-Signal senden kannst und dieses im Cue-Protokoll, genauso wie eingehende MIDI-Signale, angezeigt wird. Das hei\u00dft auch, jedes eingehende OSC-Signal wird automatisch zum Time-State hinzugef\u00fcgt, was bedeutet, dass du get und sync verwenden kannst, um mit den eingehenden Daten zu arbeiten - genauso wie bei MIDI und der Synchronisierung von live_loops - sieh in den Abschnitten 5.7 und 10.2 nach, um zu rekapitulieren, wie das funktioniert. Ein einfacher OSC-Empf\u00e4nger Lass uns einen einfachen OSC-Empf\u00e4nger bauen: live_loop :foo do use_real_time a, b, c = sync \"/osc*/trigger/prophet\" synth :prophet, note: a, cutoff: b, sustain: c end In diesem Beispiel geben wir einen OSC-Pfad an, mit dem wir uns synchronisieren, \"/osc*/trigger/prophet\" . Dies kann ein beliebiger g\u00fcltiger OSC-Pfad sein (alle Buchstaben und Zahlen sind erlaubt, das / wird wie in einer URL verwendet um W\u00f6rter zu trennen). Das Pr\u00e4fix /osc wird von Sonic Pi allen eingehenden OSC-Signalen vorangestellt, also m\u00fcssen wir eine OSC-Signal mit dem Pfad /trigger/prophet senden, damit der sync -Befehl beendet und der prophet-Synth getriggert wird. OSC an Sonic Pi senden Wir k\u00f6nnen OSC von jeder beliebigen Programmsprache, die eine Bibliothek f\u00fcr OSC bietet, aus an Sonic Pi senden. Wenn wir zum Beispiel OSC von Python aus senden, machen wir vielleicht so etwas: from pythonosc import osc_message_builder from pythonosc import udp_client sender = udp_client.SimpleUDPClient('127.0.0.1', 4560) sender.send_message('/trigger/prophet', [70, 100, 8]) Oder wenn wir OSC aus Clojure senden, machen wir vielleicht etwas wie dies aus dem REPL: (use 'overtone.core) (def c (osc-client \"127.0.0.1\" 4560)) (osc-send c \"/trigger/prophet\" 70 100 8) Von externen Computern empfangen Aus Sicherheitsgr\u00fcnden empf\u00e4ngt Sonic Pi standardm\u00e4\u00dfig keine OSC Nachrichten von externen Computern. Du kannst jedoch Unterst\u00fctzung f\u00fcr externe Ger\u00e4te unter Einstellungen->I/O->Netzwerk->Empfange OSC von externen Computern einschalten. Du kannst anschlie\u00dfend OSC-Signale beliebigen Computern in deinem Netzwerk empfangen. Das sendende Ger\u00e4t muss daf\u00fcr deine IP-Adresse kennen (eine eindeutige Bezeichnung deines Computers in deinem Netzwerk - ganz so wie eine Telefonnummer oder Email-Adresse). Du kannst die IP-Adresse deines Computers herausfinden, indem du in Einstellungen im Abschnitt I/O nachsiehst. (Falls dein Computer mehrere IP-Adressen haben sollte, kannst du die alle bekannten Adressen anzeigen lassen, indem du den Mauszeiger \u00fcber der angezeigten Adresse schweben l\u00e4sst). Beachte, dass manche Programme, wie z. B. TouchOSC f\u00fcr iPhone und Android, das Senden von OSC-Signalen von Haus aus unterst\u00fctzen. Also kannst du, sobald du auf OSC-Signale von externen Ger\u00e4ten lauscht und du deine IP-Adresse kennst, anfangen OSC-Signale von Apps wie TouchOSC zu senden und deine eigenen Steuerungen mit Slidern, Schaltfl\u00e4chen, Drehkn\u00f6pfen usw. zu bauen. Das kann dir eine enorme Bandbreite an Eingabem\u00f6glichkeiten erschlie\u00dfen. 12.2 OSC senden So wie wir OSC empfangen und mittels Time-State verarbeiten, k\u00f6nnen wir auch OSC senden (ganz so wie wir MIDI-Signale im Takt unserer Musik senden k\u00f6nnen). Wir m\u00fcssen nur wissen an welche IP-Adresse und welchen Port wir senden. Lass uns das ausprobieren: use_osc \"localhost\", 4560 osc \"/hello/world\" Wenn du den Code von oben ausf\u00fchrst, wird dir auffallen, dass Sonic Pi ein OSC-Signal an sich selbst sendet! Das kommt daher, dass wir als IP-Adresse und Port auf den Standard-OSC-Port von Sonic Pi gesetzt haben. Das ist im Grunde so, als w\u00fcrdest du einen Brief an dich selbst schreiben - das OSC-Paket wird erzeugt, verl\u00e4sst Sonic Pi, landet auf dem Netzwerkstapel deines Betriebssystems, das es dann zur\u00fcck an Sonic Pi schickt, mit dem im Protokoll sichtbaren Standard-OSC-Signal /osc:127.0.0.1:4560/hello/world . (Beachte wie Sonic Pi automatisch das Prefix /osc f\u00fcr alle eingehenden Nachrichten setzt.) OSC an andere Programme senden Nat\u00fcrlich kann es lustig sein OSC-Signale an uns selbst zu senden, hilfreich ist es aber nicht. Den echten Nutzen erkennen wir dann, wenn wir Nachrichten an andere Programme senden: use_osc \"localhost\", 123456 osc \"/hello/world\" In diesem Beispiel gehen wir davon aus, dass ein Programm auf dem selben Computer an Port 123456 lauscht. Falls dies der Fall ist, wird es ein OSC-Signal mit dem Inhalt \"/hello/world\" erhalten, welches es dann verarbeiten kann. Wenn dein Programm auf einer anderen Maschine l\u00e4uft, m\u00fcssen wir deren IP-Adresse kennen, welche wir anstelle von \"localhost\" verwenden: use_osc \"192.168.10.23\", 123456 osc \"/hello/world\" Nun k\u00f6nnen wir OSC-Signale zu jedem erreichbaren Ger\u00e4t senden, \u00fcber das lokale Netzwerk und sogar auch \u00fcber das Internet! 13 Multikanal-Audio In Sachen Klangproduktion haben wir bis jetzt das Triggern von Synths und aufgenommenen Kl\u00e4ngen \u00fcber die Funktionen play , synth und sample erkundet. Diese haben dann h\u00f6rbare T\u00f6ne erzeugt, die \u00fcber unser Stereo-Lautsprecher-System abgespielt wurden. Viele Computer verf\u00fcgen jedoch auch \u00fcber die F\u00e4higkeit Kl\u00e4nge einzuspielen, \u00fcber ein Mikrofon zum Beispiel, und zus\u00e4tzlich auch \u00fcber mehr als zwei Ausg\u00e4nge auszuspielen. Oft wird diese F\u00e4higkeit durch die Verwendung eines externen Audio-Interface m\u00f6glich gemacht - es gibt sie f\u00fcr alle Plattformen. In diesem Abschnitt der Tutorials sehen wir uns an, wie wir ein solches externes Audio-Interface nutzen und damit m\u00fchelos mit mehreren Kan\u00e4len Audio auf Ein- und -Ausg\u00e4ngen in Sonic Pi arbeiten k\u00f6nnen. 13.1 Sound-In Ein einfacher (und vielleicht schon bekannter) Weg um in Sonic Pi Audio-Eing\u00e4nge zu verwenden ist mit Hilfe unseres Freundes synth bzw. der :sound_in -Funktion: synth :sound_in Dieser Synth wird genauso funktionieren wie jeder andere Synth, beispielsweise synth:dsaw , mit der Ausnahme dass das eingehende Audio-Signal direkt vom ersten Eingang deiner System-Sound-Karte gelesen wird. Auf Laptops ist dies normalerweise das eingebaute Mikrofon, falls du aber ein externes Audio-Interface verwendest, kannst du auch jedes andere Audio-Signal an den ersten Eingang anschlie\u00dfen. Erh\u00f6hung der Dauer Eine Sache die dir sicher auffallen wird, ist, dass genauso wie synth:dsaw der :sound_in -Synth nur f\u00fcr einen Beat lang h\u00f6rbar ist, da er die Standard-H\u00fcllkurve verwendet. Falls du ihn f\u00fcr etwas l\u00e4nger offen halten m\u00f6chtest, kannst du die Einstellungen der ADSR-H\u00fcllkurve \u00e4ndern. Im folgenden Beispiel wird der Synth f\u00fcr 8 Schl\u00e4ge h\u00f6rbar sein, bevor die Verbindung geschlossen wird: synth :sound_in, sustain: 8 Effekte hinzuf\u00fcgen Nat\u00fcrlich kannst du, genau wie bei jedem normalen Synth auch, mit dem FX block einfach Effekte anwenden: with_fx :reverb do with_fx :distortion do synth :sound_in, sustain: 8 end end Falls du nun eine Gitarre an den ersten Eingang angeschlossen hast, solltest du sie jetzt mit einer Verzerrung und Hall h\u00f6ren k\u00f6nnen, bis der Synth erwartungsgem\u00e4\u00df endet. Du kannst den :sound_in -Synth so viele Male gleichzeitig einsetzen, wie du m\u00f6chtest (genauso wie du es mit jedem anderen Synth machen w\u00fcrdest). Zum Beispiel werden im Folgenden zwei :sound_in -Synths gleichzeitig gespielt - einer mit Verzerrung der andere mit Hall: with_fx :distortion do synth :sound_in, sustain: 8 end with_fx :reverb do synth :sound_in, sustain: 8 end Mehrere Eing\u00e4nge Du kannst \u00fcber die input: -Option jeweils ausw\u00e4hlen \u00fcber welchem Audio-Eingang du spielen willst. Du kannst au\u00dferdem mit :sound_in_stereo -Synth auch einen Stereo-Eingang (zwei aufeinander folgende Eing\u00e4nge) bestimmen. Mit dem folgenden Beispiel k\u00f6nntest du, wenn du \u00fcber eine Sound-Karte mit mindestens drei Eing\u00e4ngen verf\u00fcgst, die ersten beiden als Stereo-Signal behandeln und Verzerrung hinzuf\u00fcgen, und den dritten als Mono-Signal behandeln und Hall hinzuf\u00fcgen: with_fx :distortion do synth :sound_in_stereo, sustain: 8, input: 1 end with_fx :reverb do synth :sound_in, sustain: 8, input: 3 end M\u00f6gliche Probleme Obwohl dies eine n\u00fctzliche Technik darstellt, gibt es doch einige Beschr\u00e4nkungen bei diesem Ansatz. Zun\u00e4chst funktioniert sie nur \u00fcber eine festgelegte Dauer (da sie an eine ADSR-H\u00fcllkurve gebunden ist), und des weiteren gibt es keine M\u00f6glichkeit, die Effekte umzuschalten, sobald der Synth getriggert wurde. Beides sind typische Anforderungen, wenn wir mit externen Audio-Signalen wie Mikrophonen, Gitarren und externen Synthesizern arbeiten. Wir werden uns daher mit Sonic Pis L\u00f6sung zu dem Problem besch\u00e4ftigen, mit einem (potentiell) unendlichen Audio-Signal an einem Audio-Eingang zu arbeiten: live_audio . 13.2 Live-Audio Der :sound_in -Synth wie er im vorherigen Abschnitt beschrieben wurde, stellt eine sehr flexible und g\u00e4ngige Methode dar, um mit Audio-Eingangssignalen zu arbeiten. Allerdings gibt es, wie beschrieben, Beschr\u00e4nkungen bei der Behandlung einzelner Audio-Signalen als ein einzelnes Instrument (wie z. B. Stimme oder Gitarre). Mit Abstand der beste Ansatz f\u00fcr die Arbeit mit einem einzelnen anhaltenden Audio-Signal ist live_audio zu nutzen. Ein benannter Audio-Eingang live_audio teilt einige der zentralen Design-Beschr\u00e4nkungen mit live_loop (daher der \u00e4hnliche Name). Erstens muss es einen eindeutigen Namen haben, und zweitens darf es zu jedem Zeitpunkt immer nur einen live_audio -Stream mit diesem Namen geben. Lass uns das mal ansehen: live_audio :foo Dieser Code wird sich \u00e4hnlich verhalten wie synth :sound_in , mit einigen wesentlichen Unterschieden: er l\u00e4uft ununterbrochen (bis du ihn ausdr\u00fccklich stoppst), und du kannst ihn dynamisch in neue Effekt-Bl\u00f6cke schieben . Mit Effekten arbeiten Beim ersten Trigger verh\u00e4lt sich live_audio exakt so, wie du es bei der Arbeit mit Effekten erwarten w\u00fcrdest. Zum Beispiel, um einen Live-Audio-Stream mit hinzugef\u00fcgtem Hall zu starten, verwende einfach einen :reverb -Effekt-Block: with_fx :reverb do live_audio :foo end Wie auch immer, angenommen dass live_audio f\u00fcr immer l\u00e4uft (zumindest bis du es stoppst), w\u00e4re es doch sehr beschr\u00e4nkend wenn, wie mit den anderen Synths, Live-Audio f\u00fcr seine gesamte Dauer an den Effekt-Block gebunden bliebe. Gl\u00fccklicherweise ist das nicht der Fall, und Live-Audio wurde so entworfen, dass es einfach zwischen verschiedenen Effekten bewegt werden kann. Lass uns das versuchen. Lass den obigen Code laufen, um \u00fcber Live-Audio direkt das Signal zu h\u00f6ren, das am ersten Eingang deiner Sound-Karte anliegt. Beachte: Wenn du ein Laptop benutzt, wird dies standardm\u00e4\u00dfig das eingebaute Mikrophon sein - es ist also empfehlenswert Kopfh\u00f6rer zu verwenden, um Feedback zu vermeiden. Nun, w\u00e4hrend du noch den Ton live von deiner Sound-Karte mit Hall h\u00f6rst, \u00e4ndere den Code in Folgendes: with_fx :echo do live_audio :foo end Nun klicke Ausf\u00fchren, und sofort wirst du den Sound mit dem Echo-Effekt h\u00f6ren und nicht mehr mit Hall. Wenn du beide h\u00f6ren willst, \u00e4ndere einfach wieder den Code und klicke Ausf\u00fchren: with_fx :reverb do with_fx :echo do live_audio :foo end end Es ist wichtig darauf hinzuweisen, dass du live_audio :foo aus jedem Thread oder Live-Loop heraus aufrufen kannst, und es wird den Live-Audio-Synth in den Effekt-Kontext dieses Threads verschieben. Du k\u00f6nntest also leicht mehrere Live-Loops haben, die live_audio :foo automatisch zu unterschiedlichen Zeiten in unterschiedlichen Effekt-Kontexten aufrufen, was zu interessanten Ergebnissen f\u00fchren kann. Live-Audio stoppen Da Live-Audio anders als andere Synths keine H\u00fcllkurve hat, wird es f\u00fcr immer weiterlaufen (sogar wenn du den Code l\u00f6scht, genau wie bei einer Funktion, ist es immer noch im Speicher definiert, wenn du den Code im Editor l\u00f6scht). Um es anzuhalten, musst du das :stop -Argument anwenden: live_audio :foo, :stop Es kann einfach neu gestartet werden, indem du es erneut ohne :stop -Argument ausf\u00fchrst: live_audio :foo Au\u00dferdem werden alle laufenden Live-Audio-Synths gestoppt, wenn du auf Stopp klickst (genau wie bei allen anderen Synths und Effekten). Stereo-Eingang In Bezug auf die Audio-Kan\u00e4le verh\u00e4lt sich Live-Audio standardm\u00e4\u00dfig wie der :sound_in -Synth, indem er einen einzelnes Mono-Eingangssignal nimmt und in einen Stereo-Stream wandelt, unter Verwendung der eingegebenen Panorama-Einstellung. Allerdings, wie bei :sound_in_stereo besteht auch hier die M\u00f6glichkeit, Live-Audio zwei aufeinander folgende Audio-Eing\u00e4nge lesen zu lassen und sie direkt als linken und rechten Kanal zu behandeln. Dies l\u00e4sst sich durch die :stereo -Option erreichen. Um zum Beispiel Eingang 2 als linkes Signal und Eingang 3 als rechtes Signal zu behandeln, musst du die input: -Option wie folgt auf 2 konfigurieren: live_audio :foo, stereo: true, input: 2 Beachte, dass sobald du einen Audio-Stream in Stereo gestartet hast, du nicht zu Mono wechseln kannst, ohne erneut zu stoppen und zu starten. Ebenso, wenn du ihn im standardm\u00e4\u00dfigen Mono-Modus startest, kannst du nicht zu Stereo wechseln, ohne zu stoppen und zu starten. 13.3 Sound-Out Bisher haben wir in diesem Abschnitt behandelt, wie wir mehrere Audio-Streams in Sonic Pi einbinden k\u00f6nnen - entweder durch den :sound_in -Synth oder \u00fcber das m\u00e4chtige live_audio -System. \u00dcber die Arbeit mit mehreren Audio-Streams aus Eingangssignalen hinaus, kann Sonic Pi ebenso mehrere Audio-Streams als Ausgangssignal ausgeben. Dies wird \u00fcber den :sound_out -Effekt erreicht. Ausgabe-Kontexte Lass uns kurz rekapitulieren, wie Sonic Pis Synths und Effekte ihr Audio-Signal an ihren gegenw\u00e4rtigen Effekt-Kontext \u00fcbergeben. Stell dir zum Beispiel Folgendes vor: with_fx :reverb do # C with_fx :echo do # B sample :bd_haus # A end end Der einfachste Weg, um zu verstehen, was mit dem Audio-Stream passiert, ist beim innersten Audio-Kontext zu starten und uns langsam den Weg nach drau\u00dfen entlang zu arbeiten. In diesem Fall ist der innerste Kontext mit A bezeichnet und ist das :bd_haus -Sample, das getriggert wird. Der Audio-Stream hiervon geht direkt in den Kontext B , welches der :echo -Effekt ist. Dieser f\u00fcgt Echo dem eingehenden Audio-Stream hinzu und gibt es an seinen Kontext weiter - das ist C - der :reverb -Effekt. Dieser f\u00fcgt dann Hall dem eingehenden Audio-Stream hinzu und gibt ihn an seinen Kontext weiter, welcher die oberste Ebene ist - der linke und rechte Lautsprecher (was in deinem Audio-Interface Ausgang 1 und Ausgang 2 entspricht). Der Klang flie\u00dft nach drau\u00dfen den ganzen Weg hindurch als Stereo-Signal. Sound-Out-Effekte Das oben genannte Verhalten trifft auf alle Synths zu (einschlie\u00dflich live_audio ) und auf den Gro\u00dfteil der Effekte, mit Ausnahme von :sound_out . Der :sound_out -Effekt tut zwei Dinge. Erstens gibt er seinen Audio-Stream wie oben beschrieben an seinen \u00e4u\u00dferen Kontext weiter. Zum Zweiten gibt er ihn auch an einen Ausgang deines Audio-Interface oder deiner Sound-Karte aus. Sehen wir uns das an: with_fx :reverb do # C with_fx :sound_out, output: 3 do # B sample :bd_haus # A end end In diesem Besipiel gibt unser bd_haus -Sample sein Audio an seinen \u00e4u\u00dferen Kontext, welches der :sound_out -Effekt ist. Dieser seinerseits gibt sein Audio an seinen externen Kontext, den :reverb -Effekt weiter (wie erwartet). Allerdings gibt er auch einen Mono-Mix an den Ausgang 3 des Audio-Interface oder der Sound-Karte des Systems. Der Audio-Stream, wie er innerhalb von :sound_out generiert wird hat also zwei Ziele, den :reverb -Effekt und den Audio-Ausgang 3. Mono- und Stereoausgabe Wie wir gesehen haben, gibt der :sound_out -Effekt standardm\u00e4\u00dfig einen Mono-Mix des Stereo-Streams an einen bestimmten Kanal aus, zus\u00e4tzlich dazu, dass er ihn (wie erwartet) an seinen \u00e4u\u00dferen Kontext weiter gibt. Wenn ein Mono-Mix nicht gerade das ist, was du nach drau\u00dfen geben willst, hast du eine Reihe von Optionen. Zum Ersten, bei Verwendung der mode: -Option kannst du w\u00e4hlen nur den linken oder den rechten Kanal des Stereo-Streams an das Audio-Interface auszugeben. Oder du kannst den :sound_out_stereo -Effekt verwenden, um zwei aufeinanderfolgende Ausg\u00e4nge des Audio-Interface zu verwenden. Wirf einen Blick in die Dokumentation der Funktion f\u00fcr weitere Informationen und Beispiele. Direct-Out Wie wir auch gesehen haben, ist es das standardm\u00e4\u00dfige Verhalten von :sound_out und :sound_out_stereo Audio sowohl an ihren \u00e4u\u00dferen Kontext (wie f\u00fcr alle Effekte typisch) als auch an den von dir bestimmten Audio-Ausgang deiner Sound-Karte zu schicken. Trotzdem wirst du gelegentlich vielleicht w\u00fcnschen einen Audio-Stream ausschlie\u00dflich an den Ausgang deiner Sound-Karte zu schicken und nicht an den \u00e4u\u00dferen Kontext (und daher deinen Audio-Stream auch nicht gemischt durch die Standard-Ausg\u00e4nge 1 und 2 geschickt zu bekommen). Das ist m\u00f6glich, indem du die Standard-Effekt-Option amp: benutzt, die den Audio-Stream bearbeitet, nachdem der Effekt den Audio-Stream bearbeitet hat: with_fx :sound_out, output: 3, amp: 0 do # B sample :loop_amen # A end Im obigen Beispiel, wird das :loop_amen -Sample an seinen \u00e4u\u00dferen Kontext geschickt, den :sound_out -Effekt. Dieser sendet einen Mono-Mix and den Sound-Karten-Ausgang 3 und multipliziert danach den Audio-Stream mit 0, was diesen essentiell stumm schaltet. Dieses stummgeschaltete Signal wird anschlie\u00dfend an den \u00e4u\u00dferen Kontext des :sound_out -Effektes geschickt, welches der Standard-Ausgang ist. Daher werden bei diesem Code die Standard-Ausgangskan\u00e4le kein h\u00f6rbares Signal erhalten, und an Ausgang 3 wird ein Mono-Mix des Amen-Drum-Break geschickt. Abschlie\u00dfendes Dieser Abschnitt beschlie\u00dft das einf\u00fchrende Tutorial zu Sonic Pi. Hoffentlich konntest du auf dem Weg ein paar Dinge lernen. Mach dir keine Sorgen, wenn du das Gef\u00fchl hast, nicht alles verstanden zu haben - spiele einfach weiter, hab Spa\u00df dabei, und du wirst alles weitere auf deinem Weg, in deinem eigenen Tempo entdecken. Tauche einfach wieder ein, wenn du das Gef\u00fchl hast , dass eine Frage in einem der Abschnitte des Tutorials beantwortet werden k\u00f6nnte. Wenn du Fragen hast, die nicht in diesem Tutorial behandelt wurden, dann komme damit bitte im Sonic Pi Forum vorbei und stelle deine Frage dort. Du wirst dort Leute treffen, die freundlich sind und dir gerne weiterhelfen. Und abschlie\u00dfend lade ich dich auch dazu ein, dir die \u00fcbrige Dokumentation im Hilfe-System einmal genauer anzuschauen. Es gibt noch eine ganze Reihe von Merkmalen von Sonic Pi, die in diesem Tutorial nicht behandelt wurden und darauf warten, von dir entdeckt zu werden. Also, spiele, hab Spa\u00df, teile deinen Programm-Code, tritt vor deinen Freunden auf, zeige was du auf dem Monitor hast - und vergiss nicht: Es gibt keine Fehler, nur M\u00f6glichkeiten. Sam Aaron A Anhang A - Artikel aus MagPi Anhang A b\u00fcndelt Artikel \u00fcber Sonic Pi, die f\u00fcr das MagPi-Magazin geschrieben wurden. Einstieg in den Stoff Diese Artikel m\u00fcssen nicht in einer bestimmten Reihenfolge gelesen werden, und sie \u00fcberschneiden sich in vielen Punkten mit dem Tutorial. Es geht weniger darum, dir alles \u00fcber Sonic Pi beizubringen - eher fokussieren sie sich jeweils auf einen bestimmten Aspekt von Sonic Pi und behandeln ihn auf unterhaltsame und leicht zug\u00e4ngliche Weise. Lese das MagPi Du kannst die Ausgaben von The MagPi in einem gro\u00dfartigen professionellem Layout als PDFs hier herunterladen: https://www.raspberrypi.org/magpi/ Schlage ein Thema vor Wenn du kein Thema, das dich interessiert, in diesen Artikeln behandelt findest - warum nicht eines vorschlagen? Der einfachste Weg ist ein Tweet mit deinem Vorschlag an @Sonic_Pi . Du kannst nie wissen - dein Vorschlag k\u00f6nnte das Thema des n\u00e4chsten Artikels sein! A.1 Tipps zu Sonic Pi 1. Es gibt keine Fehler Die wichtigste Lektion mit Sonic Pi ist, dass es wirklich keine Fehler gibt. Der beste Weg zu lernen, ist einfach es zu versuchen und zu versuchen und zu versuchen. Probiere viele verschiedene Dinge aus, k\u00fcmmere dich nicht darum, ob dein Programm-Code gut oder schlecht klingt und fange an mit so vielen unterschiedlichen Synths, FXs und Optionen wie m\u00f6glich zu experimentieren. Du wirst viele Dinge entdecken, die dich zum Lachen bringen, weil sie furchtbar klingen und auch richtige Edelsteine, die einfach toll klingen. Lass die Dinge, die dir nicht gefallen einfach beiseite und behalte, was dir gef\u00e4llt. Je mehr 'Fehler' du dir zu machen erlaubst, desto schneller wirst du lernen und deinen eigenen Coding-Sound entdecken. 2. Verwende die Effekte Sagen wir mal, Du beherrschst die Grundlagen, wie man in Sonic Pi Sounds mit sample und play macht. Was jetzt? Hast Du gewusst, dass Sonic Pi \u00fcber 27 Studio-FX unterst\u00fctzt, mit denen Du den Sound deines Codes ver\u00e4ndern kannst? FX sind sowas wie raffinierte Bildeffekte in Bildbearbeitungsprogrammen; nur das sie nicht unscharf oder schwarz/wei\u00df machen, sondern dem Sound Hall, Verzerrung oder Echo hinzuf\u00fcgen. Stell' Dir vor, wie Du das Kabel von Deiner Gitarre ins Effekt-Pedal steckst und dann in den Verst\u00e4rker. Gl\u00fccklicherweise braucht man keine Kabel, und Sonic Pi macht es sehr einfach, FX einzusetzen. Du musst nur ausw\u00e4hlen, auf welchen Teil Deines Codes Du einen FX anwenden willst und diesen Teil mit dem FX-Code umschlie\u00dfen. Sehen wir uns ein Beispiel an: sample :loop_garzul 16.times do sample :bd_haus sleep 0.5 end Wenn Du einen FX auf das :loop_gazul -Sample anwenden m\u00f6chtest, steckst du es einfach in einen with_fx -Block, und zwar so: with_fx :flanger do sample :loop_garzul end 16.times do sample :bd_haus sleep 0.5 end Wenn Du jetzt einen FX zur Bassdrum hinzuf\u00fcgen m\u00f6chtest, dann packe diese auch in ein with_fx ein: with_fx :flanger do sample :loop_garzul end with_fx :echo do 16.times do sample :bd_haus sleep 0.5 end end Denk' dran, Du kannst jeden Code mit einem with_fx umgeben und jeder Sound, der ausgegeben wird, geht durch diesen FX. 3. Parametrisiere Deine Synths Um Deine codierten Kl\u00e4nge so richtig entdecken zu k\u00f6nnen, wirst Du sicher bald wissen wollen, wie Du Synths und FX steuern kannst. Vielleicht m\u00f6chtest Du die Dauer eines Tons ver\u00e4ndern, mehr Hall hinzuf\u00fcgen oder die Zeit zwischen zwei Echos ver\u00e4ndern. Mit optionalen Parametern oder kurz Opts bietet Dir Sonic Pi viele M\u00f6glichkeiten, genau das zu tun. Schauen wir uns das mal kurz an. Kopiere diesen Code in einen Puffer und klicke auf Ausf\u00fchren: sample :guit_em9 Oh, was f\u00fcr ein wunderbarer Gitarren-Sound! Spielen wir ein bisschen damit. Wie w\u00e4re es damit, die Abspielgeschwindigkeit (rate) zu \u00e4ndern? sample :guit_em9, rate: 0.5 Was bedeutet der Schnipsel rate: 0.5 , den ich hier am Ende hinzugef\u00fcgt habe? Das ist ein Parameter. Alle Synths und FX in Sonic Pi unterst\u00fctzen diesen und man kann viel damit anstellen. Versuche mal das hier: with_fx :flanger, feedback: 0.6 do sample :guit_em9 end Jetzt setze das feedback auf 1 und h\u00f6r' Dir die verr\u00fcckten Sounds an! Einzelheiten zu den vielen Opts, die Dir zur Verf\u00fcgung stehen, findest Du in der Dokumentation. 4. Live Code Die beste Art Sonic Pi schnell kennenzulernen, ist, live zu coden. Du f\u00e4ngst mit irgendeinem Codeschnipsel an und ver\u00e4nderst und verbesserst, w\u00e4hrend der Code abgespielt wird. Wenn Du zum Beispiel nicht wei\u00dft, was der Cutoff-Parameter mit einem Sample macht, probiere es einfach aus. Fangen wir mal an! Kopiere diesen Code in einen Puffer von Sonic Pi: live_loop :experiment do sample :loop_amen, cutoff: 70 sleep 1.75 end Jetzt klicke auf ausf\u00fchren und Du wirst einen leicht muffigen Drum-Break h\u00f6ren. \u00c4ndere den cutoff: -Wert auf 80 und klicke wieder ausf\u00fchren. H\u00f6rst Du den Unterschied? Versuche es mit 90 , 100 , 110 ... Wenn Du die live_loop s einmal im Griff hast, willst du nichts mehr anders verwenden. Wann immer ich einen Live-Coding-Gig habe, brauche ich die live_loop wie ein Schlagzeuger seine Sticks. Um mehr \u00fcber Live-Coding zu erfahren, sieh Dir den Abschnitt 9 im Tutorial an. 5. Mit dem Zufall spielen Manchmal mogele ich, indem ich Sonic Pi f\u00fcr mich komponieren lasse. Mit Randomisierung l\u00e4sst sich das gro\u00dfartig hinbekommen; das klingt vielleicht ein wenig kompliziert, ist es aber gar nicht. Sehen wir uns das an. Kopiere diesen Code in einen Puffer: live_loop :rand_surfer do use_synth :dsaw notes = (scale :e2, :minor_pentatonic, num_octaves: 2) 16.times do play notes.choose, release: 0.1, cutoff: rrand(70, 120) sleep 0.125 end end Wenn Du das laufen l\u00e4sst, wirst Du eine regelm\u00e4\u00dfige Reihenfolge von zuf\u00e4lligen T\u00f6nen der Skala :e2 :minor_pentatonic gespielt vom :dsaw -Synth h\u00f6ren. \"Halt mal, das ist doch keine Melodie\", h\u00f6re ich Dich schon sagen. Okay, dies ist der erste Teil des Zaubertricks. Jedes Mal, wenn die live_loop durchgelaufen ist, k\u00f6nnen wir Sonic Pi sagen, es soll die Zufallsfolge an einen bestimmten Punkt zur\u00fccksetzen. Das ist ein bisschen so, als w\u00fcrden wir wie Dr. Who in seiner Zeitmaschine TARDIS an einen bestimmten Ort und zu einer bestimmten Zeit zur\u00fcckkehren. Versuche es mal und schreibe die Zeile use_random_seed 1 in die live_loop : live_loop :rand_surfer do use_random_seed 1 use_synth :dsaw notes = (scale :e2, :minor_pentatonic, num_octaves: 2) 16.times do play notes.choose, release: 0.1, cutoff: rrand(70, 120) sleep 0.125 end end Jedes Mal, wenn die live_loop sich wiederholt, wird der Zufalls-Generator zur\u00fcckgesetzt. Das bedeutet, es werden jedes mal die selben 16 Noten ausgew\u00e4hlt. Hey presto, eine Melodie! Doch jetzt kommt der richtig spannende Teil: \u00c4ndere den Wert von seed von 1 in irgendeine andere Zahl. Sagen wir z.B. 4923 . Wow! Eine andere Melodie! Also nur durch das \u00c4ndern einer Zahl (dem so genannten random seed ), kannst Du jegliche nur vorstellbare melodische Kombinationen erforschen! Na, wenn das nicht die Magie des Codes ist. A.2 Live Coding Die Laserstrahlen schnitten durch die Rauschwaden als der Subwoofer den Bass tief in die K\u00f6rper der Menge pumpte. Die Atmosph\u00e4re war erf\u00fcllt von einem berauschenden Mix aus Synthesizern und Tanzen. Aber irgendetwas stimmte nicht in diesem Nachtklub. \u00dcber der DJ-Kabine leuchtete in bunten Farben futuristischer Text; bewegte sich, tanzte, blinkte. Dies war keine abgefahrene Lichtshow, sondern einfach eine Projektion von Sonic Pi, das auf einem Raspberry Pi lief. Der Insasse der DJ-Kabine drehte keine Platten, nein, er schrieb und bearbeitete Programmcode. Live. Das ist Live-Coding. Es mag sich wie eine weit hergeholte Geschichte aus einem futuristischen Nachtklub anh\u00f6rt, aber Musik auf diese Weise zu programmieren, ist ein wachsender Trend, bekannt als Live-Coding (http://toplap.org). Eine aktuelle Richtung, die diese Art des Musikmachens eingeschlagen hat, ist der Algorave (http://algorave.com) - Veranstaltungen, auf denen K\u00fcnstler wie ich Musik zum Tanzen programmieren. Du musst aber zum Live-Coden nicht in einem Nachtklub sein. Mit Sonic Pi v2.6+ kannst du \u00fcberall loslegen, wohin du deinen Raspberry Pi und ein Paar Kopfh\u00f6rer oder Lautsprecher mitnimmst. Wenn du das Ende dieses Artikels erreicht hast, wirst du bereits deine eigenen Beats programmieren und live bearbeitest. Wohin do von dort weiter gehst, wird einzig von deiner Vorstellungskraft beschr\u00e4nkt. Live-Loop Der Schl\u00fcssel zum 'live-coding' mit Sonic Pi ist das Beherrschen des 'live_loops'. Schauen wir uns einen an: live_loop :beats do sample :bd_haus sleep 0.5 end Ein Live-Loop hat 4 Hauptbestandteile. Der erste ist sein Name. Unser live_loop oben hei\u00dft live_loop . Du kannst frei entscheiden, wie Du Deinen live_loop nennen m\u00f6chtest. Sei kreativ. Ich benutze oft Namen, die dem Publikum etwas \u00fcber die Musik mitteilen, die ich mache. Der zweite Bestandteil ist das Wort do , welches anzeigt, wo der live_loop beginnt. Der dritte ist das Wort end , das markiert, wo der live_loop endet. Schlie\u00dflich gibt es noch den Block innerhalb des live_loop , der beschreibt, was die Schleife wiederholen soll \u2013 das ist der Teil zwischen do und end . In unsrem Fall spielen wir ein Bass-Drum-Sample und warten einen halben Takt. Dies f\u00fchrt zu einem sch\u00f6nen regelm\u00e4\u00dfigen Bass Beat. Auf gehts, kopiere den live_loop in einem leeren Sonic Pi-Puffer und dr\u00fccke auf Ausf\u00fchren. Boom, Boom, Boom!. Zur Laufzeit neu definieren OK, aber was ist nun das besondere an einem live_loop ? Bisher scheint er nur eine \u00fcberbewertete \"Schleife\" zu sein! Nun, das Sch\u00f6ne am live_loop ist, dass du ihn im laufenden Programm neu definieren kannst. Das bedeutet, du kannst \u00e4ndern was er machen soll, w\u00e4hrend er l\u00e4uft. Das ist das Geheimnis hinter Live-Coding mit Sonic Pi. Lass uns das ausprobieren: live_loop :choral_drone do sample :ambi_choir, rate: 0.4 sleep 1 end Klicke auf die Ausf\u00fchren -Schaltfl\u00e4che oder dr\u00fccke Alt-R . Du h\u00f6rst jetzt einen wundersch\u00f6nen Chor-Klang. Nun, w\u00e4hrend dieser noch l\u00e4uft, \u00e4ndere deie Rate von 0.4 auf 0.38 . Klicke erneut Ausf\u00fchren . Wow! Hast du geh\u00f6rt, wie der Chor die Note gewechselt hat? Setze sie wieder auf 0.4 , zur\u00fcck auf den alten Wert. Nun setze ihn runter auf 0.2 , runter bis 0.19 und dann wieder hoch auf 0.4 . Sieh wie du durch das \u00c4ndern nur eines Parameters, im laufenden Programm, die volle Kontrolle \u00fcber die Musik erlangen kannst? Spiele ein bisschen mit den Werten f\u00fcr rate - w\u00e4hle deine eigenen Werte. Probiere negative Zahlen, wirklich kleine Zahlen und gro\u00dfe Zahlen. Viel Spa\u00df! Schlafen ist wichtig Eine der wichtigsten Lektionen \u00fcber 'live_loop's ist, dass sie Pausen brauchen. Betrachte einmal folgenden 'live_loop': live_loop :infinite_impossibilities do sample :ambi_choir end Wenn du versuchst, diese Code auszuf\u00fchren, wirst du bemerken, dass Sonic Pi sich beschwert, dass der live_loop nicht geschlafen hat. Das ist ein Sicherheitssystem! Nimm dir etwas Zeit und denk dar\u00fcber nach, was dieser Code vom Computer verlangt. Genau, der Computer wird gefragt eine unendliche Anzahl an Samples zum Nullzeitpunkt zu spielen. Ohne das Sicherheitssystem wird der arme Computer das probieren und w\u00e4hrenddessen abst\u00fcrzen. Also immer daran denken: Deine live_loop s m\u00fcssen ein sleep beinhalten. T\u00f6ne kombinieren Musik ist voll von Dingen, die zur selben Zeit geschehen. Das Schlagzeug spielt zur selben Zeit wie der Bass, Gesang und die Gitarre\u2026 In der Informatik nennen wir das Nebenl\u00e4ufigkeit (concurrency). Sonic Pi bietet uns eine einfache M\u00f6glichkeit verschiedenste Dinge zur selben Zeit abspielen zu lassen. Benutze einfach mehr als einen live_loop ! live_loop :beats do sample :bd_tek with_fx :echo, phase: 0.125, mix: 0.4 do sample :drum_cymbal_soft, sustain: 0, release: 0.1 sleep 0.5 end end live_loop :bass do use_synth :tb303 synth :tb303, note: :e1, release: 4, cutoff: 120, cutoff_attack: 1 sleep 4 end Hier haben wir zwei live_loop s. Der eine wiederholt schnell Beats, w\u00e4hrend der andere durch langsames Wiederholen einen verr\u00fcckten Bass Sound kreiert. Eines der interessanten Dinge bei der Verwendung von live_loop in mehreren Instanzen ist, dass sie alle jeweils ihre eigene Zeit verwalten. Das bedeutet, dass es wirklich einfach ist, interessante polyrhythmische Strukturen zu erzeugen und sogar mit Phasenverschiebungen \u00e1 la Steve Reich zu spielen. Schau dir das an: # Steve Reich's Piano Phase notes = (ring :E4, :Fs4, :B4, :Cs5, :D5, :Fs4, :E4, :Cs5, :B4, :Fs4, :D5, :Cs5) live_loop :slow do play notes.tick, release: 0.1 sleep 0.3 end live_loop :faster do play notes.tick, release: 0.1 sleep 0.295 end Alles zusammenf\u00fchren Jedes dieser Tutorials werden wir mit einem abschlie\u00dfenden Code-Beispiel beenden, das sich aller zuvor behandelter Ideen bedient. Schau Dir diesen Code genau an und \u00fcberlege Dir, was er tut. Kopiere ihn anschlie\u00dfend in einen neuen Sonic Pi-Puffer, dr\u00fccke auf Start und h\u00f6r Dir an, wie er klingt. \u00c4ndere zum Schluss etwas am Code, indem Du Parameter ver\u00e4nderst oder Dinge auskommentierst. Vielleicht kannst Du das als Ausgangspunkt f\u00fcr eine eigene Performance nutzen. Das Wichtigste ist auf jeden Fall der Spa\u00df dabei. Bis zum n\u00e4chsten Mal \u2026 with_fx :reverb, room: 1 do live_loop :time do synth :prophet, release: 8, note: :e1, cutoff: 90, amp: 3 sleep 8 end end live_loop :machine do sample :loop_garzul, rate: 0.5, finish: 0.25 sample :loop_industrial, beat_stretch: 4, amp: 1 sleep 4 end live_loop :kik do sample :bd_haus, amp: 2 sleep 0.5 end with_fx :echo do live_loop :vortex do # use_random_seed 800 notes = (scale :e3, :minor_pentatonic, num_octaves: 3) 16.times do play notes.choose, release: 0.1, amp: 1.5 sleep 0.125 end end end A.3 Kodierte Beats Eine der spannendsten und einflussreichsten technischen Entwicklungen der modernen Musik ist die Erfindung von Samplern. Sampler sind Musikinstrumente, die es einem erlauben T\u00f6ne aufzunehmen, sie zu ver\u00e4ndern und auf verschiedene Arten und Weisen wiederzugeben. Zum Beispiel ist es mit einem Sampler m\u00f6glich ein Schlagzeug Solo (oder Break) von einer alten Schalplatte einzuspielen und es anschlie\u00dfend als Grundlage f\u00fcr einen neuen Beat zu verwenden, indem man es mit halber Geschwindigkeit wiedergibt. So ist fr\u00fcher Hip-Hop entstanden und heute gibt es kaum noch Elektronische Musik, die ohne irgendeine Art von Samples auskommt. Samples bieten dir eine gro\u00dfartige M\u00f6glichkeit auf einfache Art und Weise neue und interessante Elemente in Deine live gecodete Performance einflie\u00dfen zu lassen. Aber wo kriegen wir einen Sampler her? Wir haben bereits einen - es ist unser Raspberry Pi! Die mitgelieferte Live-Coding App Sonic Pi stellt uns einen m\u00e4chtigen Sampler bereit. Lasst ihn uns ausprobieren! Der Amen Break Eines der klassischen Schlagzeug-Break-Samples mit dem gr\u00f6\u00dften Wiedererkennungswert ist der Amen-Break. Er wurde erstmals 1969 von den Winstons in ihrem Song \"Amen Brother\" als Teil eines Drum-Break aufgenommen. Doch erst seine Wiederentdeckung durch fr\u00fche Hip-Hop-Musiker in den 80ern und sein Einsatz in Samplern f\u00fchrte zu einer Verwendung des Samples in einer gro\u00dfen Bandbreite von Musikstilen, wie Drum and Bass, Breakbeat, Hardcore Techno und Breakcore. Ich bin mir sicher, Du freust Dich zu h\u00f6ren, dass das Sample direkt in Sonic Pi eingebaut ist. Bereite einfach einen Puffer vor und kopiere den folgenden Code hinein: sample :loop_amen Dr\u00fccke auf Start und boom! Du h\u00f6rst dir gerade eines der einflussreichsten Drum Breaks in der Geschichte der Tanzmusik an. Dieses Sample ist allerdings nicht damit ber\u00fchmt geworden, einmal abgespielt zu werden. Vielmehr ist es wie gemacht daf\u00fcr wiederholt zu werden. Beat Stretching Lass uns den Amen Break in Schleife schalten, indem wir unseren alten Bekannten, den live_loop aus dem Tutorial vom letzten Monat, einsetzen: live_loop :amen_break do sample :loop_amen sleep 2 end OK, es wiederholt sich. Allerdings kommt es am Ende eines Durchlaufs zu einer l\u00e4stige Pause. Diese entsteht durch unserer Anweisung 2 Takte zu pausieren. Das :loop_amen Sample dauert bei einem voreingestellten BPM Wert von 60 nur 1.753 Takte. Das bedeutet kommt es am Sample Ende zu einer Pause von 2 - 1.753 = 0.247 Takten, was kurz, aber durchaus wahrnehmbar ist. Um dieses Problem zu beheben, k\u00f6nnen wir die beat_stretch: Option verwenden. Sie sagt Sonic Pi, dass das Sample auf die angegebene Anzahl von Takten ausgedehnt (bzw. gestaucht) werden soll. Sonic Pis Funktionen sample und synth geben uns \u00fcber optionale Parameter wie amp: , cutoff: und release: viele zus\u00e4tzliche Steuerungsm\u00f6glichkeiten. Da die Bezeichnung optionale Parameter allerdings recht lang ist, werden wir sie ab jetzt einfach opts nennen. live_loop :amen_break do sample :loop_amen, beat_stretch: 2 sleep 2 end Jetzt schwingen wir das Tanzbein! Vielleicht wollen wir es noch etwas schneller, oder doch einen Ton gem\u00e4chlicher - je nach Stimmung. Mit der Zeit spielen OK, wie sieht es aus, wenn wir den Stiel unserer Musik zu Hip Hop oder Breakcore \u00e4ndern wollen? Eine einfache M\u00f6glichkeit das zu tun ist mit der Zeit zu spielen - oder in anderen Worten am Tempo herumbasteln. In Sonic Pi ist das super leicht - f\u00fcge einfach use_bpm in deinen Live-Loop ein: live_loop :amen_break do use_bpm 30 sample :loop_amen, beat_stretch: 2 sleep 2 end W\u00e4hrend du gerade zu diesen langsamen Beats rappst, beobachte, dass obwohl wir immer noch eine Pause von 2 machen und unsere BPM bei 30 liegen nichts verz\u00f6gert klingt. Die beat_stretch Option ber\u00fccksichtigt den aktuellen BPM Wert und bringt alles in Einklang. Jetzt kommen wir zum spannenden Teil. W\u00e4hrend der Loop l\u00e4uft, ver\u00e4ndere den Wert 30 in der use_bpm 30 Zeile zu 50 . Wuhuu, auf einmal ist alles ohne aus dem Einklang zu geraten schneller geworden! Versuch das Tempo noch etwas mehr zu erh\u00f6hen - 80, 120 und um es wirklich verr\u00fcckt klingen zu lassen, trage 200 ein! Filtern Nun k\u00f6nnen wir Samples in unseren Live-Loop integrieren. Schauen wir uns einige der interessanten Optionen des sample Synths an. Zun\u00e4chst cutoff: , das den Cut-Off-Filter des Samplers steuert. Standardm\u00e4\u00dfig ist dieser ausgeschaltet. Aber du kannst ihn ganz einfach einschalten: live_loop :amen_break do use_bpm 50 sample :loop_amen, beat_stretch: 2, cutoff: 70 sleep 2 end Nun, \u00e4ndere den Wert der cutoff: Option. Erh\u00f6he ihn zum Beispiel auf 100, dr\u00fccke auf Start und warte bis der Loop einmal durchgelaufen ist, um die \u00c4nderung zu h\u00f6ren. Du kannst beobachten, dass niedrige Werte wie 50 den Klang voll und basslastig machen, hohe Werte wie 100 und 200 aber voll und kratzend klingen. Das liegt daran, dass die cutoff: Option die H\u00f6hen wegschneidet - genau so wie ein Rasenm\u00e4her die Enden von Grashalmen abschneidet. Die cutoff: fungiert als eine L\u00e4ngeneinstellung. Sie legt fest, wie viel Grass nach dem M\u00e4hen \u00fcbrig bleibt. Slicing Ein anderes tolles Tool, das wir ausprobieren k\u00f6nnen, ist der FX Slicer. Er st\u00fcckelt unseren Sound in Einzelsequenzen. Verpacke die sample Zeile daf\u00fcr einfach mit dem folgenden FX Code: live_loop :amen_break do use_bpm 50 with_fx :slicer, phase: 0.25, wave: 0, mix: 1 do sample :loop_amen, beat_stretch: 2, cutoff: 100 end sleep 2 end Beobachte, wie der Klang dadurch etwas mehr auf und ab federt. (Du kannst dir den urspr\u00fcnglichen Klang ohne FX anh\u00f6ren, indem du die Option mix: auf 0 setzt.) Als n\u00e4chstes, versuche dich an der phase: Option. Das ist die Rate (in Beats) in der gest\u00fcckelt wird. Ein kleiner Wert wie 0.125 st\u00fcckelt h\u00e4ufig, hohe Werte wie 0.5 st\u00fcckeln hingegen langsamer. Beobachte, dass eine stufenweises Halbieren oder Vierteln der phase: tendenziell immer gut klingt. Setzte zuletzt die wave: Option auf 0, 1, oder 2 und h\u00f6re dir an, wie die \u00c4nderung klingt. Die Werte stehen f\u00fcr unterschiedliche Schwingungsformen. 0 repr\u00e4sentiert eine S\u00e4gezahnschwindung (hard in, fade out), 1 eine Rechteckschwingung (hard in, hard out) und 2 eine Dreieckschwingung (hard in, hard out). Alles zusammenf\u00fchren Lass uns f\u00fcr unser letztes Beispiel einem Blick auf die fr\u00fche Drum and Bass Szene in Bristol werfen. Mach dir keinen Sorgen, wenn du nicht genau verstehst, wie das Beispiel funktioniert. F\u00fcge den Code einfach in Sonic Pi ein, klicke auf Ausf\u00fchren und versuche dich am Live-Coden, indem du die Werte der verschiedenen Optionen ver\u00e4nderst. Vergesse nicht deine Kreationen mit anderen zu teilen! Bis zum n\u00e4chsten Mal\u2026 use_bpm 100 live_loop :amen_break do p = [0.125, 0.25, 0.5].choose with_fx :slicer, phase: p, wave: 0, mix: rrand(0.7, 1) do r = [1, 1, 1, -1].choose sample :loop_amen, beat_stretch: 2, rate: r, amp: 2 end sleep 2 end live_loop :bass_drum do sample :bd_haus, cutoff: 70, amp: 1.5 sleep 0.5 end live_loop :landing do bass_line = (knit :e1, 3, [:c1, :c2].choose, 1) with_fx :slicer, phase: [0.25, 0.5].choose, invert_wave: 1, wave: 0 do s = synth :square, note: bass_line.tick, sustain: 4, cutoff: 60 control s, cutoff_slide: 4, cutoff: 120 end sleep 4 end A.4 Synth Riffs Ob polterndere Oszillatoren oder die verstimmten Kl\u00e4nge von S\u00e4gezahnschwingungen, die sich durch ein St\u00fcck ziehen, der Lead Synth - der melodische Hauptpart eines St\u00fccks - spielt in jeder elektronischen Komposition eine wichtige Rolle. Im der letzten Einheit dieses Tutorials haben wir gelernt, wie man Kl\u00e4nge erzeugt. Jetzt werden wir uns damit besch\u00e4ftigen, wie wir die drei Hauptkomponenten eines Synth Riffs - Klangfarbe, Melodie und Rhythmus - coden k\u00f6nnen. OK, fahre deinen Raspberry Pi hoch, \u00f6ffne Sonic Pi v2.6+ und auf gehts, lass und Musik machen! Die Welt der Klangfarben Ein essentieller Teil jeder Synth-Figur ist das Ver\u00e4ndern und Spielen mit der F\u00e4rbung der Kl\u00e4nge. Wir k\u00f6nnen die Klangfarbe in Sonic Pi Sonic Pi auf zwei Arten steuern - indem wir f\u00fcr dramatische \u00c4nderungen verschiedene Synths verwenden, und f\u00fcr dezente Modifizierungen die verschiedenen Synth-Optionen einsetzen. Wir k\u00f6nnen daf\u00fcr auch Effekte einsetzen, aber das ist ein Tutorial f\u00fcr sich \u2026 Lass uns einen einfachen Live-Loop schreiben, in dem wir laufend den Synth \u00e4ndern: live_loop :timbre do use_synth (ring :tb303, :blade, :prophet, :saw, :beep, :tri).tick play :e2, attack: 0, release: 0.5, cutoff: 100 sleep 0.5 end Schau dir den Code genauer an. Mit dem tick Befehl gehen wir Eintrag f\u00fcr Eintrag durch einen Ring von Synth Namen (wobei wir die Liste immer wieder wiederholen). Anschlie\u00dfend \u00fcbergeben wir diesen Synth an die use_synth Funktion, die den aktuellen Synth unseres Live-Loops \u00e4ndert. Au\u00dferdem spielen wir die Note :e2 (e der zweiten Oktave) mit einer Abklingzeit von 0.5 Takten (0.5 Sekunden bei unser Standard-BPM von 60) und einem cutoff: Wert von 100. H\u00f6rst du, wie die unterschiedlichen Synths vollkommen verschiedene Kl\u00e4nge erzeugen, obwohl sie alle die selbe Note spielen? Lass uns damit experimentieren. Erh\u00f6he oder verkleinere den Wert der Abklingzeit. \u00c4ndere zum Beispiel die Werte der Optionen attack: und release: , um zu sehen, wie sich unterschiedliche Fade-In und Fade-Out Zeiten auf den Klang auswirken. Zuletzt kannst du den Wert der cutoff: Option \u00e4ndern, um zu beobachten, wie unterschiedliche Cut-Off-Wert die Klangfarbe beeinflussen (Werte zwischen 60 und 130 sind gut). Probiert mal aus, wie viele verschiedene Kl\u00e4nge du erzeugen kannst, indem du an diesen wenigen Parametern rumschraubst. Wenn dir das gelingt, kannst du im dir im Help System den Eintrag zu Synth anschauen. Hier findest du eine Auflistung aller Synths und der Optionen, die sie bereitstellen. Ein Reich an M\u00f6glichkeiten liegt dir zu F\u00fc\u00dfen. Klangfarbe Klangfarbe (engl. timbre) ist nur ein ausgefallenes Wort f\u00fcr den Klang eines Ger\u00e4usches. Wenn man die selbe Note auf verschiedenen Instrumenten, wie zum Beispiel einer Geige, einer Gitarre oder einem Klavier spielt, so bleibt die Tonh\u00f6he (wie hoch oder niedrig ein Ton ist) immer die selbe. Die Tonqualit\u00e4t hingegen unterscheidet sich. Dieser Unterschied, der einem erlaubt festzustellen, ob es sich um ein Klavier oder eine Gitarre handelt, ist die Klangfarbe. Melodische Komposition Ein anderer wichtiger Aspekt in der Zusammenstellung unseres Leas Synths ist die Wahl der Noten, die gespielt werden sollen. Wenn du bereits eine Idee daf\u00fcr hast, kannst du einfach einen Ring erstellen, der \u00fcber die gew\u00fcnschte Notenfolge iteriert: live_loop :riff do use_synth :prophet riff = (ring :e3, :e3, :r, :g3, :r, :r, :r, :a3) play riff.tick, release: 0.5, cutoff: 80 sleep 0.25 end Hier haben wir unsere Melodie mit Hilfe eines Rings definiert, der sich aus Noten wie :e3 und Pausen - dargestellt durch :r - zusammensetzt. Wir nutzen .tick um \u00fcber die Notenfolge zu iterieren und so einen sich wiederholenden Riff zu erzeugen. Automatische Melodie Es ist nicht leicht einen gut klingenden Riff aus dem Nichts zu zaubern. Statt dessen ist es oft hilfreich sich von Sonic Pi eine Auswahl von zuf\u00e4lligen Riffs ausgeben zu lassen und einen von diesen auszuw\u00e4hlen. Um das zu tun, verbinden wir drei bekannte Konzepte miteinander: Ringe, Randomisierung und Zufallszahlen. Schauen wir uns ein Beispiel an: live_loop :random_riff do use_synth :dsaw use_random_seed 3 notes = (scale :e3, :minor_pentatonic).shuffle play notes.tick, release: 0.25, cutoff: 80 sleep 0.25 end Es gibt ein paar Dinge, die wir uns der Reihe nach ansehen wollen. Zun\u00e4chst legen wir fest, dass wir den Zufallswert 3 verwenden. Was bedeutet das? Nun, das N\u00fctzliche daran ist, dass wir, wenn wir den Seed setzen, vorhersagen k\u00f6nnen, was der n\u00e4chste Zufallswert sein wird - es ist derselbe wie beim letzten Mal, als wir den Seed auf 3 gesetzt haben! Eine weitere n\u00fctzliche Information ist, dass das Mischen eines Notenrings auf dieselbe Weise funktioniert. Im obigen Beispiel fragen wir im Wesentlichen nach dem \"dritten Shuffle\" in der Standardliste der Shuffles - was auch jedes Mal dasselbe ist, da wir den Zufallswert immer auf denselben Wert setzen, kurz bevor wir den Shuffle starten. Schlie\u00dflich gehen wir einfach durch unsere gemischten Noten, um das Riff zu spielen. Jetzt f\u00e4ngt der Spa\u00df erst so richtig an. Wenn wir den Startwert(Seed) f\u00fcr den Zufallsgenerator auf eine andere Zahl, z. B. 3000, \u00e4ndern, erhalten wir eine v\u00f6llig andere Mischung der Noten. So ist es jetzt extrem einfach, neue Melodien zu erforschen. W\u00e4hle einfach die Liste der Noten aus, die du mischen m\u00f6chten (Tonleitern sind ein guter Ausgangspunkt), und w\u00e4hlen Sie dann den Startwert(Seed), mit dem du mischen m\u00f6chten. Wenn uns die Melodie nicht gef\u00e4llt, \u00e4ndern wir einfach einen dieser beiden Punkte und versuchen es erneut. Wiederhole den Vorgang, bis dir gef\u00e4llt was du h\u00f6rst! Pseudo-Randomisierung Die Zufallsgenerierung von Sonic Pi ist nicht wirklich zuf\u00e4llig, sondern wird als Pseudozufall bezeichnet. Stell Dir vor, Du w\u00fcrdest 100 Mal w\u00fcrfeln und das Ergebnis jedes Wurfs auf ein Blatt Papier schreiben. Sonic Pi verf\u00fcgt \u00fcber das \u00c4quivalent dieser Ergebnisliste, die verwendet wird, wenn man nach einem Zufallswert fragt. Anstatt zu w\u00fcrfeln, wird einfach der n\u00e4chste Wert auf der Liste ausgew\u00e4hlt. Wenn Du einen Startwert(Seed) setzt, dann springst Du einfach zu einem bestimmten Punkt in dieser Liste. Finde deinen Rythmus Ein weiteres wichtiges Merkmal unseres Riffs ist der Rhythmus, d.h. wann wir eine Note spielen und wann nicht. Wir haben bereits gesehen, dass wir :r nutzen k\u00f6nnen, um Pausen in einen Ring einzuf\u00fcgen. Eine weiter M\u00f6glichkeit auf den Rhythmus Einfluss zu nehmen sind sog. Spreads, \u00fcber die wir in einem kommenden Tutorial mehr lernen werden. Heute nutzen wir Randomisierung, um unseren Rhythmus zu finden. Anstatt immer jede Note in einem Ring zu spielen, k\u00f6nnen wir \u00fcber eine Bedingung festlegen, mit welcher Wahrscheinlichkeit sie abgespielt werden. Lass uns einen Blick darauf werfen: live_loop :random_riff do use_synth :dsaw use_random_seed 30 notes = (scale :e3, :minor_pentatonic).shuffle 16.times do play notes.tick, release: 0.2, cutoff: 90 if one_in(2) sleep 0.125 end end Eine n\u00fctzliche Funktion in diesem Zusammenhang ist die Funktion one_in , die true bzw. false mit einer bestimmten Wahrscheinlichkeit zur\u00fcckgibt. Hier verwenden wir den Wert 2, d.h. one_in gibt durchschnittlich ein Mal alle zwei Aufrufe true zur\u00fcck. Mit anderen Worten, true wird in 50% der F\u00e4lle zur\u00fcckgegeben. H\u00f6here Werte bewirken, dass statt true h\u00e4ufiger false zur\u00fcckgegeben wird. Das f\u00fchrt zu mehr L\u00fccken in unserem Riff. Beobachte, dass wir mit dem Befehl 16.times Wiederholung eingebaut haben. Das haben wir gemacht, damit sich unser Zufallsgenerator (der R\u00fcckgabewert der one_in Funktion) nur alle 16 Noten zur\u00fccksetzt und unser Rhythmus sich so alle 16 Schl\u00e4gen wiederholt. Wir nehmen damit keinen Einfluss auf das durcheinander Mischen, weil letzteres direkt nach dem Initiieren des Zufallsgenerators passiert. Wir k\u00f6nnen \u00fcber die Gr\u00f6\u00dfe der Wiederholungen die L\u00e4nge unseres Riffs ver\u00e4ndern. Versuche mal die Zahl 16 auf 8 oder sogar 4 oder 3 zu \u00e4ndern und schaue dir an, wie sich das auf den Rhythmus des Riffs auswirkt. Alles zusammenf\u00fchren OK, lass uns zum Schluss alles, das wir gelernt haben, in einem abschlie\u00dfenden Beispiel nutzen. Bis zum n\u00e4chsten Mal! live_loop :random_riff do # uncomment to bring in: # synth :blade, note: :e4, release: 4, cutoff: 100, amp: 1.5 use_synth :dsaw use_random_seed 43 notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle.take(8) 8.times do play notes.tick, release: rand(0.5), cutoff: rrand(60, 130) if one_in(2) sleep 0.125 end end live_loop :drums do use_random_seed 500 16.times do sample :bd_haus, rate: 2, cutoff: 110 if rand < 0.35 sleep 0.125 end end live_loop :bd do sample :bd_haus, cutoff: 100, amp: 3 sleep 0.5 end A.5 Acid Bass Wenn man sich die Geschichte der Elektronischen Tanzmusik anschaut, ist es schier unm\u00f6glich den enormen Einfluss, den der winzige Synthesizer Roland TB-303 hatte, zu \u00fcbersehen. Er ist das Geheimnis hinter dem Klang des originalen Acid Bass. Diese klassisch quietschenden und quieksenden Bass Riffe des TB-303 kann man sowohl in der fr\u00fchen Chicago House Szene als auch bei Interpreten moderner Elektronischen Musik wie Plastikman, Squarepusher und Aphex Twin h\u00f6ren. Interessanterweise hatte Roland nie vorgesehen, dass der TB-303 f\u00fcr Tanzmusik zum Einsatz kommt. Er wurde urspr\u00fcnglich als eine \u00dcbungshilfe f\u00fcr Gitarristen entwickelt. Die Firma hatte sich \u00fcberlegt, dass Leute mit Hilfe des Synthesizers Basslinien programmieren w\u00fcrden zu denen sie jammen k\u00f6nnten. Leider gab es damit mehrere Probleme: die Programmierung war etwas zu kompliziert, der Klang glich nicht wirklich einer Bassgitarre, und sie waren teuer in der Anschaffung. Um ihre Verluste zu minimieren, beendete Roland die Produktion nach dem Verkauf von 10.000 Exemplaren. Nach ein paar Jahren des Daseins als Staubf\u00e4nger in den Regalen der Gitarristen wanderten die meisten TB-303s in die Schaufenster von Second-Hand-L\u00e4den. Dort warteten sie auf ihre Wiederentdeckung durch eine neue Generation von Experimentierfreudigen, die anfingen sie auf eine Art und Weise zu nutzten, die Roland nie vorgesehen hatte, um abgefahrene Kl\u00e4nge zu erzeugen. Das war die Geburtsstunde des Acid House. Obwohl es nicht leicht ist sich einen originalen TB-303 zu beschaffen, wirst Du Dich sicher freuen zu h\u00f6ren, dass Du Deinen Raspberry Pi mit Hilfe von Sonic Pi in einen TB-303 verwandeln kannst. Los gehts, wirf Sonic Pi an, kopiere den folgenden Code in einen leeren Puffer und klicke auf Ausf\u00fchren: use_synth :tb303 play :e1 Siehe da! Wir haben einen Acid Bass! Lass uns weiter experimentieren\u2026 Bringe den Bass zum Glucksen Lass uns zun\u00e4chst einen live Arpeggiator bauen. In unserer letzten Tutorialeinheit haben wir gelernt, dass Riffs durch Ringe von Noten, die wir nach einander in einer sich wiederholenden Schleife wiedergeben, repr\u00e4sentiert werden k\u00f6nnen. Lass uns einen Live-Loop schreiben, der das gleiche macht: use_synth :tb303 live_loop :squelch do n = (ring :e1, :e2, :e3).tick play n, release: 0.125, cutoff: 100, res: 0.8, wave: 0 sleep 0.125 end Schaue dir jede Codeziele genau an. In der ersten Zeile setzen wir den Defaultwert der use_synth Funktion auf tb303 . In der zweiten Zeile erstellen wir einen Live-Loop vom Typen :squelch , der sich die ganze Zeit wiederholt. In der dritten Zeile erstellen wir unseren Riff - einen Ring aus Noten (E in den Oktaven 1, 2, und 3), der diese mit Hilfe eines .tick s in Schleife durchl\u00e4uft. Wir definieren n als die aktuelle Note in unserem Riff. Das Gleichheitszeichen hier bedeutet, dass wir den Wert auf der rechten Seite der Bezeichnung auf der linken Seite zuzuweisen. In jedem Durchlauf unseres Loops hat n also ein anderer Wert. Im ersten Durchlauf wird n auf :e1 gesetzt. Im zweiten Durchlauf wird es auf :e2 , gefolgt von :e3 und dann wieder auf :e1 usw. gesetzt. Mit Zeile viert wird der eigentliche :tb303 Synth eingeleitet. Dabei werden einige interessante Optionen mitgegeben: release: , cutoff: , res: and wave: \u00fcber die wir etwas sp\u00e4ter genauer sprechen werden. In Zeile f\u00fcnf machen wir eine Pause - wir geben unserem Live-Loop vor sich alle 0.125 s (oder 8 mal pro Sekunde bei einem BPM von 60) zu wiederholen. Zeile sechs markiert das Ende ( end ) des Live-Loops. Sie teilt Sonic Pi nur mit, wo die zu wiederholende Sequenz zu Ende ist. W\u00e4hrend du dir noch \u00fcberlegst, wie das alles genau funktioniert, tippe den oben stehenden Code ab und klicke auf Ausf\u00fchren. Du solltest den :tb303 lostreten h\u00f6ren. Jetzt legen wir richtig los: lass uns mit dem Live-Coding beginnen. W\u00e4hrend der Loop noch aktiv ist, \u00e4ndere den cutoff: -Wert auf 110 . Dr\u00fccke nun erneut den \u201eAusf\u00fchren\u201c-Knopf. Der Ton sollte sich nun etwas h\u00e4rter und qu\u00e4kiger anh\u00f6ren. \u00c4ndere ihn jetzt auf 120 und dr\u00fccke \u201eAusf\u00fchren\u201c. Jetzt 130 . H\u00f6rst du, wie h\u00f6here Cutoff-Werte den Klang durchdringender und intensiver machen? \u00c4ndere den Wert schlie\u00dflich auf 80 , wenn du dich nach einer Pause sehnst. Wiederhole das Ganze dann so oft wie du willst. Keine Sorge, ich werde immer noch hier sein... Eine weitere Option, mit der es sich zu spielen lohnt, ist res: . Damit wird der Resonanzgrad des Filters eingestellt. Eine hohe Resonanz ist charakteristisch f\u00fcr Acid-Bass-Sounds. Im Moment haben wir res: auf 0.8 eingestellt. Versuche, ihn auf 0.85 , dann 0.9 und schlie\u00dflich 0.95 zu erh\u00f6hen. M\u00f6glicherweise wirst du feststellen, dass ein Cutoff-Wert wie 110 oder h\u00f6her die Unterschiede besser h\u00f6rbar macht. Jetzt mach mal etwas wildes und gib 0.999 ein: h\u00f6rst du den verr\u00fcckten Sound? Bei einer so hohen Aufl\u00f6sung h\u00f6rt man den Cutoff-Filter so stark mitschwingen, dass er anf\u00e4ngt, eigene T\u00f6ne zu erzeugen! \u00c4ndere zum Schluss die wave: Option auf 1 , um einen gro\u00dfen Einfluss auf die Klangfarbe zu nehmen. Dies legt die Art der Schwingungserzeugung fest. Der Standard ist mit 0 eine S\u00e4gezahnschwingung. 1 steht f\u00fcr eine Pulswelle und 2 f\u00fcr eine Dreiecksschwingung. Versuche nat\u00fcrlich auch verschiedene Riffs zu erzeugen, indem du die Noten im Ring \u00e4nderst oder sogar Noten aus Skalen oder Akkorden ausw\u00e4hlst. Viel Spa\u00df mit deinem ersten Acid Bass Synth. Den TB-303 zerlegen Der Aufbau des originalen TB-303 ist eigentlich ganz einfach. Wie man dem folgenden Diagramm entnehmen kann, gibt es nur vier Hauptbestandteile. First is the oscillator wave - the raw ingredients of the sound. In this case we have a square wave. Next there's the oscillator's amplitude envelope which controls the amp of the square wave through time. These are accessed in Sonic Pi by the attack: , decay: , sustain: and release: opts along with their level counterparts. For more information read Section 2.4 'Duration with Envelopes' in the built-in tutorial. We then pass our enveloped square wave through a resonant low pass filter. This chops off the higher frequencies as well as having that nice resonance effect. Now this is where the fun starts. The cutoff value of this filter is also controlled by its own envelope! This means we have amazing control over the timbre of the sound by playing with both of these envelopes. Let's take a look: use_synth :tb303 with_fx :reverb, room: 1 do live_loop :space_scanner do play :e1, cutoff: 100, release: 7, attack: 1, cutoff_attack: 4, cutoff_release: 4 sleep 8 end end F\u00fcr jede Standard-H\u00fcllkurvenoption gibt es eine entsprechende cutoff_ -Option im :tb303 -Synthesizer. Um die cutoff-Anschlagszeit zu \u00e4ndern, k\u00f6nnen wir die Option cutoff_attack: verwenden. Kopiere den Code unten in einen leeren Puffer und dr\u00fccke Run . Du wirst einen verrr\u00fcckten Sound h\u00f6ren, der ein- und auswobbelt. Nun spiel ein bisschen herum. Versuche, die cutoff_attack: -Zeit auf 1 zu \u00e4ndern, dann auf 0.5 . Und jetzt probiere 8 . Beobachte, dass wir, um etwas mehr Stimmung zu erzeugen, alles durch einen :reverb FX schicken - probiere ein paar andere Effekte aus und schaue welche hier gut passen! Alles zusammenf\u00fchren Zum Schluss gibt es ein Beispiel, das ich mit Hilfe der Konzepte aus diesem Tutorial komponiert habe. Kopiere den Code in einen leeren Puffer, h\u00f6re es Dir ein Weile lang an und dann versuche Deine eigenen \u00c4nderungen live zu coden. \u00dcberzeuge Dich davon, was f\u00fcr verr\u00fcckte Kl\u00e4nge Du erzeugen kannst! Bis zum n\u00e4chste Mal \u2026 use_synth :tb303 use_debug false with_fx :reverb, room: 0.8 do live_loop :space_scanner do with_fx :slicer, phase: 0.25, amp: 1.5 do co = (line 70, 130, steps: 8).tick play :e1, cutoff: co, release: 7, attack: 1, cutoff_attack: 4, cutoff_release: 4 sleep 8 end end live_loop :squelch do use_random_seed 3000 16.times do n = (ring :e1, :e2, :e3).tick play n, release: 0.125, cutoff: rrand(70, 130), res: 0.9, wave: 1, amp: 0.8 sleep 0.125 end end end A.6 Musisches Minecraft Minecraft Pi Hallo und willkommen zur\u00fcck! In den zur\u00fcckliegenden Tutorialeinheiten haben wir uns ausschlie\u00dflich auf die musikalischen M\u00f6glichkeiten von Sonic Pi konzentriert (um unseren Raspberry Pi in ein konzertf\u00e4higes Musikinstrument zu verwandeln). Bisher haben wir gelernt wie man: Live-Coded - Kl\u00e4nge live improvisieren, gigantische Beats komponiert, m\u00e4chtige Lead Synths generiert, und den bekannten TB-303 Acid Bass nachbaut. Es gibt noch so viel Dinge zu entdecken (was wir in zuk\u00fcnftigen Ausgaben des Tutorials auch machen werden). Diesen Monat lass uns einen Blick auf etwas werfen, was Sonic Pi kann, das du wahrscheinlich nicht erwartet hast: Minecraft steuern. Hello Minecraft World OK, lass uns loslegen. Fahre deinen Raspberry Pi hoch, werfe Minecraft Pi an und erstelle eine neue Welt. Starte nun Sonic Pi und ver\u00e4ndere die Gr\u00f6\u00dfe deiner Fenster so, dass du sowohl Sonic Pi als auch Minecraft Pi auf deinem Bildschirm sehen kannst. Gib Folgendes in einen leeren Puffer ein: mc_message \"Hello Minecraft from Sonic Pi!\" Dr\u00fccke jetzt auf Ausf\u00fchren. Boom! Deine Nachricht erscheint in Minecraft! Wie einfach war das denn? Lege nun dieses Tutorial kurz beiseite und spiele mit deinen eigenen Nachrichten herum. Viel Spa\u00df! Schall-Teleporter Lass uns ein wenig erkunden. Die \u00fcblichste Option ist Maus und Tastatur zu ergreifen und einfach loszulaufen. Das funktioniert, ist aber langsam und langweilig. Es w\u00e4re doch viel besser, wenn wir eine Art Teleporter h\u00e4tten. Dank Sonic Pi haben wir diesen. Probier dieses: mc_teleport 80, 40, 100 Meine G\u00fcte! Das war ein langer Weg nach oben. Wenn du dich nicht im Flugmodus befunden h\u00e4ttest, w\u00e4rst du den ganzen Weg zur\u00fcck auf den Boden gefallen. Wenn du doppelt auf die Leertaste dr\u00fcckst, um in den Flugmodus zu wechseln und dich wieder zu teleportieren, schwebst du weiterhin an der Stelle, an die du dich teleportiert hast. Aber was bedeuten diese Zahlen? Wir haben drei Zahlen, welche die Koordinaten beschreiben, zu denen wir in der Welt gehen wollen. Jede der Zahlen bekommt einen Namen - x, y und z: x - wie weit links und rechts (80 in unserem Beispiel) y - wie hoch wir sein wollen (40 in unserem Beispiel) z - wie weit vorw\u00e4rts und r\u00fcckw\u00e4rts (100 in unserem Beispiel) Indem wir unterschiedliche Werte f\u00fcr x, y und z w\u00e4hlen, k\u00f6nnen wir uns an jeden Ort der Welt teleportieren. Probiere es aus! W\u00e4hle verschiedene Zahlen aus und schaue, wo du landest. Falls der Bildschirm schwarz wird, hast du dich in den Boden oder in einen Berg teleportiert. W\u00e4hle in diesem Fall einen h\u00f6heren y-Wert um wieder \u00fcber den Boden zu kommen. Erkunde weiter, bis du einen Platz findest, der dir gef\u00e4llt... Using the ideas so far, let's build a Sonic Teleporter which makes a fun teleport sound whilst it whizzes us across the Minecraft world: mc_message \"Preparing to teleport....\" sample :ambi_lunar_land, rate: -1 sleep 1 mc_message \"3\" sleep 1 mc_message \"2\" sleep 1 mc_message \"1\" sleep 1 mc_teleport 90, 20, 10 mc_message \"Whoooosh!\" Magische Bl\u00f6cke Now you've found a nice spot, let's start building. You could do what you're used to and start clicking the mouse furiously to place blocks under the cursor. Or you could use the magic of Sonic Pi. Try this: x, y, z = mc_location mc_set_block :melon, x, y + 5, z Now look up! There's a melon in the sky! Take a moment to look at the code. What did we do? On line one we grabbed the current location of Steve as the variables x, y and z. These correspond to our coordinates described above. We use these coordinates in the fn mc_set_block which will place the block of your choosing at the specified coordinates. In order to make something higher up in the sky we just need to increase the y value which is why we add 5 to it. Let's make a long trail of them: live_loop :melon_trail do x, y, z = mc_location mc_set_block :melon, x, y-1, z sleep 0.125 end Now, jump over to Minecraft, make sure you're in flying-mode (double tap space if not) and fly all around the world. Look behind you to see a pretty trail of melon blocks! See what kind of twisty patterns you can make in the sky. Live Coding Minecraft Those of you that have been following this tutorial over the last few months will probably have your minds blown at this point. The trail of melons is pretty cool, but the most exciting part of the previous example is that you can use live_loop with Minecraft! For those that don't know, live_loop is Sonic Pi's special magic ability that no other programming language has. It lets you run multiple loops at the same time and allows you to change them whilst they run. They are incredibly powerful and amazing fun. I use live_loop s to perform music in nightclubs with Sonic Pi - DJs use discs and I use live_loop s :-) However, today we're going to live code both music and Minecraft. Let's get started. Run the code above and start making your melon trail again. Now, without stopping the code, just simply change :melon to :brick and hit run. Hey presto, you're now making a brick trail. How simple was that! Fancy some music to go with it? Easy. Try this: live_loop :bass_trail do tick x, y, z = mc_location b = (ring :melon, :brick, :glass).look mc_set_block b, x, y -1, z note = (ring :e1, :e2, :e3).look use_synth :tb303 play note, release: 0.1, cutoff: 70 sleep 0.125 end Now, whilst that's playing start changing the code. Change the block types - try :water , :grass or your favourite block type. Also, try changing the cutoff value from 70 to 80 and then up to 100 . Isn't this fun? Alles zusammenf\u00fchren Let's combine everything we've seen so far with a little extra magic. Let's combine our teleportation ability with block placing and music to make a Minecraft Music Video. Don't worry if you don't understand it all, just type it in and have a play by changing some of the values whilst it's running live. Have fun and see you next time... live_loop :note_blocks do mc_message \"This is Sonic Minecraft\" with_fx :reverb do with_fx :echo, phase: 0.125, reps: 32 do tick x = (range 30, 90, step: 0.1).look y = 20 z = -10 mc_teleport x, y, z ns = (scale :e3, :minor_pentatonic) n = ns.shuffle.choose bs = (knit :glass, 3, :sand, 1) b = bs.look synth :beep, note: n, release: 0.1 mc_set_block b, x+20, n-60+y, z+10 mc_set_block b, x+20, n-60+y, z-10 sleep 0.25 end end end live_loop :beats do sample :bd_haus, cutoff: 100 sleep 0.5 end A.7 Bizet Beats After our brief excursion to the fantastic world of coding Minecraft with Sonic Pi last month, let's get musical again. Today we're going to bring a classical operatic dance piece straight into the 21st century using the awesome power of code. Skandal\u00f6s und disruptiv Let's jump into a time machine back to the year 1875. A composer called Bizet had just finished his latest opera Carmen. Unfortunately like many exciting and disruptive new pieces of music people initially didn't like it at all because it was too outrageous and different. Sadly Bizet died ten years before the opera gained huge international success and became one of the most famous and frequently performed operas of all time. In sympathy with this tragedy let's take one of the main themes from Carmen and convert it to a modern format of music that is also too outrageous and different for most people in our time - live coded music! Die Habanera dekodieren Der Versuch die gesamte Oper in diesem Tutorial zu kodieren, w\u00e4re wohl zu viel des Guten, daher werden wir uns auf einen der ber\u00fchmtesten Teile fokussieren - die Basslinie der Habanera: This may look extremely unreadable to you if you haven't yet studied music notation. However, as programmers we see music notation as just another form of code - only it represents instructions to a musician instead of a computer. We therefore need to figure out a way of decoding it. Anmerkungen The notes are arranged from left to right like the words in this magazine but also have different heights. The height on the score represents the pitch of the note. The higher the note on the score, the higher the pitch of the note. In Sonic Pi we already know how to change the pitch of a note - we either use high or low numbers such as play 75 and play 80 or we use the note names: play :E and play :F . Luckily each of the vertical positions of the musical score represents a specific note name. Take a look at this handy look up table: Pausen Music scores are an extremely rich and expressive kind of code capable of communicating many things. It therefore shouldn't come as much of a surprise that musical scores can not only tell you what notes to play but also when not to play notes. In programming this is pretty much equivalent to the idea of nil or null - the absence of a value. In other words not playing a note is like the absence of a note. If you look closely at the score you'll see that it's actually a combination of black dots with lines which represent notes to play and squiggly things which represent the rests. Luckily Sonic Pi has a very handy representation for a rest: :r , so if we run: play :r it actually plays silence! We could also write play :rest , play nil or play false which are all equivalent ways of representing rests. Rhythmus Finally, there's one last thing to learn how to decode in the notation - the timings of the notes. In the original notation you'll see that the notes are connected with thick lines called beams. The second note has two of these beams which means it lasts for a 16th of a beat. The other notes have a single beam which means they last for an 8th of a beat. The rest has two squiggly beams which means it also represents a 16th of the beat. When we attempt to decode and explore new things a very handy trick is to make everything as similar as possible to try and see any relationships or patterns. For example, when we re-write our notation purely in 16ths you can see that our notation just turns into a nice sequence of notes and rests. Re-coding the Habanera Wir sind jetzt in der Lage, um diese Basslinie f\u00fcr Sonic Pie zu \u00fcbersetzen. Lass uns diese Noten kodieren und gut sein lassen: (ring :d, :r, :r, :a, :f5, :r, :a, :r) Lass uns schauen, wie es sich anh\u00f6rt. Stelle es in einen Live-Loop und ticke durch: live_loop :habanera do play (ring :d, :r, :r, :a, :f5, :r, :a, :r).tick sleep 0.25 end Fabulous, that instantly recognisable riff springs to life through your speakers. It took a lot of effort to get here, but it was worth it - high five! Stimmungssynthesizer Now we have the bass line, let's re-create some of the ambience of the operatic scene. One synth to try out is :blade which is a moody 80s style synth lead. Let's try it with the starting note :d passed through a slicer and reverb: live_loop :habanera do use_synth :fm use_transpose -12 play (ring :d, :r, :r, :a, :f5, :r, :a, :r).tick sleep 0.25 end with_fx :reverb do live_loop :space_light do with_fx :slicer, phase: 0.25 do synth :blade, note: :d, release: 8, cutoff: 100, amp: 2 end sleep 8 end end Now, try the other notes in the bass line: :a and :f5 . Remember, you don't need to hit stop, just modify the code whilst the music is playing and hit run again. Also, try different values for the slicer's phase: opt such as 0.5 , 0.75 and 1 . Alles zusammenf\u00fchren Zum Schluss lass uns alle bisherigen Ideen in einen neuen Remix von Habanera kombinieren. Du wirst feststellen, dass ich einen weiteren Teil der Basslinie als Kommentar hinzugef\u00fcgt habe. Wenn Du alles in einen neuen Puffer eingegeben hast, dr\u00fccke Run , um Dir die Komposition anzuh\u00f6ren. Und jetzt, ohne auf Stopp zu dr\u00fccken, entkommentiere die zweite Zeile, indem Du das # -Zeichen entfernst, und dr\u00fccke dann noch einmal Run \u2013 wie fantastisch das ist! Jetzt misch alles wie es Dir gef\u00e4llt \u2013 viel Spa\u00df. use_debug false bizet_bass = (ring :d, :r, :r, :a, :f5, :r, :a, :r) #bizet_bass = (ring :d, :r, :r, :Bb, :g5, :r, :Bb, :r) with_fx :reverb, room: 1, mix: 0.3 do live_loop :bizet do with_fx :slicer, phase: 0.125 do synth :blade, note: :d4, release: 8, cutoff: 100, amp: 1.5 end 16.times do tick play bizet_bass.look, release: 0.1 play bizet_bass.look - 12, release: 0.3 sleep 0.125 end end end live_loop :ind do sample :loop_industrial, beat_stretch: 1, cutoff: 100, rate: 1 sleep 1 end live_loop :drums do sample :bd_haus, cutoff: 110 synth :beep, note: 49, attack: 0, release: 0.1 sleep 0.5 end A.8 Werde ein Minecraft VJ Minecraft Pi Everyone has played Minecraft. You will all have built amazing structures, designed cunning traps and even created elaborate cart lines controlled by redstone switches. How many of you have performed with Minecraft? We bet you didn't know that you could use Minecraft to create amazing visuals just like a professional VJ. If your only way of modifying Minecraft was with the mouse, you'd have a tough time changing things fast enough. Luckily for you your Raspberry Pi comes with a version of Minecraft that can be controlled with code. It also comes with an app called Sonic Pi which makes coding Minecraft not only easy but also incredibly fun. In today's article we'll be showing you some of the tips and tricks that we've used to create performances in night clubs and music venues around the world. Lass uns anfangen \u2026 Erste Schritte Um unsere Grundlagen aufzufrischen, lass uns mit einer einfachen \u00dcbung zum Aufw\u00e4rmen anfangen. \u00d6ffne zun\u00e4chst Deinen Raspberry Pi, dann starte Minecraft und Sonic Pi. Erstelle eine neue Welt in Minecraft, und in Sonic Pi w\u00e4hlst Du einen neuen Puffer, dann schreibe diesen Code: mc_message \"Let's get started...\" Klicke den Run-Button und Du wirst die Meldung im Minecraft-Fenster sehen. Ok, wir k\u00f6nnen nun loslegen, lass uns Spa\u00df haben \u2026 Sandst\u00fcrme When we're using Minecraft to create visuals we try and think about what will both look interesting and also be easy to generate from code. One nice trick is to create a sand storm by dropping sand blocks from the sky. For that all we need are a few basic fns: sleep - um eine Verz\u00f6gerung zwischen Aktionen einzuf\u00fcgen mc_location - um unsere aktuelle Position zu finden mc_set_block - to place sand blocks at a specific location rrand - damit wir Zufallswerte innerhalb eines Bereichs erzeugen k\u00f6nnen live_loop - to allow us to continually make it rain sand If you're unfamiliar with any of the built-in fns such as rrand , just type the word into your buffer, click on it and then hit the keyboard combo Control-i to bring up the built-in documentation. Alternatively you can navigate to the lang tab in the Help system and then look up the fns directly along with all the other exciting things you can do. Lass es uns etwas regnen lassen bevor wir die ganze Kraft des Sturms enth\u00fcllen. Versuche mit dem Wissen das du hast ein paar Sandbl\u00f6ke im Himmel zu erschaffen: x, y, z = mc_location mc_set_block :sand, x, y + 20, z + 5 sleep 2 mc_set_block :sand, x, y + 20, z + 6 sleep 2 mc_set_block :sand, x, y + 20, z + 7 sleep 2 mc_set_block :sand, x, y + 20, z + 8 When you hit Run, you might have to look around a little as the blocks may start falling down behind you depending on which direction you're currently facing. Don't worry, if you missed them just hit Run again for another batch of sand rain - just make sure you're looking the right way! Let's quickly review what's going on here. On the first line we grabbed Steve's location as coordinates with the fn mc_location and placed them into the vars x , y , and z . Then on the next lines we used the mc_set_block fn to place some sand at the same coordinates as Steve but with some modifications. We chose the same x coordinate, a y coordinate 20 blocks higher and then successively larger z coordinates so the sand dropped in a line away from Steve. Why don't you take that code and start playing around with it yourself? Try adding more lines, changing the sleep times, try mixing :sand with :gravel and choose different coordinates. Just experiment and have fun! Live Loops Unleashed OK, it's time to get the storm raging by unleashing the full power of the live_loop - Sonic Pi's magical ability which unleashes the full power of live coding - changing code on-the-fly whilst it's running! live_loop :sand_storm do x, y, z = mc_location xd = rrand(-10, 10) zd = rrand(-10, 10) co = rrand(70, 130) synth :cnoise, attack: 0, release: 0.125, cutoff: co mc_set_block :sand, x + xd, y+20, z+zd sleep 0.125 end What fun! We're looping round pretty quickly (8 times a second) and during each loop we're finding Steve's location like before but then generating 3 random values: xd - Die Abweichung f\u00fcr x. Sie muss zwischen -10 und 10 liegen zd - Die Abweichung f\u00fcr z, auch zwischen -10 und 10 co - ein Cut-Off-Wert f\u00fcr den Tiefpassfilter zwischen 70 und 130 We then use those random values in the fns synth and mc_set_block giving us sand falling in random locations around Steve along with a percussive rain-like sound from the :cnoise synth. For those of you new to live loops - this is where the fun really starts with Sonic Pi. Whilst the code is running and the sand is pouring down, try changing one of the values, perhaps the sleep time to 0.25 or the :sand block type to :gravel . Now hit run again . Hey Presto! Things changed without the code stopping. This is your gateway to performing like a real VJ. Keep practising and changing things around. How different can you make the visuals without stopping the code? Epische Blockmuster Finally, another great way of generating interesting visuals is to generate huge patterned walls to fly towards and close by. For this effect we'll need to move from placing the blocks randomly to placing them in an ordered manner. We can do this by nesting two sets of iteration (hit the Help button and navigate to section 5.2 of the tutorial \"Iteration and Loops\" for more background on iteration). The funny |xd| after the do means that xd will be set for each value of the iteration. So the first time it will be 0, then 1, then 2... etc. By nesting two lots of iteration together like this we can generate all the coordinates for a square. We can then randomly choose block types from a ring of blocks for an interesting effect: x, y, z = mc_location bs = (ring :gold, :diamond, :glass) 10.times do |xd| 10.times do |yd| mc_set_block bs.choose, x + xd, y + yd, z end end Pretty neat. Whilst we're having fun here, try changing bs.choose to bs.tick to move from a random pattern to a more regular one. Try changing the block types and the more adventurous of you might want to try sticking this within a live_loop so that the patterns keep changing automatically. Now, for the VJ finale - change the two 10.times to 100.times and hit Run. Kaboom! A Huge gigantic wall of randomly placed bricks. Imagine how long it would take you to build that manually with your mouse! Double-tap space to enter fly-mode and start swooping by for some great visual effects. Don't stop here though - use your imagination to conjure up some cool ideas and then use the coding power of Sonic Pi to make it real. When you've practised enough dim the lights and put on a VJ show for your friends! A.9 Zuf\u00e4lligkeit Back in episode 4 of this tutorial series we took a brief look at randomisation whilst coding up some sizzling synth riffs. Given that randomisation is such an important part of my live coding DJ sets I thought it would be useful to cover the fundamentals in much greater detail. So, get your lucky hat on and let's surf some random streams! Es gibt keinen Zufall The first thing to learn which might really surprise you when playing with Sonic Pi's randomisation functions is that they're not actually really random. What does this actually mean? Well, let's try a couple of tests. First, imagine a number in your head between 0 and 1. Keep it there and don't tell me. Now let me guess... was it 0.321567 ? No? Bah, I'm clearly no good at this. Let me have another go, but let's ask Sonic Pi to choose a number this time. Fire up Sonic Pi v2.7+ and ask it for a random number but again don't tell me: print rand Now for the reveal... was it 0.75006103515625 ? Yes! Ha, I can see you're a little sceptical. Perhaps it was just a lucky guess. Let's try again. Press the Run button again and see what we get... What? 0.75006103515625 again? This clearly can't be random! You're right, it's not. What's going on here? The fancy computer science word here is determinism. This just means that nothing is by chance and everything is destined to be. Your version of Sonic Pi is destined to always return 0.75006103515625 in the program above. This might sound pretty useless, but let me assure you that it's one of the most powerful parts of Sonic Pi. If you stick at it you'll learn how to rely on the deterministic nature of Sonic Pi's randomisation as a fundamental building block for your compositions and live coded DJ sets. Eine zuf\u00e4llige Melodie When Sonic Pi boots it actually loads into memory a sequence of 441,000 pre-generated random values. When you call a random function such as rand or rrand , this random stream is used to generate your result. Each call to a random function consumes a value from this stream. Therefore the 10th call to a random function will use the 10th value from the stream. Also, every time you press the Run button, the stream is reset for that run. This is why I could predict the result to rand and why the 'random' melody was the same every time. Everybody's version of Sonic Pi uses the exact same random stream which is very important when we start sharing our pieces with each other. Let's use this knowledge to generate a repeatable random melody: 8.times do play rrand_i(50, 95) sleep 0.125 end Tippe dies in einen freien Puffer und dr\u00fccke Run . Du wirst eine Melodie h\u00f6ren, die aus zuf\u00e4lligen Noten zwischen 50 und 95 besteht. Wenn sie beendet ist, dr\u00fccke Run noch einmal, um Dir exakt die gleiche Melodie erneut anzuh\u00f6ren. Praktische Zuf\u00e4lligkeitsfunktionen Sonic Pi comes with a number of useful functions for working with the random stream. Here's a list of some of the most useful: rand - Gibt einfach den n\u00e4chsten Wert des Zufallsparameter zur\u00fcck rrand - Gibt einen Zufallswert innerhalb eines Bereichs zur\u00fcck rrand_i - Gibt eine zuf\u00e4llige ganze Zahl innerhalb eines Bereichs zur\u00fcck one_in - Gibt wahr oder falsch mit der angegebenen Wahrscheinlichkeit zur\u00fcck dice - Imitiert den Wurf eines W\u00fcrfels und gibt einen Wert zwischen 1 und 6 zur\u00fcck choose - W\u00e4hlt einen zuf\u00e4lligen Wert aus einer Liste aus Check out their documentation in the Help system for detailed information and examples. Resetting the Stream Whilst the ability to repeat a sequence of chosen notes is essential to allow you to replay a riff on the dance floor, it might not be exactly the riff you want. Wouldn't it be great if we could try a number of different riffs and choose the one we liked best? This is where the real magic starts. We can manually set the stream with the fn use_random_seed . In Computer Science, a random seed is the starting point from which a new stream of random values can sprout out and blossom. Let's try it: use_random_seed 0 3.times do play rrand_i(50, 95) sleep 0.125 end Great, we get the first three notes of our random melody above: 84 , 83 and 71 . However, we can now change the seed to something else. How about this: use_random_seed 1 3.times do play rrand_i(50, 95) sleep 0.125 end Interesting, we get 83 , 71 and 61 . You might notice that the first two numbers here are the same as the last two numbers before - this isn't a coincidence. Remember that the random stream is just a giant list of 'pre-rolled' values. Using a random seed simply jumps us to a point in that list. Another way of thinking about it is to imagine a huge deck of pre-shuffled cards. Using a random seed is cutting the deck at a particular point. The fabulous part of this is that it's precisely this ability to jump around the random stream which gives us huge power when making music. Let's revisit our random melody of 8 notes with this new stream resetting power, but let's also throw in a live loop so we can experiment live whilst it's playing: live_loop :random_riff do use_random_seed 0 8.times do play rrand_i(50, 95), release: 0.1 sleep 0.125 end end Now, whilst it's still playing, change the seed value from 0 to something else. Try 100 , what about 999 . Try your own values, experiment and play around - see which seed generates the riff you like best. Alles zusammenf\u00fchren This month's tutorial has been quite a technical dive into the workings of Sonic Pi's randomisation functionality. Hopefully it has given you some insight into how it works and how you can start using randomisation in a reliable way to create repeatable patterns within your music. It's important to stress that you can use repeatable randomisation anywhere you want. For example, you can randomise the amplitude of notes, the timing of the rhythm, the amount of reverb, the current synth, the mix of an FX, etc. etc. In the future we'll take a close look at some of these applications, but for now let me leave you with a short example. Type the following into a spare buffer, hit Run, and then start changing the seeds around, hit Run again (whilst it's still playing) and explore the different sounds, rhythms and melodies you can make. When you find a nice one, remember the seed number so you can get back to it. Finally, when you've found a few seeds you like, put on a live coded performance for your friends by simply switching between your favourite seeds to create a full piece. live_loop :random_riff do use_random_seed 10300 use_synth :prophet s = [0.125, 0.25, 0.5].choose 8.times do r = [0.125, 0.25, 1, 2].choose n = (scale :e3, :minor).choose co = rrand(30, 100) play n, release: r, cutoff: co sleep s end end live_loop :drums do use_random_seed 2001 16.times do r = rrand(0.5, 10) sample :drum_bass_hard, rate: r, amp: rand sleep 0.125 end end A.10 Steuerung So far during this series we've focussed on triggering sounds. We've discovered that we can trigger the many synths built into Sonic Pi with play or synth and how to trigger pre-recorded samples with sample . We've also looked at how we can wrap these triggered sounds within studio FX such as reverb and distortion using the with_fx command. Combine this with Sonic Pi's incredibly accurate timing system and you can produce a vast array of sounds, beats and riffs. However, once you've carefully selected a particular sound's options and triggered it, there's no ability to mess with it whilst it's playing right? Wrong! Today you're going to learn something very powerful - how to control running synths. Ein Grundton Lass uns einen sch\u00f6nen einfachen Sound erzeugen. Starte Sonic Pi und gib in einen neuen Puffer Folgendes ein: synth :prophet, note: :e1, release: 8, cutoff: 100 Now press the Run button at the top left to hear a lovely rumbling synth sound. Go ahead, press it again a few times to get a feel for it. OK, done? Let's start controlling it! Synth Nodes A little known feature in Sonic Pi is that the fns play , synth and sample , return something called a SynthNode which represents a running sound. You can capture one of these SynthNode s using a standard variable and then control it at a later point in time. For example, let's change the value of the cutoff: opt after 1 beat: sn = synth :prophet, note: :e1, release: 8, cutoff: 100 sleep 1 control sn, cutoff: 130 Let's look at each line in turn: Firstly we trigger the :prophet synth using the synth fn as normal. However we also capture the result in a variable called sn . We could have called this variable something completely different such as synth_node or jane - the name doesn't matter. However, it's important to choose a name that's meaningful to you for your performances and for people reading your code. I chose sn as it's a nice short mnemonic for synth node. On line 2 we have a standard sleep command. This does nothing special - it just asks the computer to wait for 1 beat before moving onto the next line. Line 3 is where the control fun starts. Here, we use the control fn to tell our running SynthNode to change the cutoff value to 130 . If you hit the Run button, you'll hear the :prophet synth start playing as before, but after 1 beat it will shift to sound a lot brighter. Modulierbare Optionen Most of Sonic Pi's synths and FX opts may be changed after being triggered. However, this isn't the case for all of them. For example, the envelope opts attack: , decay: , sustain: and release: can only be set when triggering the synth. Figuring out which opts can and can't be changed is simple - just head to the documentation for a given synth or FX and then scroll down to the individual option documentation and look for the phrases \"May be changed whilst playing\" or \"Can not be changed once set\". For example, the documentation for the :beep synth's attack: opt makes it clear that it's not possible to change it: Standard: 0 Muss null oder gr\u00f6\u00dfer sein Kann nicht mehr ge\u00e4ndert werden, wenn einmal festgelegt Mit dem aktuellen BPM-Wert skaliert Mehrere \u00c4nderungen Whilst a synth is running you're not limited to changing it only once - you're free to change it as many times as you like. For example, we can turn our :prophet into a mini arpeggiator with the following: notes = (scale :e3, :minor_pentatonic) sn = synth :prophet, note: :e1, release: 8, cutoff: 100 sleep 1 16.times do control sn, note: notes.tick sleep 0.125 end In this snippet of code we just added a couple of extra things. First we defined a new variable called notes which contains the notes we'd like to cycle through (an arpeggiator is just a fancy name for something that cycles through a list of notes in order). Secondly we replaced our single call to control with an iteration calling it 16 times. In each call to control we .tick through our ring of notes which will automatically repeat once we get to the end (thanks to the fabulous power of Sonic Pi's rings). For a bit of variety try replacing .tick with .choose and see if you can hear the difference. Note that we can change multiple opts simultaneously. Try changing the control line to the following and listen for the difference: control sn, note: notes.tick, cutoff: rrand(70, 130) Sliding When we control a SynthNode , it responds exactly on time and instantly changes the value of the opt to the new one as if you'd pressed a button or flicked a switch requesting the change. This can sound rhythmical and percussive - especially if the opt controls an aspect of the timbre such as cutoff: . However, sometimes you don't want the change to happen instantaneously. Instead, you might want to smoothly move from the current value to the new one as if you'd moved a slider or dial. Of course, Sonic Pi can also do this too using the _slide: opts. Each opt that can be modified also has a special corresponding _slide: opt that allows you to specify a slide time. For example, amp: has amp_slide: and cutoff: has cutoff_slide: . These slide opts work slightly differently than all the other opts in that they tell the synth note how to behave next time they are controlled . Let's take a look: sn = synth :prophet, note: :e1, release: 8, cutoff: 70, cutoff_slide: 2 sleep 1 control sn, cutoff: 130 Notice how this example is exactly the same as before except with the addition of cutoff_slide: . This is saying that next time this synth has its cutoff: opt controlled, it will take 2 beats to slide from the current value to the new one. Therefore, when we use control you can hear the cutoff slide from 70 to 130. It creates an interesting dynamic feel to the sound. Now, try changing the cutoff_slide: time to a shorter value such as 0.5 or a longer value such as 4 to see how it changes the sound. Remember, you can slide any of the modifiable opts in exactly this way and each _slide: value can be totally different so you can have the cutoff sliding slowly, the amp sliding fast and the pan sliding somewhere in between if that's what you're looking to create... Alles zusammenf\u00fchren Let's look at a short example which demonstrates the power of controlling synths after they've been triggered. Notice that you can also slide FX just like synths although with a slightly different syntax. Check out section 7.2 of the built-in tutorial for more information on controlling FX. Kopiere den Code in einen freien Puffer und h\u00f6re zu. H\u00f6r an dieser Stelle nicht auf \u2013 spiel mit dem Code herum. \u00c4ndere die Wechselzeiten, \u00e4ndere die Noten, den Synth, die FX und die Pausenzeiten, und probier, etwas ganz Anderes daraus zu machen! live_loop :moon_rise do with_fx :echo, mix: 0, mix_slide: 8 do |fx| control fx, mix: 1 notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle sn = synth :prophet , sustain: 8, note: :e1, cutoff: 70, cutoff_slide: 8 control sn, cutoff: 130 sleep 2 32.times do control sn, note: notes.tick, pan: rrand(-1, 1) sleep 0.125 end end end A.11 Tick Tock Last month in this series we took a deep technical dive into the randomisation system underpinning Sonic Pi. We explored how we can use it to deterministically add new levels of dynamic control over our code. This month we're going to continue our technical dive and turn our attention to Sonic Pi's unique tick system. By the end of this article you'll be ticking your way through rhythms and riffs on your way to being a live coding DJ. Beat Counting When making music we often want to do a different thing depending on which beat it is. Sonic Pi has a special beat counting system called tick to give you precise control over when a beat actually occurs and even supports multiple beats with their own tempos. Lass uns spielen \u2013 um den Beat zu erweitern, m\u00fcssen wir nur tick aufrufen. \u00d6ffne einen neuen Puffer, gib Folgendes ein und dr\u00fccke Run: puts tick #=> 0 This will return the current beat: 0 . Notice that even if you press the Run button a few times it will always return 0 . This is because each run starts a fresh beat counting from 0. However, whilst the run is still active, we can advance the beat as many times as we want: puts tick #=> 0 puts tick #=> 1 puts tick #=> 2 Whenever you see the symbol #=> at the end of a line of code it means that that line will log the text on the right-hand-side. For example, puts foo #=> 0 means the code puts foo prints 0 to the log at that point in the program. Checking the Beat We've seen that tick does two things. It increments (adds one) and returns the current beat. Sometimes we just want to look at the current beat without having to increment it which we can do via look : puts tick #=> 0 puts tick #=> 1 puts look #=> 1 puts look #=> 1 In this code we tick the beat up twice and then call look twice. We'll see the following values in the log: 0 , 1 , 1 , 1 . The first two tick s returned 0 , then 1 as expected, then the two look s just returned the last beat value twice which was 1 . Ringe So now we can advance the beat with tick and check the beat with look . What next? We need something to tick over. Sonic Pi uses rings for representing riffs, melodies and rhythms and the tick system has been specifically designed to work very closely with them. In fact, rings have their own dot version of tick which does two things. Firstly, it acts like a regular tick and increments the beat. Secondly it looks up the ring value using the beat as the index. Let's take a look: puts (ring :a, :b, :c).tick #=> :a .tick is a special dot version of tick which will return the first value of the ring :a . We can grab each of the values in the ring by calling .tick multiple times: puts (ring :a, :b, :c).tick #=> :a puts (ring :a, :b, :c).tick #=> :b puts (ring :a, :b, :c).tick #=> :c puts (ring :a, :b, :c).tick #=> :a puts look #=> 3 Take a look at the log and you'll see :a , :b , :c and then :a again. Notice that look returns 3 . Calls to .tick act just like they are regular calls to tick - they increment the local beat. A Live Loop Arpeggiator The real power comes when you mix tick with rings and live_loop s. When combined we have all the tools we need to both build and understand a simple arpegiator. We need just four things: A ring containing the notes we want to loop over. A means of incrementing and obtaining the beat. The ability to play a note based on the current beat. A loop structure to keep the arpegiator repeating. Diese Konzepte findest du alle in dem folgenden Code: notes = (ring 57, 62, 55, 59, 64) live_loop :arp do use_synth :dpulse play notes.tick, release: 0.2 sleep 0.125 end Let's look at each of these lines. First we define our ring of notes which we'll continually play. We then create a live_loop called :arp which loops round for us. Each time round the live_loop we set our synth to :dpulse and then play the next note in our ring using .tick . Remember that this will increment our beat counter and use the latest beat value as an index into our notes ring. Finally, we wait for an eighth of a beat before looping round again. Mehrere gleichzeitige Beats A really important thing to know is that tick s are local to the live_loop . This means that each live_loop has its own independent beat counter. This is much more powerful than having a global metronome and beat. Let's take a look at this in action: notes = (ring 57, 62, 55, 59, 64) with_fx :reverb do live_loop :arp do use_synth :dpulse play notes.tick + 12, release: 0.1 sleep 0.125 end end live_loop :arp2 do use_synth :dsaw play notes.tick - 12, release: 0.2 sleep 0.75 end Clashing Beats A big cause of confusion with Sonic Pi's tick system is when people want to tick over multiple rings in the same live_loop : use_bpm 300 use_synth :blade live_loop :foo do play (ring :e1, :e2, :e3).tick play (scale :e3, :minor_pentatonic).tick sleep 1 end Even though each live_loop has its own independent beat counter, we're calling .tick twice within the same live_loop . This means that the beat will be incremented twice every time round. This can produce some interesting polyrhythms but is often not what you want. There are two solutions to this problem. One option is to manually call tick at the start of the live_loop and then use .look to look up the current beat in each live_loop . The second solution is to pass a unique name to each call to .tick such as .tick(:foo) . Sonic Pi will then create and track a separate beat counter for each named tick you use. That way you can work with as many beats as you need! See the section on named ticks in 9.4 of the built-in tutorial for more information. Alles zusammenf\u00fchren Let's bring all this knowledge of tick s, ring s and live_loop s together for a final fun example. As usual, don't treat this as a finished piece. Start changing things and play around with it and see what you can turn it into. See you next time... use_bpm 240 notes = (scale :e3, :minor_pentatonic).shuffle live_loop :foo do use_synth :blade with_fx :reverb, reps: 8, room: 1 do tick co = (line 70, 130, steps: 32).tick(:cutoff) play (octs :e3, 3).look, cutoff: co, amp: 2 play notes.look, amp: 4 sleep 1 end end live_loop :bar do tick sample :bd_ada if (spread 1, 4).look use_synth :tb303 co = (line 70, 130, steps: 16).look r = (line 0.1, 0.5, steps: 64).mirror.look play notes.look, release: r, cutoff: co sleep 0.5 end A.12 Sample Slicing Way back in episode 3 of this Sonic Pi series we looked at how to loop, stretch and filter one of the most famous drum breaks of all time - the Amen Break. In this tutorial we're going to take this one step further and learn how to slice it up, shuffle the slices and glue it back together in a completely new order. If that sounds a bit wild to you, don't worry, it will all become clear and you'll soon master a powerful new tool for your live coded sets. Ton als Daten Before we get started let's just take a brief moment to understand how to work with samples. By now, you've all hopefully played with Sonic Pi's powerful sampler. If not, there's no time like the present! Boot up your Raspberry Pi, launch Sonic Pi from the Programming menu, type the following into a fresh buffer and then hit the Run button to hear a pre-recorded drum beat: sample :loop_amen A recording of a sound is simply represented as data - lots of numbers between -1 and 1 which represent the peaks and troughs of the sound wave. If we play those numbers back in order, we get the original sound. However, what's to stop us from playing them back in a different order and creating a new sound? How are samples actually recorded? It's actually pretty simple once you understand the basic physics of sound. When you make a sound - for example by hitting a drum, the noise travels through the air in a similar fashion to how the surface of a lake ripples when you throw a pebble into it. When those ripples reach your ears, your eardrum moves sympathetically and converts those movements into the sound you hear. If we wish to record and play back the sound, we therefore need a way of capturing, storing and reproducing those ripples. One way is to use a microphone which acts like an eardrum and moves back and forth as the sound ripples hit it. The microphone then converts its position into a tiny electric signal which is then measured many times a second. These measurements are then represented as a series of numbers between -1 and 1. If we were to plot a visualisation of the sound it would be a simple graph of data with time on the x axis and microphone/speaker position as a value between -1 and 1 on the y axis. You can see an example of such a graph at the top of the diagram. Playing Part of a Sample So, how do we code Sonic Pi to play a sample back in a different order? To answer this question we need to take a look at the start: and finish: opts for sample . These let us control the start and finish positions of our playback of the numbers which represent the sound. The values for both of these opts are represented as a number between 0 and 1 where 0 represents the start of the sample and 1 is the end. So, to play the first half of the Amen Break, we just need to specify a finish: of 0.5 : sample :loop_amen, finish: 0.5 We can add in a start: value to play an even smaller section of the sample: sample :loop_amen, start: 0.25, finish: 0.5 For fun, you can even have the finish: opt's value be before start: and it will play the section backwards: sample :loop_amen, start: 0.5, finish: 0.25 Re-ordering Sample Playback Now that we know that a sample is simply a list of numbers that can be played back in any order and also how to play a specific part of a sample we can now start having fun playing a sample back in the 'wrong' order. Let's take our Amen Break and chop it up into 8 equally-sized slices and then shuffle the pieces around. Take a look at the diagram: at the top A) represents the graph of our original sample data. Chopping it into 8 slices gives us B) - notice that we've given each slice a different colour to help distinguish them. You can see each slice's start and finish values at the top. Finally C) is one possible re-ordering of the slices. We can then play this back to create a new beat. Take a look at the code to do this: live_loop :beat_slicer do slice_idx = rand_i(8) slice_size = 0.125 s = slice_idx * slice_size f = s + slice_size sample :loop_amen, start: s, finish: f sleep sample_duration :loop_amen, start: s, finish: f end we choose a random slice to play which should be a random number between 0 and 7 (remember that we start counting at 0). Sonic Pi has a handy function for exactly this: rand_i(8) . We then store this random slice index in the variable slice_idx . We define our slice_size which is 1/8 or 0.125. The slice_size is necessary for us to convert our slice_idx into a value between 0 and 1 so we can use it as our start: opt. We calculate the start position s by multiplying the slice_idx by the slice_size . We calculate the finish position f by adding the slice_size to the start position s . We can now play the sample slice by plugging in the s and f values into the start: and finish: opts for sample . Before we play the next slice we need to know how long to sleep which should be the duration of the sample slice. Luckily, Sonic Pi has us covered with sample_duration which accepts all the same opts as sample and simply returns the duration. Therefore, by passing sample_duration our start: and finish: opts, we can find out the duration of a single slice. We wrap all of this code in a live_loop so that we continue to pick new random slices to play. Alles zusammenf\u00fchren Let's combine everything we've seen so far into a final example which demonstrates how we can take a similar approach to combine randomly sliced beats with some bass to create the start of an interesting track. Now it's your turn - take the code below as a starting point and see if you can take it in your own direction and create something new... live_loop :sliced_amen do n = 8 s = line(0, 1, steps: n).choose f = s + (1.0 / n) sample :loop_amen, beat_stretch: 2, start: s, finish: f sleep 2.0 / n end live_loop :acid_bass do with_fx :reverb, room: 1, reps: 32, amp: 0.6 do tick n = (octs :e0, 3).look - (knit 0, 3 * 8, -4, 3 * 8).look co = rrand(70, 110) synth :beep, note: n + 36, release: 0.1, wave: 0, cutoff: co synth :tb303, note: n, release: 0.2, wave: 0, cutoff: co sleep (ring 0.125, 0.25).look end end A.13 Code a Probabilistic Sequencer In a previous episode of this Sonic Pi series we explored the power of randomisation to introduce variety, surprise and change into our live coded tracks and performances. For example, we randomly picked notes from a scale to create never-ending melodies. Today we're going to learn a new technique which uses randomisation for rhythm - probabilistic beats! Wahrscheinlichkeit Before we can start making new beats and synth rhythms we need to take a quick dive into the basics of probability. This might sound daunting and complicated, but really it's just as simple as rolling a dice - honestly! When you take a regular 6 sided board game dice and roll it what's actually happening? Well, firstly you'll roll either a 1, 2, 3, 4, 5 or 6 with exactly the same chance of getting any of the numbers. In fact, given that it's a 6 sided dice, on average (if you roll lots and lots of times) you'll throw a 1 every 6 throws. This means you have a 1 in 6 chance of throwing a 1. We can emulate dice rolls in Sonic Pi with the fn dice . Let's roll one 8 times: 8.times do puts dice sleep 1 end Notice how the log prints values between 1 and 6 just as if we'd rolled a real dice ourselves. Zuf\u00e4llige Beats Now imagine you had a drum and every time you were about to hit it you rolled a dice. If you rolled a 1, you hit the drum and if you rolled any other number you didn't. You now have a probabilistic drum machine working with a probability of 1/6! Let's hear what that sounds like: live_loop :random_beat do sample :drum_snare_hard if dice == 1 sleep 0.125 end Let's quickly go over each line to make sure everything is very clear. First we create a new live_loop called :random_beat which will continually repeat the two lines between do and end . The first of these lines is a call to sample which will play a pre-recorded sound (the :drum_snare_hard sound in this case). However, this line has a special conditional if ending. This means that the line will only be executed if the statement on the right hand side of the if is true . The statement in this case is dice == 1 . This calls our dice function which, as we have seen, returns a value between 1 and 6. We then use the equality operator == to check to see if this value is 1 . If it is 1 , then the statement resolves to true and our snare drum sounds, if it isn't 1 then the statement resolves to false and the snare is skipped. The second line simply waits for 0.125 seconds before rolling the dice again. Wahrscheinlichkeiten \u00e4ndern Diejenigen unter euch die schon einmal Rollenspiele gespielt haben, werden mit einer Menge seltsam geformter W\u00fcrfel verschiedener Zahlenbereiche vertraut sein. Es gibt zum Beispiel den tetraederf\u00f6rmigen W\u00fcrfel, der 4 Seiten hat und sogar einen 20-seitigen W\u00fcrfel in der Form eines Ikosaeder. Die Anzahl der Seiten eines W\u00fcrfels \u00e4ndert die Chancen, oder die Wahrscheinlichkeit eine 1 zu w\u00fcrfeln. Je weniger Seiten, desto gr\u00f6\u00dfer sind deine Chancen eine 1 zu w\u00fcrfeln, und je mehr Seiten, desto geringer. Zum Beispiel betr\u00e4gt die Wahrscheinlichkeit eine 1 zu w\u00fcrfeln bei einem 4-seitigen W\u00fcrfel 1 zu 4, und bei einem 20-seitigen W\u00fcrfel betr\u00e4gt sie 1 zu 20. Gl\u00fccklicherweise verf\u00fcgt Sonic Pi \u00fcber die praktische one_in -Funktion, um genau dies zu beschreiben. Lass uns spielen: live_loop :different_probabilities do sample :drum_snare_hard if one_in(6) sleep 0.125 end Start the live loop above and you'll hear the familiar random rhythm. However, don't stop the code running. Instead, change the 6 to a different value such as 2 or 20 and hit the Run button again. Notice that lower numbers mean the snare drum sounds more frequently and higher numbers mean the snare triggers fewer times. You're making music with probabilities! Wahrscheinlichkeiten kombinieren Things get really exciting when you combine multiple samples being triggered with different probabilities. For example: live_loop :multi_beat do sample :elec_hi_snare if one_in(6) sample :drum_cymbal_closed if one_in(2) sample :drum_cymbal_pedal if one_in(3) sample :bd_haus if one_in(4) sleep 0.125 end Again, run the code above and then start changing the probabilities to modify the rhythm. Also, try changing the samples to create an entirely new feel. For example try changing :drum_cymbal_closed to :bass_hit_c for extra bass! Wiederholbare Rhythmen Next, we can use our old friend use_random_seed to reset the random stream after 8 iterations to create a regular beat. Type the following code to hear a much more regular and repeating rhythm. Once you hear the beat, try changing the seed value from 1000 to another number. Notice how different numbers generate different beats. live_loop :multi_beat do use_random_seed 1000 8.times do sample :elec_hi_snare if one_in(6) sample :drum_cymbal_closed if one_in(2) sample :drum_cymbal_pedal if one_in(3) sample :bd_haus if one_in(4) sleep 0.125 end end One thing I tend to do with this kind of structure is to remember which seeds sound good and make a note of them. That way I can easily re-create my rhythms in future practice sessions or performances. Alles zusammenf\u00fchren Finally, we can throw in some random bass to give it some nice melodic content. Notice that we can also use our newly discovered probabilistic sequencing method on synths just as well as samples. Don't leave it at that though - tweak the numbers and make your own track with the power of probabilities! live_loop :multi_beat do use_random_seed 2000 8.times do c = rrand(70, 130) n = (scale :e1, :minor_pentatonic).take(3).choose synth :tb303, note: n, release: 0.1, cutoff: c if rand < 0.9 sample :elec_hi_snare if one_in(6) sample :drum_cymbal_closed if one_in(2) sample :drum_cymbal_pedal if one_in(3) sample :bd_haus, amp: 1.5 if one_in(4) sleep 0.125 end end A.14 Amplitudenmodulation This month we're going to take a deep dive into one of Sonic Pi's most powerful and flexible audio FX - the :slicer . By the end of this article you will have learned how to manipulate the overall volume of parts of our live coded sound in powerful new ways. This will allow you to create new rhythmic and timbral structures and broaden your sonic possibilities. Slice that Amp So, what does the :slicer FX actually do? One way to think about it is that it's just like having someone play around with the volume control on your TV or home hi-fi. Let's take a look but first, listen to the deep growl of the following code which triggers the :prophet synth: synth :prophet, note: :e1, release: 8, cutoff: 70 synth :prophet, note: :e1 + 4, release: 8, cutoff: 80 Now, let's pipe it through the :slicer FX: with_fx :slicer do synth :prophet, note: :e1, release: 8, cutoff: 70 synth :prophet, note: :e1 + 4, release: 8, cutoff: 80 end Hear how the slicer acts like it's muting and unmuting the audio with a regular beat. Also, notice how the :slicer affects all the audio generated between the do / end blocks. You can control the speed at which it turns the audio on and off with the phase: opt which is short for phase duration. Its default value is 0.25 which means 4 times a second at the default BPM of 60. Let's make it faster: with_fx :slicer, phase: 0.125 do synth :prophet, note: :e1, release: 8, cutoff: 70 synth :prophet, note: :e1 + 4, release: 8, cutoff: 80 end Now, play with different phase: durations yourself. Try longer and shorter values. See what happens when you choose a really short value. Also, try different synths such as :beep or :dsaw and different notes. Take a look at the following diagram to see how different phase: values change the number of amplitude changes per beat. Phase duration is the length of time for one on/off cycle. Therefore smaller values will make the FX switch on and off much faster than larger values. Good values to start playing with are 0.125 , 0.25 , 0.5 and 1 . Control Waves By default, the :slicer FX uses a square wave to manipulate the amplitude through time. This is why we hear the amplitude on for a period, then immediately off for a period, then back on again. It turns out that the square wave is just one of 4 different control waves that are supported by :slicer . The others are saw, triangle and (co)sine. Take a look at the diagram below to see what these look like. We can also hear what they sound like. For example, the following code uses (co)sine as the control wave. Hear how the sound doesn't turn on and off abruptly but instead smoothly fades in and out: with_fx :slicer, phase: 0.5, wave: 3 do synth :dsaw, note: :e3, release: 8, cutoff: 120 synth :dsaw, note: :e2, release: 8, cutoff: 100 end Have a play with the different wave forms by changing the wave: opt to 0 for saw, 1 for square, 2 for triangle and 3 for sine. See how different waves sound with different phase: opts too. Each of these waves can be inverted with the invert_wave: opt which flips it on the y axis. For example, in a single phase the saw wave typically starts high, and slowly goes down before jumping back to the top. With invert_wave: 1 it will start low and slowly go up before jumping back down again. Additionally, the control wave can be started at different points with the phase_offset: opt which should be a value between 0 and 1 . By playing around with phase: , wave: , invert_wave: and phase_offset opts you can dramatically change how the amplitude is modified through time. Dauer Setting your levels By default, :slicer switches between amplitude values 1 (fully loud) and 0 (silent). This can be changed with the amp_min: and amp_max: opts. You can use this alongside the sine wave setting to create a simple tremolo effect: with_fx :slicer, amp_min: 0.25, amp_max: 0.75, wave: 3, phase: 0.25 do synth :saw, release: 8 end This is just like grabbing the volume knob on your hi-fi and moving it up and down just a little so the sound 'wobbles' in and out. Wahrscheinlichkeiten One of :slicer 's powerful features is its ability to use probability to choose whether or not to turn the slicer on or off. Before the :slicer FX starts a new phase it rolls a dice and based on the result either uses the selected control wave or keeps the amplitude off. Let's take a listen: with_fx :slicer, phase: 0.125, probability: 0.6 do synth :tb303, note: :e1, cutoff_attack: 8, release: 8 synth :tb303, note: :e2, cutoff_attack: 4, release: 8 synth :tb303, note: :e3, cutoff_attack: 2, release: 8 end Hear how we now have an interesting rhythm of pulses. Try changing the probability: opt to a different value between 0 and 1 . Values closer to 0 will have more space between each sound due to the likelihood of the sound being triggered being much lower. Another thing to notice is that the probability system in the FX is just like the randomisation system accessible via fns such as rand and shuffle . They are both completely deterministic. This means that each time you hit Run you'll hear exactly the same rhythm of pulses for a given probability. If you would like to change things around you can use the seed: opt to select a different starting seed. This works exactly the same as use_random_seed but only affects that particular FX. Finally, you can change the 'resting' position of the control wave when the probability test fails from 0 to any other position with the prob_pos: opt: with_fx :slicer, phase: 0.125, probability: 0.6, prob_pos: 1 do synth :tb303, note: :e1, cutoff_attack: 8, release: 8 synth :tb303, note: :e2, cutoff_attack: 4, release: 8 synth :tb303, note: :e3, cutoff_attack: 2, release: 8 end Slicing Beats One really fun thing to do is to use :slicer to chop a drum beat in and out: with_fx :slicer, phase: 0.125 do sample :loop_mika end This allows us to take any sample and create new rhythmical possibilities which is a lot of fun. However, one thing to be careful about is to make sure that the tempo of the sample matches the current BPM in Sonic Pi otherwise the slicing will sound totally off. For example, try swapping :loop_mika with the loop_amen sample to hear how bad this can sound when the tempos don't align. Tempo \u00e4ndern As we have already seen, changing the default BPM with use_bpm will make all the sleep times and synth envelope durations grow or shrink to match the beat. The :slicer FX honours this too, as the phase: opt is actually measured in beats not seconds. We can therefore fix the issue with loop_amen above by changing the BPM to match the sample: use_sample_bpm :loop_amen with_fx :slicer, phase: 0.125 do sample :loop_amen end Alles zusammenf\u00fchren Let's apply all these ideas into a final example that only uses the :slicer FX to create an interesting combination. Go ahead, start changing it and make it into your own piece! live_loop :dark_mist do co = (line 70, 130, steps: 8).tick with_fx :slicer, probability: 0.7, prob_pos: 1 do synth :prophet, note: :e1, release: 8, cutoff: co end with_fx :slicer, phase: [0.125, 0.25].choose do sample :guit_em9, rate: 0.5 end sleep 8 end live_loop :crashing_waves do with_fx :slicer, wave: 0, phase: 0.25 do sample :loop_mika, rate: 0.5 end sleep 16 end A.15 Five Live Coding Techniques In this month's Sonic Pi tutorial we're going to take a look at how you can start treating Sonic Pi like a real instrument. We therefore need to start thinking of code in a completely different way. Live coders think of code in a similar way to how violinists think of their bow. In fact, just like a violinist can apply various bowing techniques to create different sounds (long slow motions vs short fast hits) we will explore five of the basic live coding techniques that Sonic Pi enables. By the end of this article you'll be able to start practicing for your own live coded performances. 1. Memorise the Shortcuts The first tip to live coding with Sonic Pi is to start using the shortcuts. For example, instead of wasting valuable time reaching for the mouse, moving it over to the Run button and clicking, you can simply press alt and r at the same time which is much faster and keeps your fingers at the keyboard ready for the next edit. You can find out the shortcuts for the main buttons at the top by hovering the mouse over them. See section 10.2 of the built-in tutorial for the full list of shortcuts. When performing, one fun thing to do is to add a bit of flair with your arm motion when hitting shortcuts. For example, it's often good to communicate to the audience when you're about to make a change - so embellish your movement when hitting alt-r just like a guitarist would do when hitting a big power chord. 2. Manually Layer your Sounds Now you can trigger code instantly with the keyboard, you can instantly apply this skill for our second technique which is to layer your sounds manually. Instead of 'composing' using lots of calls to play , and sample separated by calls to sleep we will have one call to play which we will manually trigger using alt-r . Let's try it. Type the following code into a fresh buffer: synth :tb303, note: :e2 - 0, release: 12, cutoff: 90 Now, hit Run and whilst the sound is playing, modify the code in order to drop down four notes by changing it to the following: synth :tb303, note: :e2 - 4, release: 12, cutoff: 90 Now, hit Run again, to hear both sounds playing at the same time. This is because Sonic Pi's Run button doesn't wait for any previous code to finish, but instead starts the code running at the same time. This means you can easily layer lots of sounds manually with minor or major modifications between each trigger. For example, try changing both the note: and the cutoff: opts and then re-trigger. You can also try this technique with long abstract samples. For example: sample :ambi_lunar_land, rate: 1 Try starting the sample off, and then progressively halving the rate: opt between hitting Run from 1 to 0.5 to 0.25 to 0.125 and then even try some negative values such as -0.5 . Layer the sounds together and see where you can take it. Finally, try adding some FX. When performing, working with simple lines of code in this way means that an audience new to Sonic Pi has a good chance to follow what you're doing and relate the code that they can read to the sounds they are hearing. 3. Master Live Loops When working with more rhythmic music, it can often be hard to manually trigger everything and keep good time. Instead, it is often better to use a live_loop . This provides repetition for your code whilst also giving the ability to edit the code for the next time round the loop. They also will run at the same time as other live_loop s which means you can layer them together both with each other and manual code triggers. Take a look at section 9.2 of the built-in tutorial for more information about working with live loops. When performing, remember to make use of live_loop 's sync: opt to allow you to recover from accidental runtime mistakes which stop the live loop running due to an error. If you already have the sync: opt pointing to another valid live_loop , then you can quickly fix the error and re-run the code to re-start things without missing a beat. 4. Verwende den Hauptmischer One of Sonic Pi's best kept secrets is that it has a main mixer through which all sound flows. This mixer has both a low pass filter and a high pass filter built-in, so you can easily perform global modifications to the sound. The main mixer's functionality can be accessed via the fn set_mixer_control! . For example, whilst some code is running and making sound, enter this into a spare buffer and hit Run : set_mixer_control! lpf: 50 After you run this code, all existing and new sounds will have a low pass filter applied to them and will therefore sound more muffled. Note that this means that the new mixer values stick until they are changed again. However, if you want, you can always reset the mixer back to its default state with reset_mixer! . Some of the currently supported opts are: pre_amp: , lpf: hpf: , and amp: . For the full list, see the built-in docs for set_mixer_control! . Use the mixer's *_slide opts to slide one or many opts values over time. For example, to slowly slide the mixer's low pass filter down from the current value to 30, use the following: set_mixer_control! lpf_slide: 16, lpf: 30 You can then slide quickly back to a high value with: set_mixer_control! lpf_slide: 1, lpf: 130 Bei der Ausf\u00fchrung ist es oft hilfreich, einen Puffer frei zu halten, um, wie jetzt, mit dem Mixer zu arbeiten. 5. \u00dcbung The most important technique for live coding is practice. The most common attribute across professional musicians of all kinds is that they practice playing with their instruments - often for many hours a day. Practice is just as important for a live coder as a guitarist. Practice allows your fingers to memorise certain patterns and common edits so you can type and work with them more fluently. Practice also gives you opportunities to explore new sounds and code constructs. When performing, you'll find the more practice you do, the easier it will be for you to relax into the gig. Practice will also give you a wealth of experience to draw from. This can help you understand which kinds of modifications will be interesting and also work well with the current sounds. Alles zusammenf\u00fchren This month, instead of giving you a final example that combines all the things discussed, let's part by setting down a challenge. See if you can spend a week practicing one of these ideas every day. For example, one day practice manual triggers, the next do some basic live_loop work and the following day play around with the main mixer. Then repeat. Don't worry if things feel slow and clunky at first - just keep practicing and before you know it you'll be live coding for a real audience. A.16 How to Practice Live Coding Last month we took a look at five important techniques for mastering live coding - in other words, we explored how we could use Sonic Pi to approach code in the same way we would approach a musical instrument. One of the important concepts that we discussed was practice. This month we're going to take a deeper dive into understanding why live coding practice is important and how you might start. \u00dcbe regelm\u00e4\u00dfig The most important piece of advice is to make sure you practice regularly. As a rule I typically practice for 1-2 hours a day, but 20 mins is just fine when you're starting out. Little but often is what you're aiming for - so if you can only manage 10 minutes, that's a great start. Practice tip #1 - start to develop a practice routine. Find a nice time in the day that works for you and try and practice at that time as many days of the week as you can. Before long you'll be looking forward to your regular session. Learn to Touch Type If you watch a professional musician performing on stage you'll likely notice a few things. Firstly, when they play they don't stare at their instrument. Their fingers, arms and bodies know which keys to press, strings to pluck or drums to hit without them having to think about it too much. This is known as \"muscle memory\" and although it might sound like something only professionals can do - it's just the same as when you first learned to walk or ride a bike - practicing through repetition. Live coders use muscle memory to free their minds from having to think about where to move their fingers so they can focus on the music. This is called touch-typing - typing without having to look at the keyboard. Practice tip #2 - learn how to touch type. There are many apps, websites and even games which can help you achieve this. Find one you like the look of and stick at it until you can code without looking down. Code whilst standing The body of a musician is conditioned for playing their instrument. For example, a trumpet player needs to be able to blow hard, a guitar player needs to be able to grip the fretboard with strength and a drummer needs to be able to continually hit the drums for long periods of time. So, what's physical about live coding? Just like DJs, live coders typically perform whilst standing up and some even dance whilst they code! If you practice live coding whilst sitting at a desk and then have to get up and stand at a gig, you'll likely find the difference very difficult and frustrating. Practice tip #3 - stand whilst you practice. The easiest way to do this is to use a standing height desk. However, if like me you don't have one at home, there's a couple of low-fi options. The approach I take is to use an ironing board which happens to work rather well. Another is to stack some boxes or large books on a normal desk and place your keyboard on top of that. Also, make sure you stretch before you start practicing and try and dance a little during the session. Remember, nobody is watching you, so have fun and you'll feel much more natural on stage. Practice setting up Most instruments require some assembly and tuning before they can be played. Unless you're a rockstar with a bus full of roadies, you'll have to set up your own instrument before your gig. This is often a stressful time and it is easy for problems to occur. One way to help with this is to incorporate the setup process into your practice sessions. Practice tip #4 - treat setting up as an important part of your practice. For example, have a box or bag that you can keep your Raspberry Pi and keyboard in etc. Before each practice session, take out all the parts, connect everything, and work through the boot process until you have Sonic Pi running and can make sounds. Once you've finished practicing, take the time to carefully pack everything away afterwards. This may take some time at first, but before long you'll be able to setup and pack everything away incredibly quickly without having to think about it. Experimentiere musikalisch Once you've set up and are ready to start making music, you might find yourself struggling to know where to start. One problem many people face is that they might have a good idea of the kinds of sounds they want to make, but are frustrated that they can't produce them. Some people don't even know what kind of sounds they want to make! The first thing to do is not to worry - this is very common and happens to every musician - even if they've been practicing for a long time. It is much more important to be making sounds you don't like than not making any sounds at all. Practice tip #5 - spend time making sounds and music you don't like. Try to make time to explore new sounds and ideas. Don't worry that it might sound terrible if it's not the style you're looking for. When you're experimenting like this you increase the chance of stumbling over a sound or combination of sounds which you love! Even if 99% of the sounds you make are bad, that 1% might be the riff or intro to your new track. Forget the things you don't like and remember the parts you do. This is even easier when you're making music with code - just hit save! H\u00f6re den Code Viele Musiker k\u00f6nnen auf ein Notenblatt schauen und die Musik in ihrem Kopf h\u00f6ren, ohne das sie gespielt wird. Das ist eine sehr n\u00fctzliche F\u00e4higkeit und es lohnt sich auch diese auf deine Live-Coding \u00dcbungen zu \u00fcbertragen: Der wichtige Punkt ist, dass Du eine gewisse Vorstellungen dar\u00fcber entwickelst, wie sich Dein Code anh\u00f6ren wird. Du musst es nat\u00fcrlich nicht genau in deinem Kopf h\u00f6ren k\u00f6nnen, aber es ist praktisch, ein Gef\u00fchl daf\u00fcr zu haben, ob sich der Code schnell oder langsam, laut, rhythmisch, melodisch, zuf\u00e4llig usw. anh\u00f6ren wird. Das endg\u00fcltige Ziel ist dann, diesen Prozess umkehren zu k\u00f6nnen und zu Musik, die Du dir in deinem Kopf vorstellst, den passenden Code schreiben zu k\u00f6nnen. Bis dahin wirst du wahrscheinlich sehr viel \u00fcben m\u00fcssen, aber wenn du es dann kannst, wirst du es schaffen auf der B\u00fchne improvisieren zu k\u00f6nnen und deine Ideen flie\u00dfend umzusetzen. Practice tip #6 - write some code into Sonic Pi but don't hit the Run button. Instead, try to imagine what sound it is going to produce. Then, hit Run, listen, and think about what you got right and what you didn't. Keep repeating this until it become a natural part of your coding process. When I practice I normally have a good idea of what the code will sound like. However, I still am occasionally surprised, and then I'll stop and spend some time thinking about why I was wrong. Each time this happens, I learn new tricks which allow me to express myself in new ways. Remove all distractions A common problem when practicing is to become distracted with other things. Practicing is hard and requires real discipline regardless of the kind of music you're making - from jazz to classical to EDM. If you're struggling to get started or make progress, it's often too easy to hop on social media, or look something up on the internet etc. If you've set yourself a target of 20 minutes of practice, it's important to try and spend all that time being as productive as possible. Practice tip #7 - before you start practicing remove as many distractions as possible. For example, disconnect from the internet, put your phone in another room and try to practice in a quiet place where you're unlikely to be disturbed. Try to focus on coding music and you can return to your distractions when you've finished. Keep a practice diary When you are practicing, you'll often find your mind is full of new exciting ideas - new musical directions, new sounds to try out, new functions to write, etc. These ideas are often so interesting that you might stop what you're doing and start working on the idea. This is another form of distraction! Practice tip #8 - keep a practice diary by your keyboard. When you get an exciting new idea, temporarily pause your practice session, quickly jot the idea down, then forget about it and carry on practicing. You can then spend some quality time thinking about and working on your ideas after you've finished practicing. Alles zusammenf\u00fchren Try to establish a practice routine which incorporates as many of these ideas as possible. Try to keep the sessions as fun as possible but be aware that some practice sessions will be hard and feel a little like work. However, it will all be worth it once you've created your first piece or given your first performance. Remember, practice is the key to success! A.17 Sample Stretching When people discover Sonic Pi, one of the first things they learn is how simple it is to play pre-recorded sounds using the sample function. For example, you can play an industrial drum loop, hear the sound of a choir or even listen to a vinyl scratch all via a single line of code. However, many people don't realise that you can actually vary the speed that the sample is played back at for some powerful effects and a whole new level of control over your recorded sounds. So, fire up a copy of Sonic Pi and let's get started stretching some samples! Sample verlangsamen To modify the playback rate of a sample we need to use the rate: opt: Sample :guit_em9, rate: 1 If we specify a rate: of 1 then the sample is played back at the normal rate. If we want to play it back at half speed we simply use a rate: of 0.5 : sample :guit_em9, rate: 0.5 Dies hat zwei Auswirkungen auf den Ton. Das Sample h\u00f6rt sich tiefer an und es dauert doppelt so lange es abzuspielen (eine Erkl\u00e4rung hierf\u00fcr findest du in der Seitenleiste). Wir k\u00f6nnen den Wert von rate immer kleiner machen, indem wir uns 0 ann\u00e4hern. Eine Rate von 0.25 bedeutet ein Viertel der Geschwindigkeit, eine Rate von 0.1 ein Zehntel, usw. Spiele mit niedrige Raten herum und schaue, ob du es schaffst ein tiefes Murren zu erzeugen. Sample beschleunigen In addition to making the sound longer and lower using a small rate, we can use higher rates to make the sound shorter and higher. Let's play with a drum loop this time. First, take a listen to how it sounds at the default rate of 1 : sample :loop_amen, rate: 1 Lassen wir es etwas schneller werden: sample :loop_amen, rate: 1.5 Ha! We just moved musical genres from old-skool techno to jungle. Notice how the pitch of each drum hit is higher as well as how the whole rhythm speeds up. Now, try even higher rates and see how high and short you can make the drum loop. For example, if you use a rate of 100 , the drum loop turns into a click! R\u00fcckw\u00e4rtsgang Now, I'm sure many of you are thinking the same thing right now... \"what if you use a negative number for the rate?\". Great question! Let's think about this for a moment. If our rate: opt signifies the speed with which the sample is played back, 1 being normal speed, 2 being double speed, 0.5 being half speed, -1 must mean backwards! Let's try it on a snare. First, play it back at the normal rate: sample :elec_filt_snare, rate: 1 Jetzt lass es uns r\u00fcckw\u00e4rts abspielen: sample :elec_filt_snare, rate: -1 Of course, you can play it backwards twice as fast with a rate of -2 or backwards at half speed with a rate of -0.5 . Now, play around with different negative rates and have fun. It's particularly amusing with the :misc_burp sample! Sample, Rate and Pitch One of the effects of rate modification on samples is that faster rates result in the sample sounding higher in pitch and slower rates result in the sample sounding lower in pitch. Another place you may have heard this effect in every day life is when you're cycling or driving past a beeping pedestrian crossing - as you're heading towards the sound source the pitch is higher than when you're moving away from the sound - the so-called Doppler effect. Why is this? Let's consider a simple beep which is represented by a sine wave. If we use an oscilloscope to plot a beep, we'll see something like Figure A. If we plot a beep an octave higher, we'll see Figure B and an octave lower will look like Figure C. Notice that the waves of higher notes are more compact and the waves of lower notes are more spread out. A sample of a beep is nothing more than a lot of numbers (x, y, coordinates) which when plotted onto a graph will re-draw the original curves. See figure D where each circle represents a coordinate. To turn the coordinates back into audio, the computer works through each x value and sends the corresponding y value to the speakers. The trick here is that the rate at which the computer works through the x numbers does not have to be the same as the rate with which they were recorded. In other words, the space (representing an amount of time) between each circle can be stretched or compressed. So, if the computer walks through the x values faster than the original rate, it will have the effect of squashing the circles closer together which will result in a higher sounding beep. It will also make the beep shorter as we will work through all the circles faster. This is shown in Figure E. Finally, one last thing to know is that a mathematician called Fourier proved that any sound is actually lots and lots of sine waves all combined together. Therefore, when we compress and stretch any recorded sound we're actually stretching and compressing many sine waves all at the same time in exactly this manner. Pitch Bending As we've seen, using a faster rate will make the sound higher in pitch and a slower rate will make the sound lower in pitch. A very simple and useful trick is to know that doubling the rate actually results in the pitch being an octave higher and inversely halving the rate results in the pitch being an octave lower. This means that for melodic samples, playing it alongside itself at double/half rates actually sounds rather nice: sample :bass_trance_c, rate: 1 sample :bass_trance_c, rate: 2 sample :bass_trance_c, rate: 0.5 However, what if we just want to alter the rate such that the pitch goes up one semitone (one note up on a piano)? Sonic Pi makes this very easy via the rpitch: opt: sample :bass_trance_c sample :bass_trance_c, rpitch: 3 sample :bass_trance_c, rpitch: 7 If you take a look at the log on the right, you'll notice that an rpitch: of 3 actually corresponds to a rate of 1.1892 and a rpitch: of 7 corresponds to a rate of 1.4983 . Finally, we can even combine rate: and rpitch: opts: sample :ambi_choir, rate: 0.25, rpitch: 3 sleep 3 sample :ambi_choir, rate: 0.25, rpitch: 5 sleep 2 sample :ambi_choir, rate: 0.25, rpitch: 6 sleep 1 sample :ambi_choir, rate: 0.25, rpitch: 1 Alles zusammenf\u00fchren Let's take a look at a simple piece which combines these ideas. Copy it into an empty Sonic Pi buffer, hit play, listen to it for a while and then use it as a starting point for your own piece. See how much fun it is to manipulate the playback rate of samples. As an added exercise try recording your own sounds and play around with the rate to see what wild sounds you can make. live_loop :beats do sample :guit_em9, rate: [0.25, 0.5, -1].choose, amp: 2 sample :loop_garzul, rate: [0.5, 1].choose sleep 8 end live_loop :melody do oct = [-1, 1, 2].choose * 12 with_fx :reverb, amp: 2 do 16.times do n = (scale 0, :minor_pentatonic).choose sample :bass_voxy_hit_c, rpitch: n + 4 + oct sleep 0.125 end end end A.18 Sound Design - Additive Synthesis This is the first of a short series of articles on how to use Sonic Pi for sound design. We'll be taking a quick tour of a number of different techniques available for you to craft your own unique sound. The first technique we'll look at is called additive synthesis . This may sound complicated - but if we expand each word slightly the meaning pops right out. Firstly, additive means a combination of things and secondly synthesis means to create sound. Additive synthesis therefore means nothing more complicated than combining existing sounds to create new ones . This synthesis technique dates back a very long time - for example, pipe organs in the middle ages had lots of slightly different sounding pipes which you could enable or disable with stops. Pulling out the stop for a given pipe 'added it to the mix' making the sound richer and more complex. Now, let's see how we can pull out all the stops with Sonic Pi. Simple Combinations Let's start with the most basic sound there is - the humble pure-toned sine wave: synth :sine, note: :d3 Now, let's see how this sounds combined with a square wave: synth :sine, note: :d3 synth :square, note: :d3 Notice how the two sounds combine to form a new, richer sound. Of course, we don't have to stop there, we can add as many sounds as we need. However, we need to be careful with how many sounds we add together. Just like when we mix paints to create new colours, adding too many colours will result in a messy brown, similarly - adding too many sounds together will result in a muddy sound. Blending Let's add something to make it sound a little brighter. We could use a triangle wave at an octave higher (for that high bright sound) yet only play it at amp 0.4 so it adds something extra to the sound rather than taking it over: synth :sine, note: :d3 synth :square, note: :d3 synth :tri, note: :d4, amp: 0.4 Now, try creating your own sounds by combining 2 or more synths at different octaves and amplitudes. Also, note that you can play around with each synth's opts to modify each source sound before it is mixed in for even more combinations of sounds. Verstimmung So far, when combining our different synths we've used either the same pitch or switched octave. How might it sound if we didn't stick to octaves but instead chose a slightly higher or lower note? Let's try it: detune = 0.7 synth :square, note: :e3 synth :square, note: :e3 + detune If we detune our square waves by 0.7 notes we hear something that perhaps doesn't sound in tune or correct - a 'bad' note. However, as we move closer to 0 it will sound less and less out of tune as the pitches of the two waves get closer and more similar. Try it for yourself! Change the detune: opt value from 0.7 to 0.5 and listen to the new sound. Try 0.2 , 0.1 , 0.05 , 0 . Each time you change the value, take a listen and see if you can hear how the sound is changing. Notice that low detune values such as 0.1 produce a really nice 'thick' sound, with both slightly different pitches interacting with each other in interesting, often surprising, ways. Einige der integrierten Synths haben bereits eine Option zur Verstimmung, die das ganze f\u00fcr einem Synth machen. Probiere die Option detune: von :dsaw , :dpulse und :dtri aus. Amplitudenmodellierung Another way we can finely craft our sound is to use a different envelope and options for each synth trigger. For example this will allow you to make some aspects of the sound percussive and other aspects ring out for a period of time. detune = 0.1 synth :square, note: :e1, release: 2 synth :square, note: :e1 + detune, amp: 2, release: 2 synth :gnoise, release: 2, amp: 1, cutoff: 60 synth :gnoise, release: 0.5, amp: 1, cutoff: 100 synth :noise, release: 0.2, amp: 1, cutoff: 90 In the example above I have mixed in a noisy percussive element to the sound along with some more persistent background rumbling. This was achieved firstly by using two noise synths with middling cutoff values ( 90 and 100 ) using short release times along with a noise with a longer release time but with a low cutoff value (which makes the noise less crisp and more rumbly.) Alles zusammenf\u00fchren Let's combine all these techniques to see if we can use additive synthesis to re-create a basic bell sound. I've broken this example into four sections. Firstly we have the 'hit' section which is the initial onset part of the bell sound - so uses a short envelope (e.g. a release: of around 0.1 ). Next we have the long ringing section in which I'm using the pure sound of the sine wave. Notice that I'm often increasing the note by roughly 12 and 24 which are the number of notes in one and two octaves. I have also thrown in a couple of low sine waves to give the sound some bass and depth. Finally, I used define to wrap my code in a function which I can then use to play a melody. Try playing your own melody and also messing around with the contents of the :bell function until you create your own fun sound to play with! define :bell do |n| # Triangle waves for the 'hit' synth :tri, note: n - 12, release: 0.1 synth :tri, note: n + 0.1, release: 0.1 synth :tri, note: n - 0.1, release: 0.1 synth :tri, note: n, release: 0.2 # Sine waves for the 'ringing' synth :sine, note: n + 24, release: 2 synth :sine, note: n + 24.1, release: 2 synth :sine, note: n + 24.2, release: 0.5 synth :sine, note: n + 11.8, release: 2 synth :sine, note: n, release: 2 # Low sine waves for the bass synth :sine, note: n - 11.8, release: 2 synth :sine, note: n - 12, release: 2 end # Play a melody with our new bell! bell :e3 sleep 1 bell :c2 sleep 1 bell :d3 sleep 1 bell :g2 A.19 Sound Design - Subtractive Synthesis This is the second in a series of articles on how to use Sonic Pi for sound design. Last month we looked at additive synthesis which we discovered was the simple act of playing multiple sounds at the same time to make a new combined sound. For example we could combine different sounding synths or even the same synth at different pitches to build a new complex sound from simple ingredients. This month we'll look at a new technique commonly called subtractive synthesis which is simply the act of taking an existing complex sound and removing parts of it to create something new. This is a technique which is commonly associated with the sound of analog synthesisers of the 1960s and 1970s but also with the recent renaissance of modular analog synths through popular standards such as Eurorack. Despite this sounding like a particularly complicated and advanced technique, Sonic Pi makes it surprisingly simple and easy - so let's dive right in. Complex Source Signal For a sound to work well with subtractive synthesis, it typically needs to be fairly rich and interesting. This doesn't mean we need something hugely complex - in fact, just a standard :square or :saw wave will do: synth :saw, note: :e2, release: 4 Notice that this sound is already pretty interesting and contains many different frequencies above :e2 (the second E on a piano) which add to create the timbre. If that didn't make much sense to you, try comparing it with the :beep : synth :beep, note: :e2, release: 4 As the :beep synth is just a sine wave, you'll hear a much purer tone and only at :e2 and none of the high crispy/buzzy sounds which you heard in the :saw . It's this buzziness and variation from a pure sine wave that we can play with when we use subtractive synthesis. Filter Once we have our raw source signal, the next step is to pass it through a filter of some kind which will modify the sound by removing or reducing parts of it. One of the most common filters used for subtractive synthesis is something called a low pass filter. This will allow all the low parts of the sound through but will reduce or remove the higher parts. Sonic Pi has a powerful yet simple to use FX system that includes a low pass filter, called :lpf . Let's play with it: with_fx :lpf, cutoff: 100 do synth :saw, note: :e2, release: 4 end If you listen carefully you'll hear how some of that buzziness and crispiness has been removed. In fact, all the frequencies in the sound above note 100 have been reduced or removed and only the ones below are still present in the sound. Try changing that cutoff: point to lower notes, say 70 and then 50 and compare the sounds. Of course, the :lpf isn't the only filter you can use to manipulate the source signal. Another important FX is the high pass filter referred to as :hpf in Sonic Pi. This does the opposite to :lpf in that it lets the high parts of the sound through and cuts off the low parts. with_fx :hpf, cutoff: 90 do synth :saw, note: :e2, release: 4 end Notice how this sounds much more buzzy and raspy now that all the low frequency sounds have been removed. Play around with the cutoff value - notice how lower values let more of the original bass parts of the source signal through and higher values sound increasingly tinny and quiet. Low Pass Filter The low pass filter is such an important part of every subtractive synthesis toolkit that it's worth taking a deeper look at how it works. This diagram shows the same sound wave (the :prophet synth) with varying amounts of filtering. At the top, section A shows the audio wave with no filtering. Notice how the wave form is very pointy and contains lots of sharp edges. It is these hard, sharp angles that produce the high crispy/buzzy parts of the sound. Section B shows the low pass filter in action - notice how it is less pointy and more rounded than the wave form above. This means that the sound will have fewer high frequencies giving it a more mellow rounded feel. Section C shows the low pass filter with a fairly low cutoff value - this means that even more of the high frequencies have been removed from the signal resulting in an even softer, rounder wave form. Finally, notice how the size of the wave form, which represents the amplitude, decreases as we move from A to C. Subtractive synthesis works by removing parts of the signal which means that the overall amplitude is reduced as the amount of filtering that is taking place increases. Filter Modulation So far we've just produced fairly static sounds. In other words, the sound doesn't change in any way for the entirety of its duration. Often you might want some movement in the sound to give the timbre some life. One way to achieve this is via filter modulation - changing the filter's options through time. Luckily Sonic Pi gives you powerful tools to manipulate an FX's opts through time. For example, you can set a slide time to each modulatable opt to specify how long it should take for the current value to linearly slide to the target value: with_fx :lpf, cutoff: 50 do |fx| control fx, cutoff_slide: 3, cutoff: 130 synth :prophet, note: :e2, sustain: 3.5 end Let's take a quick look at what's going on here. Firstly we start an :lpf FX block as normal with an initial cutoff: of a low 50 . However, the first line also finishes with the strange |fx| at the end. This is an optional part of the with_fx syntax which allows you to directly name and control the running FX synth. Line 2 does exactly this and controls the FX to set the cutoff_slide: opt to 3 and the new target cutoff: to be 130 . The FX will now start sliding the cutoff: opt's value from 50 to 130 over a period of 3 beats. Finally we also trigger a source signal synth so we can hear the effect of the modulated low pass filter. Alles zusammenf\u00fchren This is just a very basic taster of what's possible when you use filters to modify and change a source sound. Try playing with Sonic Pi's many built-in FX to see what fun sounds you can design. If your sound feels too static, remember you can start modulating the options to create some movement. Let's finish by designing a function which will play a new sound created with subtractive synthesis. See if you can figure out what's going on here - and for the advanced Sonic Pi readers out there - see if you can work out why I wrapped everything inside a call to at (please send answers to @samaaron on Twitter). define :subt_synth do |note, sus| at do with_fx :lpf, cutoff: 40, amp: 2 do |fx| control fx, cutoff_slide: 6, cutoff: 100 synth :prophet, note: note, sustain: sus end with_fx :hpf, cutoff_slide: 0.01 do |fx| synth :dsaw, note: note + 12, sustain: sus (sus * 8).times do control fx, cutoff: rrand(70, 110) sleep 0.125 end end end end subt_synth :e1, 8 sleep 8 subt_synth :e1 - 4, 8 A.20 Creative coding in the classroom with Sonic Pi (This article was published in issue 9 of the Hello World Magazine ) Code is one of the most creative media that humans have created. The initially obscure symbols of parentheses and lambdas are not just deeply rooted in science and mathematics, they are the closest we have managed to get to casting the same kind of magical spells as Gandalf and Harry Potter. I believe that this provides a powerful means of engagement in our learning spaces. Through the magic of code we are able to conjure up individually meaningful stories and learning experiences. We are surrounded by magical experiences. From the sleight of hand of a stage magician making the ball disappear into thin air, to the wonder of seeing your favourite band perform on a big stage. It is these \"wow\" moments that inspire us to pick up a magic book and learn the French Drop or to start jamming power chords on an old guitar. How might we create similarly deep and lasting senses of wonder that will motivate people to practice and learn the fundamentals of programming? Musical Engines and Notation The histories of music and computers have been intricately woven together since the inception of computing machines, or \"engines\" as Charles Babbage's powerful analytical engine was called. Back in 1842 the Mathematician Ada Lovelace, who worked very closely with Babbage, saw the creative potential of these engines. Whilst these first engines had originally been designed to accurately solve hard maths problems, Ada dreamt about making music with them: \"..the engine might compose elaborate and scientific pieces of music of any degree of complexity or extent.\" Ada Lovelace, 1842. Of course, today in 2019 much of our music, regardless of genre, has either been composed, produced or mastered with a digital computer. Ada's dream came true. It is even possible to trace the history back even further. If you see coding as the art of writing sequences of special symbols that instruct a computer to do specific things, then musical composition is a very similar practice. In Western music, the symbols are black dots positioned on a stave of lines that tell the musician which notes to play and when. Intriguingly, if we trace the roots of Western music notation back to the Italian Benedictine monk, Guido d'Arezzo, we find that the dots and lines system that modern orchestras use is just one of a number of notation systems he worked on. Some of the others were much closer to what we might now see as code. In der Wissenschaft werden seit den sp\u00e4ten 60er Jahren magische, bedeutungsvolle Erfahrungen mit Computern und Programmiersprachen erforscht. Die Pioniere des Computerunterrichts Seymour Papert, Marvin Minsky und Cynthia Solomon erforschten einfache Lisp-basierte Sprachen, die Stifte \u00fcber gro\u00dfe Papierst\u00fccke bewegten. Mit nur wenigen einfachen Befehlen war es m\u00f6glich, den Computer so zu programmieren, dass er jedes beliebige Bild zeichnete. Sie experimentierten sogar damit, ihre Logo-Sprache vom Zeichnen auf Musik auszuweiten. Papert schrieb \u00fcber das Lernen durch die Erfahrung der Rekonstruktion von Wissen und nicht durch dessen Vermittlung. Die Menschen dazu zu bringen, direkt mit den Dingen zu experimentieren, war ein wichtiger Teil der Arbeit seiner Gruppe. Sonic Pi Performances Jylda und Sam Aaron treten auf der Thinking Digital Conference im Sage Gateshead auf. Foto: TyneSight Photos. Sonic Pi has been used to perform in a wide range of venues such as school halls, nightclubs, outdoor stages at musical festivals, college chapels and prestigious music venues. For example the amazing Convo project which brought 1000 children together in the Royal Albert Hall to perform an ambitious new composition by composer Charlotte Harding. The piece was written for traditional instruments, choirs, percussion and Sonic Pi code. The pop-artist Jylda also performed with Sonic Pi in the Sage Gateshead for the Thinking Digital Conference, where she created a unique live-coded improvised remix of her song Reeled. Sonic Pi used as one of the instruments as part of Convo at the Royal Albert Hall. Photo credit: Pete Jones. Live coding in the classroom Sonic Pi is a code-based music creation and performance tool that builds on all of these ideas. Unlike the majority of computing education software, it is both simple enough to use for education and also powerful enough for professionals. It has been used to perform in international music festivals, used to compose in a range of styles from classical, EDM and heavy metal, and was even reviewed in the Rolling Stone magazine. It has a diverse community of over 1.5 million live coders with a variety of backgrounds all learning and sharing their ideas and thoughts through the medium of code. It is free to download for Mac, PC and Raspberry Pi and includes a friendly tutorial that assumes you know nothing about either code or music. Sonic Pi was initially conceived as a response to the UK's newly released Computing curriculum in 2014. The goal was to find a motivating and fun way to teach the fundamentals of programming. It turns out that there is a lot in common and it's huge fun to explain sequencing as melody, iteration as rhythm, conditionals as musical variety. I developed the initial designs and first iterations of the platform with Carrie Anne Philbin, who brought a teacher\u2019s perspective to the project. Since then, Sonic Pi has undergone iterative improvements thanks to the feedback gained from observing learners and collaborating directly with educators in the classroom. A core design philosophy was to never add a feature that couldn't be easily taught to a 10 year old child. This meant that most ideas had to be heavily refined and reworked until they were simple enough. Making things simple whilst keeping them powerful continues to be the hardest part of the project. In order to provide the magical motivation, Sonic Pi's design was never limited to a pure focus on education. Ideally there would be famous musicians and performers using Sonic Pi as a standard instrument alongside guitars, drums, vocals, synths, violins, etc. These performers would then act as motivational role models demonstrating the creative potential of code. For this to be possible sufficient focus and effort therefore had to be placed on making it a powerful instrument whilst still keeping it simple enough for 10 year olds to pick up. In addition to educators, I also worked directly with a variety of different artists in classrooms, art galleries, studios and venues in the early stages of Sonic Pi\u2019s development. This provided essential feedback which enabled Sonic Pi to grow and ultimately flourish as a tool for creative expression. There were a number of exciting and unexpected side effects of this dual focus on education and professional musicians. Many of the features are beneficial to both groups. For example, a lot of effort has been put into making error messages more friendly and useful (rather than being a huge complicated mess of jargon). This turns out to be very useful when you write a bug while performing in front of thousands of people. Additionally, functionality such as playing studio quality audio samples, adding audio effects, providing access to live audio from the microphone all turn out to make the learning experience more fun, rewarding and ultimately meaningful. The Sonic Pi community continues to grow and share amazing code compositions, lesson plans, musical algorithms, and much more. Much of this happens on our friendly forum in_thread (in-thread.sonic-pi.net) which is home to a very diverse group of people that includes educators, musicians, programmers, artists and makers. It is a real joy to see people learn to use code to express themselves in new ways and for that in turn to inspire others to do the same. Some fun capabilities From a Computer Science perspective, Sonic Pi provides you with the building blocks to teach you the basics as found in the UK's curriculum such as sequencing, iteration, conditionals, functions, data structures, algorithms, etc. However, it also builds on a number of important and relevant concepts which have become adopted in mainstream industry such as concurrency, events, pattern matching, distributed computing and determinism - all whilst keeping things simple enough to explain to a 10 year old child. Der Einstieg ist ganz einfach: play 70 A melody can be constructed with one more command, sleep: play 72 sleep 0.5 play 75 sleep 0.5 play 79 In this example, we play the note 70 (roughly the 70th note on a piano), wait for 1 second, play note 72, wait for half a second and then play note 75. What's interesting here is that with just two commands we have access to pretty much all of Western notation (which notes to play and when) and learners can code any melody they've ever heard. This leads to huge variety in expressive outcomes whilst focussing on the same computing concept: sequencing in this case. Taking ideas from the professional music world, we can also play back any recorded sound. Sonic Pi can play any audio file on your computer but also has a number of sounds built-in to make things easy to get started: sample :loop_amen This code will play back the drum break which was a pillarstone to early hip-hop, Drum and Bass and Jungle. For example, a number of early hip-hop artists played this drum break back at half speed to give it a more laid-back feeling: sample :loop_amen, rate: 0.5 In the 90s a number of music scenes burst out of new technology which enabled artists to take drum breaks like this apart and reassemble in a different order. For example: live_loop :jungle do sample :loop_amen, onset: pick sleep 0.125 end In diesem Beispiel f\u00fchren wir eine einfache Schleife mit dem Namen :jungle ein, die einen zuf\u00e4lligen Trommelschlag aus unserem Audio Sample ausw\u00e4hlt, eine achtel Sekunde wartet und dann einen weiteren Trommelschlag abspielt. Das Ergebnis ist eine endlose Folge von Trommelschl\u00e4gen zum dabei Tanzen, w\u00e4hrend Du erf\u00e4hrst, was eine Schleife ist. Unentbehrliche Kenntnisse In diesem Kapitel findest Du sehr n\u00fctzliches - nein, unentbehrliches - Wissen, um das Bestm\u00f6gliche aus Sonic Pi herauszuholen. Wir behandeln viele der verf\u00fcgbaren Tastaturk\u00fcrzel, zeigen, wie Du Deine Ergebnisse mit anderen teilen kannst, und geben Dir Tipps f\u00fcr Auftritte mit Sonic Pi. 10.1 Tastaturk\u00fcrzel Sonic Pi ist zu gleichen Teilen Musikinstrument und Programmierumgebung. Mit Tastaturk\u00fcrzeln kannst Du Sonic Pi viel effizienter und nat\u00fcrlicher spielen - insbesondere, wenn Du live vor Publikum spielst. Sehr vieles in Sonic Pi kann mit der Tastatur gesteuert werden. Je vertrauter Du mit Sonic Pi wirst, umso mehr wirst Du diese Tastaturk\u00fcrzel verwenden. Ich selbst tippe, ohne die Tastatur anzusehen (und kann Dir nur empfehlen, das Zehnfingersystem auch zu lernen). Und ich bin jedes Mal frustriert, wenn ich zur Maus greifen muss, denn das macht mich langsam. Deshalb benutze ich st\u00e4ndig Tastaturk\u00fcrzel! Wer die Tastaturk\u00fcrzel beherrscht, kann auch seine Tastatur viel effektiver benutzen und in k\u00fcrzester Zeit wirst Du programmieren wie ein Profi. Versuche aber nicht, alle auf einmal zu lernen , merke dir erst einmal die, welche du am h\u00e4ufigsten brauchst und f\u00fcge sp\u00e4ter weitere deinem Repertoire hinzu. Konsistenz auf verschiedenen Plattformen Stell Dir vor, Du lernst Klarinette. Du kannst davon ausgehen, dass alle Klarinetten aller Marken gleiche Mechaniken und Fingers\u00e4tze haben. H\u00e4tten sie das nicht, k\u00f6nntest Du nicht ohne weiteres zwischen verschiedenen Klarinetten hin- und her wechseln. Sondern m\u00fcsstest immer bei einer Marke bleiben. Ungl\u00fccklicherweise haben die drei wesentlichen Betriebssysteme (Linux, Mac OS X und Windows) alle ihre eigenen typischen Tastaturk\u00fcrzel f\u00fcr Aktionen wie z.B. Kopieren, Ausschneiden und Einf\u00fcgen. Sonic Pi nutzt diese Standards wo immer m\u00f6glich. Jedoch liegt die Priorit\u00e4t auf plattform\u00fcbergreifender Konsistenz innerhalb von Sonic Pi, nicht auf dem Versuch, die Standards der jeweiligen Plattform vollumf\u00e4nglich zu erf\u00fcllen. Das bedeutet, dass die in Sonic Pi auf dem Raspberry Pi gelernten Tastaturk\u00fcrzel ebenso auf einem Mac oder PC mit Sonic Pi funktionieren. Control und Meta F\u00fcr diese Konsistenz m\u00fcssen wir auch die Namen der Tastaturk\u00fcrzel entsprechend ausw\u00e4hlen. In Sonic Pi verwenden wir die Namen Control und Meta f\u00fcr die beiden wichtigsten Kombinationstasten. Control ( Ctrl - oder Strg f\u00fcr \"Steuerung\" auf deutschen Tastaturen) ist auf allen Plattformen gleich. Auf Linux und Windows ist Meta die Alt -Taste, w\u00e4hrend Meta auf dem Mac die Command -Taste ist. Um konsistent zu bleiben, nutzen wir den Begriff Meta - diesem musst Du mental die passende Taste Deines Betriebssystems zuordnen. Abk\u00fcrzungen Um die Dinge einfach und lesbar zu halten, werden wir die Abk\u00fcrzungen C- f\u00fcr Control und eine weitere Taste sowie M- f\u00fcr Meta und eine weitere Taste verwenden. Wenn ein Tastaturk\u00fcrzel beispielsweise erfordert, dass Du Meta und r gleichzeitig dr\u00fcckst, werden wir die Abk\u00fcrzung M-r verwenden. Der Bindestrich in der Mitte ( - ) bedeutet nur \"zur gleichen Zeit.\" Hier sind ein paar der Tastaturk\u00fcrzel, die ich am n\u00fctzlichsten finde. Starten und Stoppen Du musst nicht immer zur Maus greifen, um Deinen Code auszuf\u00fchren. Dr\u00fccke stattdessen einfach M-r zum Abspielen. Mit M-s stoppst Du die Musik. Navigation Ohne die Tastenk\u00fcrzel zur Navigation bin ich verloren. Deshalb empfehle ich Dir dringend, diese K\u00fcrzel zu lernen. Sie funktionieren besonders gut, wenn Du das Zehnfingersystem schon halbwegs beherrschst, da sie normale Buchstaben verwenden - so musst Du Deine Hand nicht zur Maus oder zu den Pfeiltasten bewegen. Mit C-a springst Du an den Anfang, mit C-e ans Ende einer Zeile. Eine Zeile nach oben geht es mit C-p , eine nach unten mit C-n , ein Zeichen vorw\u00e4rts mit C-f und eines nach hinten mit C-b . Du kannst auch alle Zeichen von der aktuellen Cursorposition bis zum Ende der Zeile mit C-k l\u00f6schen. Code aufr\u00e4umen Um Deinen Code sauber einzur\u00fccken, dr\u00fccke M-m . Hilfesystem Zum Hilfesystem kommst Du mit M-i . Noch hilfreicher ist allerdings C-i , damit wird Dir f\u00fcr das Wort, auf dem der Cursor gerade steht, sofort die passende Stelle in der Dokumentation gezeigt. Sofortige Hilfe! Eine Liste aller Tastaturk\u00fcrzel ist in Kapitel 10.2 \"Cheatsheet f\u00fcr Tastenk\u00fcrzel\" enthalten. 10.2 Cheatsheet f\u00fcr Tastaturk\u00fcrzel In diesem Abschnitt findest Du eine Zusammenfassung der wichtigsten Tastenk\u00fcrzel von Sonic Pi. In Abschnitt 10.1 erkl\u00e4rte ich Dir bereits, warum diese so n\u00fctzlich sind. Konventionen Wir verwenden die folgenden Konventionen ( Meta ist Alt auf Windows und Linux und Cmd auf dem Mac wie in 10.1 beschrieben): C-a bedeutet, die Control ( Strg auf deutschen Tastaturen) zu dr\u00fccken und zu halten, dabei a zu dr\u00fccken und danach beide Tasten wieder los zu lassen. M-r bedeutet, Meta zu dr\u00fccken und zu halten, dabei die r -Taste zu dr\u00fccken und danach beide wieder los zu lassen. S-M-z bedeutet, die Meta -Taste zu dr\u00fccken und zu halten, dann Shift zu dr\u00fccken und zu halten und schlie\u00dflich die z -Taste und alle drei Tasten gleichzeitig wieder los zu lassen. C-M-f bedeutet, Control zu dr\u00fccken und zu halten, dann Meta zu dr\u00fccken und zu halten, dann f zu dr\u00fccken und alle drei Tasten gleichzeitig wieder los zu lassen. Steuerung der Hauptanwendung M-r - Code ausf\u00fchren M-s - Code-Ausf\u00fchrung stoppen M-i - Hilfesystem ein-/ausschalten M-p - Einstellungen ein-/ausschalten M-< - Zum Puffer links wechseln M-> - Zum Puffer rechts wechseln S-M-0 - Switch to buffer 0 S-M-1 - Switch to buffer 1 ... S-M-9 - Switch to buffer 9 M-+ - Schrift des Puffers vergr\u00f6\u00dfern M-- - Schrift des Puffers verkleinern Auswahl/Kopieren/Einf\u00fcgen M-a - Alles ausw\u00e4hlen M-c - Auswahl in den Zwischenspeicher kopieren M-] - Auswahl in den Zwischenspeicher kopieren M-x - Auswahl ausschneiden und im Zwischenspeicher ablegen C-] - Auswahl ausschneiden und im Zwischenspeicher ablegen C-k - Text ab Cursor bis zum Ende der Zeile ausschneiden M-v - Inhalt des Zwischenspeichers in den Editor kopieren C-y - Inhalt des Zwischenspeichers in den Editor kopieren C-SPACE - Markierung setzen. Textauswahl ab jetzt von hier bis zum Cursor. C-g l\u00f6scht die Markierung. Text-Manipulation M-m - Gesamten Code ausrichten Tab - Aktuelle Codezeile oder Auswahl ausrichten C-l - Editor zentrieren M-/ - Aktuelle Codezeile auskommentieren C-t - Zeichen vertauschen M-u - Das n\u00e4chste Wort oder Auswahl in Gro\u00dfbuchstaben wandeln. M-l - Das n\u00e4chste Wort oder Auswahl in Kleinbuchstaben wandeln. Navigation C-a - An den Anfang der Zeile springen C-e - Ans Ende der Zeile springen C-p - Zur vorherigen Zeile springen C-n - Zur n\u00e4chsten Zeile springen C-f - Ein Zeichen vorw\u00e4rts C-b - Ein Zeichen zur\u00fcck M-f - Ein Wort nach vorne M-b - Ein Wort zur\u00fcck C-M-n - Zeile oder Auswahl nach unten schieben C-M-p - Zeile oder Auswahl nach unten schieben S-M-u - 10 Zeilen nach oben springen S-M-d - 10 Zeilen nach unten springen M-< - Zum Anfang des Puffers gehen M-> - Zum Ende des Puffers gehen L\u00f6schen C-h - Vorangegangenes Zeichen l\u00f6schen C-d - N\u00e4chstes Zeichen l\u00f6schen Fortgeschrittene Funktionen des Editors C-i - Dokumentation f\u00fcr das Wort unter dem Cursor anzeigen M-z - R\u00fcckg\u00e4ngig (\"Undo\") S-M-z - Wiederholen (\"Redo\") C-g - Escape S-M-f - Vollbildmodus ein-/ausschalten S-M-b - Buttons ein-/ausschalten S-M-l - Anzeige Protokoll-Fenster ein-/aus S-M-m - Dunkle Benutzeroberfl\u00e4che ein-/ausschalten S-M-s - Inhalt des Puffers in Datei speichern S-M-o - Datei in einen Puffer laden 10.3 Teilen In Sonic Pi geht es vor allen Dingen um das Teilen und gemeinsame Lernen. Sobald Du gelernt hast, Musik zu programmieren, kannst Du Deine Kompositionen ganz leicht mit anderen teilen: Schicke Deinen Code einfach mit einer E-Mail an Deine Freunde. Ich m\u00f6chte Dich ermuntern, Deinen Code mit anderen zu teilen , so dass sie von Deiner Arbeit lernen und Teile davon in neuen Mash-Ups verwenden k\u00f6nnen. Du hast keine Ahnung, wo Du Deine Werke am besten mit anderen teilen kannst? Ich empfehle Dir f\u00fcr Deinen Code GitHub und f\u00fcr Deine Musik SoundCloud . So erreichst Du schnell ein gro\u00dfes Publikum. Code -> GitHub GitHub wird von professionellen Entwicklern und auch K\u00fcnstlern verwendet, um Code zu teilen und zusammenzuarbeiten. Auf GitHub gibt es einen eigenen Bereich namens Gist , damit kann man besonders einfach ein neues St\u00fcck Code (egal ob fertig oder nicht) ver\u00f6ffentlichen. Mit einem Gist k\u00f6nnen dann auch andere Deinen Code \u00fcbernehmen, kommentieren und verbessern. Audio -> SoundCloud Statt Code kannst Du auch eine Musikaufnahme ver\u00f6ffentlichen und daf\u00fcr eine Audiodatei zu SoundCloud hochladen. Dort k\u00f6nnen andere Nutzer Kommentare dazu abgeben und die Musik diskutieren. Es ist empfehlenswert, bei einer Ver\u00f6ffentlichung auf Soundcloud zus\u00e4tzlich einen Link zu einem Gist mit Deinen Code in die Beschreibung aufzunehmen. Um Dein St\u00fcck aufzunehmen, dr\u00fccke den Aufnehmen -Knopf in der Werkzeugleiste, die Aufnahme startet dann sofort. Dr\u00fccke Ausf\u00fchren , um Deinen Code zu starten, wenn er nicht bereits l\u00e4uft. Wenn Du fertig bist, dr\u00fccke den blinkenden Aufnehmen -Knopf erneut. Du wirst dann nach einem Dateinamen gefragt, unter dem die Aufnahme als WAV-Datei gespeichert wird. Es gibt viele Werkzeuge, um eine WAV-Datei in ein MP3 zu wandeln, z.B. das Programm Audacity . Hoffnung Ich m\u00f6chte Dich ermuntern, Deine Arbeiten zu teilen, und hoffe sehr, dass wir uns gegenseitig neue Sonic-Pi-Tipps und -Tricks beibringen werden. Ich bin schon sehr gespannt darauf, was Du mir zeigen wirst. 10.4 Auftritte Einer der aufregendsten Aspekte von Sonic Pi ist, dass Du von nun an Code als Musikinstrument verwenden kannst. Vor Publikum zu programmieren wird damit ein neuer Weg, um Musik aufzuf\u00fchren. Das nennen wir Live-Coding . Zeig Deinen Bildschirm Wenn Du live programmierst, empfehle ich Dir, Deinem Publikum Deinen Bildschirm zu zeigen . Beim Gitarrespielen versteckst Du ja auch nicht Deine Finger und die Saiten Deines Instruments. Wenn ich zu Hause \u00fcbe, verwende ich einen Raspberry Pi und projiziere den Bildschirm mit einem kleinen Beamer an meine Wohnzimmerwand. Du k\u00f6nntest auch Deinen Fernseher oder einen Projektor in der Schule/Arbeit verwenden und eine kleine Show geben. Versuch es, das macht eine Menge Spa\u00df. Gr\u00fcnde eine Band Don't just play on your own - form a live coding band! It's a lot of fun jamming with others. One person could do beats, another ambient background, etc. Use the live_audio functionality to combine code with traditional instruments such as a guitar or a microphone. See what interesting combinations of sounds you can create with code. TOPLAP Live-Coding ist nicht wirklich neu - eine kleine Gruppe von Enthusiasten macht das schon seit Jahren, typischerweise mit selbstgebauten, individuellen Systemen. Bei TOPLAP erf\u00e4hrst Du mehr \u00fcber diese anderen Live-Coder und ihre Ger\u00e4te. Algorave Einige Live-Coder spielen auch in Nightclubs. Mehr \u00fcber dieses spezielle Genre erf\u00e4hrst Du auf Algorave .","title":"1 Willkommen bei Sonic Pi"},{"location":"#section-01","text":"Willkommen in Sonic Pi! Hoffentlich bist du ebenso gespannt darauf zu lernen, wie man mit Sonic Pi verr\u00fcckte Kl\u00e4nge machen kann, wie ich gespannt darauf bin es dir zu zeigen. Es wird eine wirklich unterhaltsame Reise werden, bei der du alles \u00fcber Musik, Synthese, Programmieren, Komposition, Auff\u00fchrung (Performance) lernen wirst - und mehr. Aber halt, wie unh\u00f6flich von mir! Darf ich mich vorstellen? Ich bin Sam Aaron der Typ, der Sonic Pi entwickelt hat. Du kannst mich unter @samaaron auf Twitter finden, und ich w\u00fcrde mich sehr freuen dich dort begr\u00fc\u00dfen zu k\u00f6nnen. Vielleicht interessierst du dich auch f\u00fcr meine Live-Coding-Performances , wo ich meine Musik mit Sonic Pi direkt vor Publikum schreibe. Wenn du irgendwelche Vorschl\u00e4ge oder Ideen zur Verbesserung von Sonic Pi hast \u2013 bitte schreibe sie mir \u2013 eure Kommentare sind sehr hilfreich. Es w\u00e4re ja schlie\u00dflich auch m\u00f6glich, dass deine Idee zu der n\u00e4chsten gro\u00dfen Funktion in Sonic Pi wird! Dieses Tutorial ist in Abschnitte aufgeteilt, die nach Themen gruppiert sind. Auch wenn ich es so geschrieben habe, dass du damit vom Anfang bis zum Ende einfach lernen kann, kannst du ebenso gut an jeder anderen Stelle einsteigen, und wieder aussteigen, ganz wie es dir gef\u00e4llt. Wenn du etwas im Tutorial vermisst, lass es mich wissen, und ich werde \u00fcberlegen, wie ich das in zuk\u00fcnftige Versionen einbauen kann. Anderen beim Live-Coding zuzusehen ist eine wirklich gro\u00dfartige Art zu lernen. Ich streame regelm\u00e4\u00dfig live auf http://youtube.com/samaaron . Also schau gerne vorbei, sag Hallo und stell' mir jede Menge Fragen :-) Ok, legen wir los \u2026","title":"1 Willkommen bei Sonic Pi"},{"location":"#section-01-1","text":"Einer der aufregendsten Aspekte von Sonic Pi ist, dass du Code live schreiben und ver\u00e4ndern kannst, um Musik zu machen. Ganz so wie du auch mit einer Gitarre auftreten w\u00fcrdest. Mit anderen Worten: Wenn du etwas \u00dcbung hast, kannst du Sonic Pi mit auf die B\u00fchne nehmen und jammen.","title":"1.1 Live-Coding"},{"location":"#mach-den-kopf-frei","text":"Bevor wir in diesem Tutorial in die ernsten Details von Sonic Pi eintauchen, m\u00f6chte ich dir erst einmal zeigen, wie sich das anf\u00fchlt live Musik zu programmieren. Keine Sorge, wenn du nicht alles (oder auch nur irgend etwas davon) verstehst. Das macht nichts. Versuch' an deinem Platz zu bleiben - und genie\u00dfe ...","title":"Mach den Kopf frei"},{"location":"#ein-live-loop","text":"Lass uns loslegen. Kopiere den folgenden Code in einen leeren Puffer: live_loop :flibble do sample :bd_haus, rate: 1 sleep 0.5 end Jetzt klicke die Ausf\u00fchren -Schaltfl\u00e4che und du wirst eine sch\u00f6ne Bass-Drum h\u00f6ren, die schnell vor sich hin h\u00e4mmert. Mit einem Klick auf den Stopp -Schaltfl\u00e4che h\u00f6rt die Musik wieder auf. Aber klicke bitte noch nicht gleich darauf ... probiere stattdessen die folgenden Schritte aus: Lass den Bass-Drum-Sound weiter laufen Setze den Wert von sleep von 0.5 auf einen h\u00f6heren Wert, etwa 1 . Klicke wieder die Ausf\u00fchren -Schaltfl\u00e4che Achte darauf, wie die Geschwindigkeit des Bass-Drum-Beats sich ver\u00e4ndert hat. Und schlie\u00dflich, merke dir diesen Moment ! Dies war das erste Mal, dass du mit Sonic Pi live Programm-Code geschrieben hast. Und es ist wahrscheinlich, dass es nicht das letzte Mal gewesen sein wird \u2026 Ok, das war einfach. F\u00fcgen wir etwas anderes hinzu. \u00dcber sample :bd_haus f\u00fcge die Zeile sample :ambi_choir, rate: 0.3 ein. Dein Programm-Code sollte dann so aussehen: live_loop :flibble do sample :ambi_choir, rate: 0.3 sample :bd_haus, rate: 1 sleep 1 end So, jetzt spiele damit herum. Ver\u00e4ndere die Werte f\u00fcr rate: \u2013 was passiert, wenn du hohe, niedrige oder negative Zahlen eintr\u00e4gst? Achte darauf, wie sich eine sehr kleine \u00c4nderung des rate: -Wertes auf das :ambi_choir -Sample auswirkt (z. B. 0.29)? Was passiert wenn du einen wirklich kleinen sleep -Wert eintr\u00e4gst? Probiere aus, ob du es so schnell machen kannst, dass du einen Stopp und eine Fehlermeldung deines Computers ausl\u00f6st, weil er nicht mehr hinterher kommt. (Wenn das geschieht, nimm einfach wieder einen gr\u00f6\u00dferen Wert f\u00fcr sleep und klicke wieder auf Ausf\u00fchren ). Versuche eine Zeile mit dem sample -Code auszukommentieren, indem du ein # an ihren Anfang schreibst: live_loop :flibble do sample :ambi_choir, rate: 0.3 # sample :bd_haus, rate: 1 sleep 1 end Beachte wie das Zeichen den Computer anweist die Zeile zu ignorieren - wir h\u00f6ren das Ergebnis des Befehls in dieser Zeile nicht mehr. Was hinter einem # steht ist ein Kommentar. Wir k\u00f6nnen dieses Zeichen in Sonic Pi benutzen, um Dinge schnell aus dem Mix zu entfernen und sp\u00e4ter wieder hinzuzuzuf\u00fcgen. Abschlie\u00dfend m\u00f6chte ich dir etwas unterhaltsames zum Spielen geben. Nimm den Code unten und kopiere ihn in einen freien Puffer. Versuche nicht mehr davon zu verstehen, als dass da zwei Loops sind \u2013 zwei Schleifen, die gleichzeitig laufen und sich endlos wiederholen. Jetzt tue, was du am besten kannst - experimentiere und spiele damit herum. Hier ein paar Vorschl\u00e4ge: \u00c4ndere die blauen Werte hinter rate: und achte darauf, wie sich das Sample ver\u00e4ndert. \u00c4ndere die sleep -Zeiten, und achte darauf, wie die beiden Schleifen mit unterschiedlicher Geschwindigkeit aneinander vorbei laufen. Versuche die auskommentierte Sample-Zeile zu aktivieren (entferne das # ) und genie\u00dfe den Klang einer umgekehrt abgespielten Gitarre. Probiere, die blauen Werte f\u00fcr mix: auf Werte zwischen 0 (nicht im Mix) und 1 (voll im Mix) zu \u00e4ndern. Denke daran Ausf\u00fchren zu klicken, dann h\u00f6rst du sofort beim n\u00e4chsten Durchlauf eines Loops deine \u00c4nderungen. Wenn irgendwas schiefgeht \u2013 macht nichts! Klicke auf Stopp , l\u00f6sche den kaputten Code im Puffer und fange mit einer frischen Kopie noch einmal von vorn an zu jammen. Am schnellsten lernst du, wenn du Fehler machst\u2026 live_loop :guit do with_fx :echo, mix: 0.3, phase: 0.25 do sample :guit_em9, rate: 0.5 end # sample :guit_em9, rate: -0.5 sleep 8 end live_loop :boom do with_fx :reverb, room: 1 do sample :bd_boom, amp: 10, rate: 1 end sleep 8 end Spiele solange herum und experimentiere, bis deine Neugierde einsetzt und du dich fragst, wie das hier alles eigentlich wirklich funktioniert, und was man noch so alles damit anstellen kann. Du bist jetzt bereit f\u00fcr den Rest dieses Tutorials. Also, worauf wartest du\u2026","title":"Ein Live-Loop"},{"location":"#section-01-2","text":"Sonic PI hat eine sehr einfache Oberfl\u00e4che f\u00fcr das Programmieren von Musik. Schauen wir sie uns einmal genauer an. A - Wiedergabe-Steuerung B - Editor-Steuerung C - Info und Hilfe D - Code-Editor E - Einstellungen F - Protokoll-Fenster G - Hilfe-System H - Oszilloskop F - Protokoll-Fenster","title":"1.2 Die Programmoberfl\u00e4che von Sonic Pi"},{"location":"#a-wiedergabe-steuerung","text":"Mittels diesen pinkfarbenen Schaltfl\u00e4chen kannst du Kl\u00e4nge abspielen und stoppen. Die Ausf\u00fchren -Schaltfl\u00e4che startet den Programm-Code im Editor, Stopp h\u00e4lt den laufenden Programm-Code an, Speichern schreibt den Code in eine Datei und Aufnehmen nimmt die Kl\u00e4nge, die gerade zu h\u00f6ren sind (in einer WAV-Datei) auf.","title":"A. Wiedergabe-Steuerung"},{"location":"#b-editor-steuerung","text":"Diese orangenen Schaltfl\u00e4chen erlauben dir, den Code-Editor zu manipulieren. Mit den Size + und Size - Kn\u00f6pfen kannst du den Text vergr\u00f6\u00dfern oder verkleinern.","title":"B. Editor-Steuerung"},{"location":"#c-information-und-hilfe","text":"Die blauen Schaltfl\u00e4chen bieten dir Zugriff auf Informationen, die Hilfe und die Voreinstellungen. Der Info -Schalter \u00f6ffnet ein Fenster mit Informationen \u00fcber Sonic Pi selbst - das Entwickler-Team, Geschichte, Mitwirkende und Community. Der Help -Schalter zeigt/verbirgt das eingebaute Hilfesystem ( F ) und Prefs zeigt/verbirgt das Fenster, wo du einige grunds\u00e4tzliche Einstellungen vornehmen kannst.","title":"C. Information und Hilfe"},{"location":"#d-code-editor","text":"In diesem Bereich schreibst du deinen Code und komponierst und f\u00fchrst deine Musik auf. Es ist ein einfacher Texteditor, in dem du Code schreiben, l\u00f6schen, ausschneiden und einf\u00fcgen kannst u.s.w. Stelle es dir als sehr einfache Version von Word oder Google Docs vor. Der Editor f\u00e4rbt bestimmte Begriffe automatisch ein, je nachdem, welche Bedeutung sie innerhalb des Codes haben. Am Anfang mag dir das vielleicht ein wenig merkw\u00fcrdig erscheinen, aber du wirst es bald sehr n\u00fctzlich finden. Zum Beispiel erkennst du Zahlen sofort daran, dass sie blau sind.","title":"D. Code-Editor"},{"location":"#e-einstellungen","text":"Sonic Pi enth\u00e4lt eine Reihe von ver\u00e4nderbaren Einstellungen, die \u00fcber den Prefs -Schalter im Info- und Hilfe-Men\u00fc erreicht werden k\u00f6nnen. In den Einstellungen sind einige Optionen verf\u00fcgbar, die ge\u00e4ndert werden k\u00f6nnen, darunter z. B.: Wechsel in den Mono-Modus, Tauschen der Stereokan\u00e4le, Einstellung der Ausf\u00fchrlichkeit der Protokoll-Ausgabe und ein Volumen-Regler. Auf einem Raspberry Pi kannst du hier auch das Ausgabemodul f\u00fcr den Ton ausw\u00e4hlen.","title":"E. Einstellungen"},{"location":"#f-protokoll-fenster","text":"Wenn du deinen Programm-Code laufen l\u00e4sst, siehst du im Protokoll-Fenster, was das Programm gerade tut. Standardm\u00e4\u00dfig siehst du eine Nachricht f\u00fcr jeden erzeugten Klang und die exakte Zeit, wann der Klang ausgel\u00f6st wurde. Bei der Suche nach Fehlern (Debugging) in deinem Programm-Code kann das sehr hilfreich sein, und du verstehst schneller, was dein Code macht.","title":"F. Protokoll-Fenster"},{"location":"#g-hilfe-system","text":"Eines der wichtigsten Elemente des Sonic Pi Programmfensters ist das Hilfe-System, das am unteren Ende des Fensters auftaucht. Du kannst es ein- und ausblenden, indem du den blauen Hilfe -Schalter klickst. Das Hilfe-System zeigt Hilfe und Informationen zu allen Aspekten von Sonic Pi an, einschlie\u00dflich dieses Tutorials, einer Liste der mitgelieferten Synthesizer, Samples, Beispiele, Effekte (FX) sowie eine komplette Liste aller Funktionen (Sprachbefehle), die Sonic Pi zum Coden von Musik bereitstellt.","title":"G. Hilfe-System"},{"location":"#h-oszilloskop","text":"Das Oszilloskop kann dir die T\u00f6ne die du h\u00f6rst, anzeigen. Du kannst leicht erkennen, dass die S\u00e4gezahnwelle wie eine S\u00e4ge aussieht und der Beep wie eine kurvige Sinus-Welle. Du kannst auch den Unterschied zwischen lauten und leisen T\u00f6nen anhand der Gr\u00f6\u00dfe der Linien erkennen. Es gibt drei Oszilloskope, mit denen du spielen kannst. Standard ist ein aus dem linken und rechten Kanal kombiniertes Oszilloskop, es gibt daneben ein Stereo-Oszilloskop, das beide Kan\u00e4le einzeln anzeigt. Und zu guter Letzt gibt es das Lissajous-Oszilloskop, das dir die Phasen-Beziehung zwischen dem linken und rechten Kanal anzeigt - es erm\u00f6glicht dir auch das Zeichnen von Bildern mit Kl\u00e4ngen (https://de.wikipedia.org/wiki/Lissajous-Figur).","title":"H. Oszilloskop"},{"location":"#i-protokoll-fenster","text":"Alle internen und externen Ereignisse (in Sonic Pi Cues genannt) werden automatisch im Cue-Protokoll angezeigt. Bet\u00e4tigst du zum Beispiel einen verbundenen MIDI-Controller, erscheint die Bezeichnung des bet\u00e4tigten Schalters/Reglers und des Controllers im Protokoll. Sobald du die Grundlagen der Erzeugung und Hervorbringung von Kl\u00e4ngen gemeistert hast, wirst du auch Cues f\u00fcr Kl\u00e4nge oder ganze Abschnitte von Kl\u00e4ngen mit diesen Mitteln steuern wollen. Cue-Ereignisse (cue events) sind Indikatoren daf\u00fcr, dass etwas geschehen ist. Zum Beispiel schickt ein Live-Loop jedes Mal wenn er eine Runde ausf\u00fchrt ein solches Cue-Ereignis, das im Cue-Protokoll angezeigt wird. Auch externe Ereignisse, wie MIDI-Signale von angeschlossenen MIDI-Ger\u00e4ten, und OSC-Signale von anderen Programmen und Computern werden im Cue-Protokoll angezeigt. Zudem ist es auch m\u00f6glich mithilfe der cue -Funktion Eintr\u00e4ge im Protokoll zu generieren. In den Abschnitten 10 bis 12 lernst du im einzelnen, wie du Protokoll-Eintr\u00e4ge als Trigger (Ausl\u00f6ser) f\u00fcr andere Abl\u00e4ufe benutzen kannst.","title":"I. Protokoll-Fenster"},{"location":"#section-01-3","text":"Sonic Pi ermutigt dich etwas \u00fcber Computer und Musik zu lernen - durch Spielen und Experimentieren. Das aller Wichtigste ist, dass du Spa\u00df hast, und bevor du es \u00fcberhaupt bemerkst, wirst du zuf\u00e4llig gelernt haben Code zu schreiben, Musik zu komponieren und aufzuf\u00fchren.","title":"1.3 Lernen durch Spielen"},{"location":"#es-gibt-keine-fehler","text":"Wo wir gerade dabei sind, m\u00f6chte ich dir noch einen Rat geben, etwas das ich in den Jahren, in denen ich Musik live programmiert habe gelernt habe - es gibt keine Fehler, nur Gelegenheiten . Ich habe das oft im Bezug auf Jazz geh\u00f6rt, aber es trifft ebenso gut auf Live-Coding zu. Es spielt keine Rolle, wie viel Erfahrung du hast, ob du ein absoluter Anf\u00e4nger oder ein erfahrender Live-Coder bist. Du wirst Code laufen lassen, der vollkommen unerwartete Ergebnisse hervorbringt. Kann sein, dass es unglaublich cool klingt - dann mache da weiter. Wie dem auch sei, kann sein, dass es schrecklich klingt und vollkommen fehl am Platz ist. Es ist egal, wenn das passiert, wichtig ist, was du dann damit als N\u00e4chstes tust. Nimm den Klang, bearbeite ihn und verwandle ihn in etwas Tolles. Die Menge wird durchdrehen .","title":"Es gibt keine Fehler"},{"location":"#beginne-einfach","text":"Wenn du lernst, willst du die tollen Sachen vielleicht am liebsten sofort machen. Halte solche Gedanken fest, aber sieh sie als ein Ziel an, welches du etwas sp\u00e4ter erreichen wirst. Denke zun\u00e4chst erst einmal an die einfachste Sache, die du schreiben kannst, die dir Spa\u00df machen w\u00fcrde und dir lohnend erscheint; diese Sache ist ein kleiner Schritt auf dem Weg zu den faszinierenden Dingen, die dir im Kopf herum gehen. Wenn dir die Idee zu diesem einfachen Schritt klar ist, versuche ihn umzusetzen, spiele damit herum und finde heraus, auf was f\u00fcr neue Ideen du dadurch kommst. Du wirst bald sehr viel Spa\u00df daran haben und echte Fortschritte machen. Stelle sicher, dass du deine Werke mit anderen teilst!","title":"Beginne einfach"},{"location":"#section-02","text":"Ok, genug der Einf\u00fchrung - lasst uns Kl\u00e4nge machen. In diesem Abschnitt behandeln wir die Grundlagen des Triggerns (Ausl\u00f6sen) und Manipulierens von Synths. Synth ist die Kurzform von Synthesizer - dem genauen Wortlaut f\u00fcr etwas, das Kl\u00e4nge erzeugt. Typischerweise sind Synths ziemlich kompliziert im Gebrauch, vor allem analoge Synths wie Eurorack-Module, untereinander verbunden mit einem Durcheinander von Kabeln. Sonic Pi gibt dir eine Vielzahl solcher M\u00f6glichkeiten auf eine einfache und gut zug\u00e4ngliche Art. Lass dich nicht t\u00e4uschen von der einfachen Programmoberfl\u00e4che von Sonic Pi. Wenn du willst, kannst du damit sehr tief in sehr ausgekl\u00fcgelte Klangmanipulationen eintauchen. Also festhalten...","title":"2 Synthesizer"},{"location":"#section-02-1","text":"Sieh dir den folgenden Code an: play 70 Damit f\u00e4ngt alles an. Leg los, kopiere und setze das in das Code-Fenster oben im Programm ein (der gro\u00dfe wei\u00dfe Bereich unter der Ausf\u00fchren-Schaltfl\u00e4che). Nun klicke auf Ausf\u00fchren...","title":"2.1 Deine ersten Beeps"},{"location":"#beep","text":"Stark. Klicke die Schaltfl\u00e4che nochmal. Und nochmal. Und nochmal... Wow, verr\u00fcckt, ich bin sicher, du k\u00f6nntest das den ganzen Tag lang machen. Aber halt, bevor du dich in einem endlosen Strom von Piepst\u00f6nen verlierst, versuche es mit einer anderen Zahl: play 75 H\u00f6rst du den Unterschied? Nimm eine kleinere Zahl: play 60 Also, niedrigere Zahlen machen tiefere T\u00f6ne und h\u00f6here Zahlen h\u00f6here T\u00f6ne. Wie bei einem Klavier erzeugen, von links nach rechts gesehen, die niedrigeren Tasten weiter links tiefere T\u00f6ne als die h\u00f6heren Tasten weiter rechts, die h\u00f6here T\u00f6ne erzeugen. Es ist gut zu wissen, dass das C in der vierten Oktave mit der Zahl 60 bezeichnet wird. play 60 spielt also ein C der vierten Oktave. Um den n\u00e4chsth\u00f6heren Ton rechts davon auf der Klaviatur zu spielen, musst du 1 zu 60 addieren und play 61 schreiben. Das ist dann die schwarze Taste rechts vom C, ein Cis (oder C# in englischer Schreibweise). Um nun ein D, den n\u00e4chst h\u00f6heren Ton rechts davon, zu spielen, schreibe play 62 . Keine Sorge , wenn du keine Ahnung hast, was das alles bedeutet. Mir ging es genauso als ich anfing. F\u00fcr den Beginn reicht es v\u00f6llig zu wissen, niedrigere Zahlen bedeuten tiefere Kl\u00e4nge und h\u00f6here Zahlen bedeuten h\u00f6here Kl\u00e4nge .","title":"Beep!"},{"location":"#akkorde","text":"Eine Note zu spielen kann ganz lustig sein, aber mehrere zur selben Zeit zu spielen ist noch besser. Versuche es: play 72 play 75 play 79 Jazzig! Wenn du also mehrere play s hinschreibst, spielen sie alle zur selben Zeit. Probiere selbst aus - welche Nummern klingen gut zusammen? Welche klingen f\u00fcrchterlich? Experimentiere, erforsche und finde es f\u00fcr dich selbst heraus.","title":"Akkorde"},{"location":"#melodie","text":"Einzelne Noten und Akkorde zu spielen macht Spa\u00df - aber wie w\u00e4re es mit einer Melodie? Was, wenn du eine Note nach der anderen spielen wolltest und nicht alle zur selben Zeit? Also, das ist ganz einfach, du brauchst nur ein sleep zwischen den Noten: play 72 sleep 1 play 75 sleep 1 play 79 Wie h\u00fcbsch, ein kleines Arpeggio. Was bedeutet die 1 in sleep 1 ? Sie gibt die Dauer von sleep an. Tats\u00e4chlich bedeutet das: Schlafe f\u00fcr einen Schlag. Aber vorl\u00e4ufig k\u00f6nnen wir uns vorstellen, dass es bedeutet: Schlafe f\u00fcr eine Sekunde. Wie k\u00f6nnten wir unser Arpeggio schneller ablaufen lassen? Dazu brauchen wir k\u00fcrzere Werte f\u00fcr sleep. Wie w\u00e4re es z. B. mit der H\u00e4lfte, also 0.5 : play 72 sleep 0.5 play 75 sleep 0.5 play 79 Achte darauf, wie die Melodie nun schneller spielt. Probiere es f\u00fcr dich selbst aus, \u00e4ndere die Zeiten - verwende unterschiedliche Zeiten und Noten. Versuche einmal Zwischennoten wie play 52.3 und play 52.63 . Es gibt \u00fcberhaupt keinen Grund, nur ganze Zahlen zu verwenden. Spiel damit herum und hab Spa\u00df dabei. Beachte dabei, dass Computer grunds\u00e4tzlich die englische Schreibweise f\u00fcr Zahlen verwenden - setze also stets einen Punkt vor die Nachkommastellen (sic!), kein Komma!","title":"Melodie"},{"location":"#traditionelle-notennamen","text":"Beachte f\u00fcr das folgende, dass Sonic Pi die englischen Notennamen verwendet, Fis ist F sharp oder auch F# und Fes ist F flat bzw. Fb . Die Note H hei\u00dft im Englischen B . F\u00fcr die unter euch, die die musikalische Notation schon ein wenig kennen (keine Sorge, wenn nicht - du brauchst es nicht unbedingt) - vielleicht m\u00f6chtet ihr eine Melodie mit Notennamen anstelle von Zahlen schreiben, also C oder F#. Auch das geht mit Sonic Pi. Du kannst folgendes machen: play :C sleep 0.5 play :D sleep 0.5 play :E Denk daran, direkt vor den Notennamen einen Doppelpunkt : zu stellen, sodass dieser sich Pink f\u00e4rbt. Du kannst ebenfalls die Oktave festlegen, indem du eine Zahl direkt hinter den Notennamen schreibst: play :C3 sleep 0.5 play :D3 sleep 0.5 play :E4 Wenn du eine Note um einen Halbton erh\u00f6hen willst, f\u00fcge ein s hinzu, also play :Fs3 . Und wenn du eine Note um einen Halbton verringern m\u00f6chtest, f\u00fcge ein b an, also play :Eb3 . Es gibt auch eine praktische Abk\u00fcrzung f\u00fcr eine Pause (eine musikalische Art zu sagen, dass anstelle einer Note nichts gespielt werden soll) mit :r , :rest oder nil . Jetzt spiel' verr\u00fcckt und baue dir deine eigenen Melodien.","title":"Traditionelle Notennamen"},{"location":"#section-02-2","text":"Genauso wie es dich steuern l\u00e4sst, welche Noten du erzeugst und welche Samples du abspielst, bietet dir Sonic Pi eine ganzen Bandbreite von Optionen, um die Kl\u00e4nge zu gestalten und zu steuern. Wir werden viele davon in diesem Tutorial behandeln, und f\u00fcr jede Option gibt es eine ausf\u00fchrliche Dokumentation im Hilfe-Fenster. F\u00fcr den Moment werden wir uns zun\u00e4chst zwei der n\u00fctzlichsten ansehen: Amplitude (Lautst\u00e4rke) und Pan (Panorama). Aber vorher will ich kurz erkl\u00e4ren, was Optionen eigentlich sind.","title":"2.2 Synth-Optionen"},{"location":"#optionen","text":"Die Synths von Sonic Pi lassen sich \u00fcber verschiedene Optionen (oder kurz: Opts) ver\u00e4ndern. Opts sind Regler, die an play oder sample \u00fcbergeben werden; sie ver\u00e4ndern und steuern unterschiedliche Aspekte der Kl\u00e4nge, die du h\u00f6rst. Jeder Synth hat seinen eigenen Satz Opts, um den Klang fein einzustellen. Es gibt auch Opts, die f\u00fcr viele Kl\u00e4nge identisch sind, z.B. amp: und H\u00fcllkurven-Opts (die wir in einer anderen Sektion besprechen). Opts bestehen aus zwei Teilen, ihrem Namen (der Name des Reglers) und ihrem Wert (der Wert, auf den du den Regler setzten m\u00f6chtest). Zum Beispiel k\u00f6nntest du eine Option mit dem Namen cheese: haben, der du den Wert 1 geben m\u00f6chtest. Opts werden den Aufrufen von play und sample nach einem Komma , \u00fcbergeben, dem der Name der Option folgt, etwa amp: (vergiss den Doppelpunkt : nicht), dann eine Leerstelle und schlie\u00dflich der Wert der Option. Zum Beispiel: play 50, cheese: 1 ( cheese: ist keine g\u00fcltige Option, wir nehmen sie hier nur als Beispiel). Du kannst mehrere Opts hintereinander schreiben, indem du sie jeweils mit einem weiteren Komma abtrennst: play 50, cheese: 1, beans: 0.5 Die Reihenfolge der Opts spielt keine Rolle, so dass die folgende Zeile h\u00e4tte dasselbe Ergebnis: play 50, beans: 0.5, cheese: 1 Opts, die der Synth nicht kennt, ignoriert er einfach. (wie cheese und beans , die ja nun wirklich alberne Namen f\u00fcr Optionen sind!) Wenn du aus Versehen zweimal dieselbe Opt mit unterschiedlichen Werten benutzt, gewinnt die letzte. Im folgenden Beispiel wird beans den Wert 2 bekommen und nicht 0.5: play 50, beans: 0.5, cheese: 3, eggs: 0.1, beans: 2 Viele Dinge in Sonic Pi akzeptieren Optionen, also verbringe ein wenig Zeit damit zu lernen, wie du sie einsetzen kannst, und du wirst bald startklar sein! Spielen wir mal mit unserer ersten Opt: amp: .","title":"Optionen"},{"location":"#amplitude","text":"Die Amplitude ist wie der Computer die Lautheit eines Klangs repr\u00e4sentiert. Eine hohe Amplitude bringt einen lauten Klang hervor , und eine niedrige Amplitude ergibt einen leisen Klang . So wie Sonic Pi Zahlen dazu benutzt, um Zeit und T\u00f6ne darzustellen, bildet es auch die Lautst\u00e4rke mit Hilfe von Zahlen ab. Eine Amplitude von 0 bedeutet Stille (du wirst nichts h\u00f6ren), eine Amplitude von 1 steht f\u00fcr normale Lautst\u00e4rke. Du kannst die Amplitude aufdrehen auf 2, 10, 100. Aber Vorsicht: Wenn die Amplitude aller gemeinsamen Kl\u00e4nge zu hoch wird, setzt Sonic Pi einen so genannten Kompressor ein, der sie zusammen quetscht, damit die Kl\u00e4nge nicht zu laut f\u00fcr dein Ohr werden. Oft klingt das dann matschig und schr\u00e4g. Verwende also lieber niedrige Amplituden, das hei\u00dft im Bereich zwischen 0 und 0.5, um Kompression zu verhindern.","title":"Amplitude"},{"location":"#amp-aufdrehen","text":"Um die Amplitude eines Klangs zu \u00e4ndern, setze die Opt amp: ein. Um zum Beispiel mit halber Amplitude abzuspielen \u00fcbergebe 0.5: play 60, amp: 0.5 F\u00fcr die doppelte Amplitude \u00fcbergebe 2: play 60, amp: 2 Die amp: -Opt beeinflusst nur den Aufruf von play , mit der sie unmittelbar zusammenh\u00e4ngt. Das hei\u00dft, in dem folgenden Beispiel wird der erste Aufruf von play mit halber Lautst\u00e4rke gespielt und der zweite wieder mit der Standardlautst\u00e4rke (1): play 60, amp: 0.5 sleep 0.5 play 65 Nat\u00fcrlich kannst du f\u00fcr jeden Aufruf von play andere Werte f\u00fcr amp: festlegen: play 50, amp: 0.1 sleep 0.25 play 55, amp: 0.2 sleep 0.25 play 57, amp: 0.4 sleep 0.25 play 62, amp: 1","title":"Amp aufdrehen"},{"location":"#panning","text":"Eine weitere interessante Opt ist pan: . Ihr Wert gibt an, aus welcher Richtung der Klang kommt, wenn wir in Stereo h\u00f6ren. Panning nach links bedeutet, dass du denKlang aus dem linken Lautsprecher und Panning nach rechts, dass du ihn aus dem rechten Lautsprecher h\u00f6rst. F\u00fcr unsere Werte benutzen wir -1 , um den Klang ganz nach links zu schieben, 0 steht f\u00fcr die Mitte und mit 1 schieben wir den Klang ganz nach rechts. Nat\u00fcrlich k\u00f6nnen wir jeden Wert zwischen -1 und 1 verwenden, um die Kl\u00e4nge exakt im Stereofeld zu positionieren. Lasst uns einen Beep nur aus dem linken Lautsprecher abspielen: play 60, pan: -1 Jetzt aus dem rechten Lautsprecher: play 60, pan: 1 Nun wollen wir den Klang aus der Mitte zwischen beiden Lautsprechern herauskommen lassen (die Standardposition): play 60, pan: 0 Jetzt leg' einfach los und ver\u00e4ndere die Amplitude und das Panning deiner Kl\u00e4nge!","title":"Panning"},{"location":"#section-02-3","text":"Bisher hatten wir viel Spa\u00df damit Piept\u00f6ne zu erzeugen. Aber wahrscheinlich langweilt es dich langsam, immer wieder denselben Klang zu h\u00f6ren. Ist das alles, was Sonic Pi zu bieten hat? Live-Coding kann doch sicher mehr als nur einen einfachen Piepton zu spielen? Aber klar doch! In diesem Abschnitt schauen wir uns die aufregende Vielfalt der Kl\u00e4nge, die uns Sonic Pi bietet, an.","title":"2.3 Synths wechseln"},{"location":"#synthesizer","text":"Sonic Pi verf\u00fcgt \u00fcber eine ganze Palette unterschiedlicher Instrumente, die es Synths nennt (kurz f\u00fcr Synthesizer - Klangerzeuger ). Wohingegen Samples bereits aufgenommene Kl\u00e4nge sind. Synths erzeugen neue Kl\u00e4nge, je nachdem, wie du sie steuerst (was wir sp\u00e4ter in diesem Tutorial untersuchen werden). Die Synths in Sonic Pi sind sehr kraftvoll und ausdrucksstark, und du wirst viel Spa\u00df damit haben sie zu erforschen und damit zu spielen. Lass uns zuerst lernen, wie ein Synth ausgew\u00e4hlt wird, um ihn zu verwenden.","title":"Synthesizer"},{"location":"#brummende-sagen-und-propheten","text":"Ein lustiger Klang ist die S\u00e4gezahn-Welle - probieren wir es mal aus: use_synth :saw play 38 sleep 0.25 play 50 sleep 0.25 play 62 Nehmen wir einen anderen Klang - den Prophet : use_synth :prophet play 38 sleep 0.25 play 50 sleep 0.25 play 62 Wie w\u00e4re es beide Kl\u00e4nge zu verbinden? Zuerst nacheinander: use_synth :saw play 38 sleep 0.25 play 50 sleep 0.25 use_synth :prophet play 57 Jetzt mehrere T\u00f6ne gleichzeitig (keine Pausen mit sleep zwischen aufeinander folgenden Aufrufen von play ): use_synth :tb303 play 38 use_synth :dsaw play 50 use_synth :prophet play 57 Achte darauf, wie das use_synth -Kommando nur die nachfolgenden play -Kommandos beeinflusst. Stell dir das wie einen gro\u00dfen Schalter vor - neue Aufrufe von play werden immer den Synth benutzen, auf den der Schalter gerade zeigt. Du kannst diesen Schalter mit use_synth auf einen anderen Synth umschalten.","title":"Brummende S\u00e4gen und Propheten"},{"location":"#synths-entdecken","text":"Um zu entdecken welche Synths Sonic Pi f\u00fcr dich zum Spielen bereith\u00e4lt, schau im Synths-Option im Men\u00fc links unten im Hilfe-Fenster nach (gleich neben FX ). Es gibt \u00fcber 20 zur Auswahl. Hier sind einige meiner Favoriten: :prophet :dsaw :fm :tb303 :pulse Spiele ein bisschen herum und wechsle die Synths, w\u00e4hrend du spielst . Kombiniere unterschiedliche Synths, um neue Kl\u00e4nge zu erzeugen, oder setze sie f\u00fcr unterschiedliche Sektionen in deinem St\u00fcck ein.","title":"Synths entdecken"},{"location":"#section-02-4","text":"In einem fr\u00fcheren Abschnitt haben wir gesehen, wie wir mit dem sleep -Kommando steuern k\u00f6nnen, dass unsere Kl\u00e4nge ausgel\u00f6st (getriggert) werden. Bislang konnten wir aber noch nicht die Dauer unserer K\u00e4nge steuern. Daf\u00fcr uns einfache und doch m\u00e4chtige Mittel zur Steuerung der Dauer unserer Kl\u00e4nge zu geben, verwendet Sonic Pi den Begriff der ADSR-H\u00fcllkurve (wir werden sp\u00e4ter in diesem Abschnitt die genaue Bedeutung von ADSR behandeln). Eine H\u00fcllkurve bietet f\u00fcr die Steuerung zwei praktische Eigenschaften: Steuerung der Dauer eines Klanges Steuerung der Lautst\u00e4rke eines Klanges","title":"2.4 Dauer bei H\u00fcllkurven"},{"location":"#dauer","text":"Die Dauer beschreibt, wie lange ein Klang anh\u00e4lt. Eine l\u00e4ngere Dauer bedeutet, dass du den Klang l\u00e4nger h\u00f6ren kannst. Alle Kl\u00e4nge in Sonic Pi haben eine steuerbare H\u00fcllkurve, und die gesamte Dauer dieser H\u00fcllkurve bestimmt die Dauer des Klanges. Daher steuerst du mit der Dauer der H\u00fcllkurve die Dauer des Klanges.","title":"Dauer"},{"location":"#amplitude_1","text":"Die ADSR-H\u00fcllkurve steuert nicht nur die Dauer, sondern erm\u00f6glicht dir auch eine genaue Kontrolle \u00fcber den Verlauf der Lautst\u00e4rke eines Klanges . Alle h\u00f6rbaren Kl\u00e4nge beginnen und enden mit Stille; alles was dazwischen liegt, ist nicht still. H\u00fcllkurven erlauben es dir, die Lautst\u00e4rke der h\u00f6rbaren Anteile des Klanges zu verschieben, zu verl\u00e4ngern und zu verk\u00fcrzen. Es ist so, als w\u00fcrdest du eine andere Person anweisen, wie sie mit dem Lautst\u00e4rkeregler einen Gitarren-Verst\u00e4rker lauter und leiser drehen soll. Du k\u00f6nntest sie z. B. bitten, \"fang mit Stille an, dreh die Lautst\u00e4rke langsam bis zum Anschlag hoch, lasse es eine Weile so und blende dann schnell runter, so dass es wieder still wird\". Genau diese Anweisungen zu geben erlaubt dir Sonic Pi mit H\u00fcllkurven. Wie wir bereits gesehen haben, bedeutet eine Amplitude von 0 Stille und eine Amplitude von 1 entspricht normaler Lautst\u00e4rke. Nun lasst uns auch einen Blick auf jeden einzelnen Teil einer H\u00fcllkurve werfen.","title":"Amplitude"},{"location":"#release-zeit","text":"Der einzige Teil der H\u00fcllkurve den Sonic Pi standardm\u00e4\u00dfig einsetzt ist die Release-Zeit. Das ist die Dauer mit der ein Synth-Klang ausklingt. Alle Synths haben eine Release-Zeit von 1, was bedeutet, dass sie eine Dauer von 1 Beat haben (beim Standard-BPM-Wert 60 entspricht das genau 1 Sekunde): play 70 Diesen Ton wirst du 1 Sekunde lang h\u00f6ren. Probiere es aus und stoppe die Zeit :-) Dies ist die Kurzform der etwas l\u00e4ngeren, ausf\u00fchrlichen Variante: play 70, release: 1 Achte darauf, wie dieser Ton exakt gleich klingt (der Klang ist eine Sekunden lang zu h\u00f6ren). Aber jetzt ist es sehr einfach die Dauer \u00fcber die release: -Option zu ver\u00e4ndern: play 60, release: 2 Wir k\u00f6nnen den Synth mit einer sehr kurzen Release-Zeit sehr kurz klingen lassen: play 60, release: 0.2 Die Dauer des Ausklingens eines Klangs wird Release-Zeit ( release phase ) genannt. Standardm\u00e4\u00dfig bedeutet dies ein lineares Ausklingen (das entspricht einer gerade Linie). Das folgende Diagramm zeigt diesen \u00dcbergang: Die senkrechte Linie ganz links im Bild zeigt, dass der Klang mit einer Amplitude von 0 startet, jedoch sofort auf die volle H\u00f6he geht (das ist die Attack-Zeit, die wir gleich behandeln werden). Wenn die volle H\u00f6he erreicht ist, geht die Amplitude in einer geraden Linie bis auf Null zur\u00fcck, wobei dies so lange dauert, wie es mit release festgelegt wurde. Lange Release-Zeiten erzeugen ein langes Ausklingen des Synths. Du kannst daher mit der Release-Zeit die Dauer eines Klanges \u00e4ndern. Spiele damit - f\u00fcge deiner Musik unterschiedlichen Release-Zeiten hinzu.","title":"Release-Zeit"},{"location":"#attack-zeit","text":"Standardm\u00e4\u00dfig ist die Attack-Zeit f\u00fcr alle Synths 0, das bedeutet, die Amplitude geht unmittelbar von 0 auf 1. Daher setzt der Synth mit einem perkussiven Klang ein. Du m\u00f6chtest den Klang vielleicht hingegen einblenden. Dies kann mit der attack -Opt erreicht werden. Versuche einige Kl\u00e4nge einzublenden: play 60, attack: 2 sleep 3 play 65, attack: 0.5 Du kannst mehrere Opts zur gleichen Zeit anwenden. Versuche zum Beispiel f\u00fcr eine kurze Attack-Zeit und eine lange Release-Zeit: play 60, attack: 0.7, release: 4 Diese H\u00fcllkurve mit einer kurzen Attack-Zeit und langer Release-Zeit sieht so aus: Du kannst es nat\u00fcrlich auch anders herum machen. Probiere eine lange Attack-Zeit und eine kurze Release-Zeit aus: play 60, attack: 4, release: 0.7 Letztlich kannst du auch eine kurze Attack- und Release-Zeit verwenden - f\u00fcr k\u00fcrzere Kl\u00e4nge. play 60, attack: 0.5, release: 0.5","title":"Attack-Zeit"},{"location":"#sustain-zeit","text":"Zus\u00e4tzlich zu Attack- und Release-Zeiten kannst du auch eine Sustain-Zeit bestimmen. Diese ist die Zeitdauer, \u00fcber die der Klang anh\u00e4lt, wenn er die eingestellte Lautst\u00e4rke erreicht hat, also zwischen der Attack- und den Release-Phase. play 60, attack: 0.3, sustain: 1, release: 1 Die Sustain-Zeit ist n\u00fctzlich f\u00fcr wichtige Kl\u00e4nge, die du in einem Mix hervorheben willst, bevor sie eine optionale Release-Phase erreichen. Nat\u00fcrlich ist es ebenso m\u00f6glich sowohl den Wert f\u00fcr attack: als auch den f\u00fcr release: auf 0 zu setzen und nur den Sustain zu gebrauchen - ohne Ein- und Ausblendung. Aber Achtung, eine Release-Zeit von 0 kann h\u00f6rbare Klickger\u00e4usche verursachen, und es ist meist besser einen sehr kleinen Wert wie z. B. 0.2 zu verwenden.","title":"Sustain-Zeit"},{"location":"#decay-zeit","text":"Auf einer weiteren Ebene kannst du auch eine Decay-Zeit festlegen. Das ist eine Phase innerhalb der H\u00fcllkurve, die zwischen der Attack- und der Release-Phase liegt. Die Decay-Zeit legt die Dauer der Phase fest, in der die Amplitude abf\u00e4llt - von attack_level: zu decay_level: (welches zun\u00e4chst den gleichen Wert hat wie sustain_level: , solange du den Wert f\u00fcr decay_level: nicht ausdr\u00fccklich vorgibst). Standardm\u00e4\u00dfig steht die Opt decay: auf 0, und sowohl Attack- als auch das Sustain-Level stehen auf 1. Damit die Decay-Zeit einen h\u00f6rbaren Effekt hat, musst du diese Pegel (Level) festlegen: play 60, attack: 0.1, attack_level: 1, decay: 0.2, sustain_level: 0.4, sustain: 1, release: 0.5","title":"Decay-Zeit"},{"location":"#decay-level","text":"Ein weiterer Trick besteht darin, auch die Option decay_level: ausdr\u00fccklich auf einen anderen Wert zu setzen, da decay_level: ansonsten automatisch den Wert von sustain_level: erh\u00e4lt. So erlangst du die vollst\u00e4ndige Kontrolle \u00fcber die H\u00fcllkurve. Du kannst nun H\u00fcllkurven wie die folgende erzeugen: play 60, attack: 0.1, attack_level: 1, decay: 0.2, decay_level: 0.3, sustain: 1, sustain_level: 0.4, release: 0.5 Es ist auch m\u00f6glich f\u00fcr decay_level: ein h\u00f6herer Wert als f\u00fcr sustain_level: zu setzen: play 60, attack: 0.1, attack_level: 0.1, decay: 0.2, decay_level: 1, sustain: 0.5, sustain_level: 0.8, release: 1.5","title":"Decay-Level"},{"location":"#adsr-hullkurven","text":"Fassen wir zusammen: Die ADSR-H\u00fcllkurven von Sonic Pi bestehen aus den folgenden Phasen: Attack - die Zeit in der die Amplitude von 0 zu attack_level \u00fcbergeht, Decay - die Zeit in der die Amplitude von attack_level zu sustain_level \u00fcbergeht, Sustain - die Zeit in der die Amplitude von decay_level zu sustain_level \u00fcbergeht, Release - die Zeit in der die Amplitude von sustain_level auf 0 \u00fcbergeht Es ist wichtig festzuhalten, dass die Dauer eines Klanges der Summe der Zeiten jeder einzelnen dieser Phasen entspricht. Daher hat der folgende Klang eine Dauer von 0.5 + 1 + 2 + 0.5 = 4 Schl\u00e4gen (Beats): play 60, attack: 0.5, attack_level: 1, decay: 1, sustain_level: 0.4, sustain: 2, release: 0.5 Nun leg los und spiele ein wenig damit herum deinen Kl\u00e4ngen H\u00fcllkurven hinzuzuf\u00fcgen...","title":"ADSR-H\u00fcllkurven"},{"location":"#section-03","text":"Eine weitere gro\u00dfartige M\u00f6glichkeit deine Musik zu entwickeln stellt die Verwendung bereits aufgenommener Kl\u00e4nge dar. In der gro\u00dfen Tradition des Hip-Hop nennen wir diese aufgenommenen Kl\u00e4nge auch Samples . Wenn du mit einem Mikrophon nach drau\u00dfen gehst und den zarten Klang von Regentropfen aufnimmst, die auf ein Zeltdach fallen - dann hast du ein Sample hergestellt. Mit Samples kannst du in Sonic Pi viele spa\u00dfige Sachen machen. Es hat nicht nur \u00fcber 130 freie Samples mit an Bord, mit denen du sofort jammen kannst, du kannst auch eigene Samples verwenden und manipulieren. Legen wir damit los...","title":"3 Samples"},{"location":"#section-03-1","text":"Bleeps zu spielen ist nur der Anfang. Was auch eine Menge Spa\u00df macht, ist mit aufgenommenen Samples zu spielen. Probier's mal: sample :ambi_lunar_land Sonic Pi enth\u00e4lt viele Samples, mit denen du spielen kannst. Du kannst sie genauso benutzen wie du das play -Kommando benutzt. Um mehrere Samples gleichzeitig zu spielen, schreib sie einfach untereinander: play 36 play 48 sample :ambi_lunar_land sample :ambi_drone Wenn du sie \u00fcber die Zeit verteilt spielen willst, verwende den sleep -Befehl: sample :ambi_lunar_land sleep 1 play 48 sleep 0.5 play 36 sample :ambi_drone sleep 1 play 36 Achte darauf, dass Sonic Pi nicht wartet, bis ein Klang beendet ist, bevor es den n\u00e4chsten startet? Der sleep -Befehl beschreibt nur, in welchem Abstand ein Klang erneut getriggert (ausgel\u00f6st) wird. Dies erlaubt dir Kl\u00e4nge in Schichten \u00fcbereinander legen und interessante \u00dcberlappungseffekte herzustellen.","title":"3.1 Samples ansteuern"},{"location":"#samples-entdecken","text":"Du kannst die Samples, die Sonic Pi mitbringt, auf zwei Arten entdecken. Erstens kannst du dieses Hilfe-System benutzen. Klicke links unten im Men\u00fc auf Samples , w\u00e4hle eine Kategorie aus und du siehst eine Liste aller darin verf\u00fcgbaren Kl\u00e4nge. Alternativ kannst du das Auto-Completion System (Auto-Vervollst\u00e4ndigung) verwenden. Tippe einfach den Anfang des Namens einer Sample-Kategorie, wie z. B.: sample :ambi_ , dann klappt ein Men\u00fc mit allen dazu passenden Sample-Namen auf. Versuche einen der folgenden Anf\u00e4nge von Kategorie-Namen: :ambi_ :bass_ :elec_ :perc_ :guit_ :drum_ :misc_ :bd_ Jetzt leg los und mixe Samples in deine Kompositionen!","title":"Samples entdecken"},{"location":"#section-03-2","text":"Genauso wie bei den Synths k\u00f6nnen wir unsere Kl\u00e4nge mit Parametern steuern. Samples unterst\u00fctzen genau den selben Parameter-Mechanismus. Besuchen wir unsere Freunde amp: und pan: noch einmal.","title":"3.2 Sample-Parameter"},{"location":"#samples-verstarken","text":"Du kannst die Amplitude (Lautst\u00e4rke) von Samples genau mit der selben Methode steuern wie bei den Synths: sample :ambi_lunar_land, amp: 0.5","title":"Samples verst\u00e4rken"},{"location":"#samples-pannen","text":"Wir k\u00f6nnen auch den pan: -Parameter auf Samples anwenden. Hier zum Beispiel spielen wir den Amen-Break zun\u00e4chst f\u00fcr das linke und nach der H\u00e4lfte nochmals f\u00fcr das rechte Ohr: sample :loop_amen, pan: -1 sleep 0.877 sample :loop_amen, pan: 1 0.877 ist genau die H\u00e4lfte der Dauer des Amen-Breaks in Sekunden. Beachte: Wenn du mit use_synth_defaults Grundeinstellungen f\u00fcr einen Synth setzt (was wir sp\u00e4ter behandeln werden), werden diese von Samples ignoriert.","title":"Samples pannen"},{"location":"#section-03-3","text":"Jetzt k\u00f6nnen wir schon eine Reihe Synths und Samples spielen, um damit Musik zu machen. Es wird Zeit zu lernen, wie wir diese Synths und Samples ver\u00e4ndern k\u00f6nnen, um unsere Musik einzigartiger und spannender zu gestalten. Als Erstes erkunden wir, wie sich Samples strecken und stauchen lassen.","title":"3.3 Samples dehnen"},{"location":"#samples-representation","text":"Samples sind aufgenommene Kl\u00e4nge, gespeichert als eine Reihe von Zahlen, die repr\u00e4sentieren wie die Lautsprechermembran sich bewegen muss, um den Klang wiederzugeben. Die Lautsprechermembran kann sich nach innen und nach au\u00dfen bewegen und die Zahlen geben deshalb an, wie weit sich die Membran zu jedem Zeitpunkt nach innen oder au\u00dfen bewegen muss. Um einen Klang als Aufnahme wirklichkeitsgetreu wiederzugeben, muss das Sample f\u00fcr jede Sekunde viele tausend Zahlen speichern! Sonic Pi nimmt diese Zahlenreihe und gibt sie in der richtigen Geschwindigkeit (sample rate) aus, um den Lautsprecher in deinem Computer genau so bewegen, dass der Klang richtig wiedergegeben wird. Es macht aber auch Spa\u00df, die Geschwindigkeit mit der die Zahlen ausgegeben werden zu \u00e4ndern, um den Klang zu ver\u00e4ndern.","title":"Samples Representation"},{"location":"#geschwindigkeit-andern","text":"Lass uns mit einem der Ambient-Kl\u00e4nge spielen: :ambi_choir . Um die Standard-Geschwindigkeit zu ver\u00e4ndern kannst du die Opt rate: an sample \u00fcbergeben: sample :ambi_choir, rate: 1 Das Sample wird unver\u00e4ndert mit der Standard-Geschwindigkeit (1) abgespielt, also nichts Besonderes. Aber wir k\u00f6nnen die Zahl jederzeit ver\u00e4ndern. Wie w\u00e4r's mit 0.5 ? sample :ambi_choir, rate: 0.5 Wow! Was ist denn jetzt los? Also, hier passieren zwei Dinge. Erstens braucht das Sample doppelt so lange und zweitens klingt er eine Oktave niedriger. Sehen wir uns das ein bisschen genauer an.","title":"Geschwindigkeit \u00e4ndern"},{"location":"#lasst-uns-stretchen","text":"Mit dem Amen-Break-Sample macht das Strecken und Stauchen besonders viel Spa\u00df. Bei normaler Geschwindigkeit w\u00fcrden wir es vielleicht in einem Drum 'n' Bass -Track verwenden: sample :loop_amen Aber mit einer anderen Geschwindigkeit passt es auch zu anderen Stilen. Probiere es aus mit halber Samplerate f\u00fcr Hip-Hop alter Schule : sample :loop_amen, rate: 0.5 Wenn wir es beschleunigen, erreichen wir Jungle -Territorium: sample :loop_amen, rate: 1.5 Und als letzten Party-Trick - schauen wir mal, was passiert, wenn wir eine negative Rate angeben: sample :loop_amen, rate: -1 Wow! Das Sample spielt r\u00fcckw\u00e4rts ! Jetzt probiere mit vielen unterschiedlichen Samples und unterschiedlichen Sampleraten herum. Versuch es mit sehr hohen oder mit verr\u00fcckt langsamen Geschwindigkeiten. Finde heraus, welche spannenden Kl\u00e4nge du produzieren kannst.","title":"Lasst uns stretchen"},{"location":"#eine-einfache-erklarung-der-samplerate","text":"Ein n\u00fctzlicher Weg ist sich Samples als Sprungfedern vorzustellen. Samplerate (auch Abtastrate) ist, als ob man die Sprungfeder zusammendr\u00fcckt oder auseinanderzieht. Wenn du ein Sample mit derRate 2 abspielst, dr\u00fcckst du die Feder zusammen, bis sie nur noch die H\u00e4lfte ihrer normalen L\u00e4nge hat. Das Sample braucht nur die H\u00e4lfte der Abspielzeit, weil es k\u00fcrzer ist. Wenn du das Sample mit halber Rate abspielst, ziehst du die Feder auf ihre doppelte L\u00e4nge auseinander. Das Sample braucht nun doppelt so lange, weil es l\u00e4nger ist. Je mehr Du quetscht (h\u00f6here Rate), desto k\u00fcrzer das Sample, je mehr du streckst (geringere Rate), desto l\u00e4nger das Sample. Wenn du eine Sprungfeder zusammendr\u00fcckt, erh\u00f6hst du ihre Dichte (die Anzahl der Windungen je Zentimeter) - das entspricht einem Sample, das h\u00f6her klingt . Wenn du die Sprungfeder auseinanderziehst, verringerst du ihre Dichte, entspricht das einem, das tiefer klingt .","title":"Eine einfache Erkl\u00e4rung der Samplerate"},{"location":"#die-mathematik-hinter-der-samplerate","text":"(Dieser Abschnitt ist f\u00fcr diejenigen gedacht, die an den Details interessiert sind. Er kann gerne \u00fcbersprungen werden...) Wie wir oben gesehen haben, wird ein Sample durch eine lange Reihe von Zahlen dargestellt, die der Lautsprechermembran sagen, wo sie im Verlauf der Zeit sein soll. Wir k\u00f6nnen diese Zahlenreihe nehmen, um eine Kurve zu zeichnen, die ungef\u00e4hr so aussieht: Vielleicht hast du Bilder wie dieses schon einmal gesehen. Das ist die Waveform (Wellenform) eines Samples. Es ist einfach eine Kurve aus Zahlenwerten. Typischerweise besteht eine Kurve wie diese aus 44100 Datenpunkten je Sekunde (das hat mit dem Nyquist-Shannon-Abtasttheorem zu tun). Wenn also das Sample 2 Sekunden dauert, dann wird die Kurve aus 88200 Zahlen gebildet, die wir an den Lautsprecher mit einer Rate von 44100 Datenpunkten pro Sekunde senden. Nat\u00fcrlich k\u00f6nnten wir das Sample mit der doppelten Abtastrate senden, also 88200 Datenpunkten pro Sekunde. Dann w\u00fcrde das Sample nur eine Sekunde lang dauern. Wir k\u00f6nnen es auch mit der halben Rate abspielen; das w\u00e4ren dann 22050 Datenpunkte pro Sekunde und w\u00fcrde 4 Sekunden dauern. Die Dauer des Samples ist abh\u00e4ngig von der Abtastrate: Wird die Abtastrate verdoppelt, halbiert das die Abspielzeit, Wird die Abtastrate halbiert, dann verdoppelt das die Abspielzeit, Eine Abtastrate von einem Viertel vervierfacht die Abspielzeit, Bei Verwendung einer Abtastrate von 1/10 dauert die Abspielzeit 10 mal l\u00e4nger. Wir k\u00f6nnen das in einer Formel abbilden: neue_sample_dauer = (1 / rate) * sample_dauer Eine Ver\u00e4nderung der Samplerate beeinflusst auch die Tonh\u00f6he des Samples. Die Frequenz oder Tonh\u00f6he einer Kurve wird dadurch bestimmt, wie schnell sie hoch und runter geht. Unser Gehirn macht aus schnellen Bewegungen einer Lautsprechermembran hohe T\u00f6ne und aus langsamen tiefe T\u00f6ne. Deshalb kannst du manchmal sogar sehen, wie sich ein gro\u00dfer Basslautsprecher bewegt, wenn er einen sehr tiefen Ton ausgibt - tats\u00e4chlich bewegt er sich dann wesentlich langsamer als ein Lautsprecher, der hohe T\u00f6ne wiedergibt. Wenn du eine Wellenform nimmst und sie zusammendr\u00fcckst, wird sie in jeder Sekunde h\u00e4ufiger hoch und runter gehen. Das l\u00e4sst den Ton h\u00f6her klingen. Es zeigt sich, dass die Tonh\u00f6he sich verdoppelt, wenn die Auf- und Abbewegungen pro Sekunde (Oszillationen) verdoppelt werden. Also, wenn du dein Sample mit doppelter Rate abspielst, wird es auch doppelt so hoch klingen , und anders herum wird eine Halbierung der Rate die Frequenz halbieren . Entsprechend werden auch andere Raten die Tonh\u00f6he beeinflussen.","title":"Die Mathematik hinter der Samplerate"},{"location":"#section-03-4","text":"Es ist auch m\u00f6glich, die Dauer und Amplitude eines Samples mit einer ADSR-H\u00fcllkurve zu ver\u00e4ndern. Das funktioniert jedoch ein wenig anders als bei den ADSR-H\u00fcllkurven f\u00fcr Synths. Sample-H\u00fcllkurven k\u00f6nnen die Amplitude und die Dauer eines Samples nur verringern - niemals vergr\u00f6\u00dfern. Das Sample wird entweder stoppen, wenn seine normale Laufzeit vorbei ist, oder wenn die H\u00fcllkurve des Samples endet - je nach dem was zuerst passiert. Mit einem sehr langen release: l\u00e4sst sich die Dauer eines Samples nicht verl\u00e4ngern.","title":"3.4 Samples mit H\u00fcllkurven"},{"location":"#amen-hullkurven","text":"Kommen wir zu unserem vertrauten Freund zur\u00fcck, dem Amen-Break: sample :loop_amen Ohne Opts h\u00f6ren wir das Sample in seiner gesamten L\u00e4nge und mit voller Lautst\u00e4rke. Wenn wir es \u00fcber 1 Sekunde einblenden wollen, k\u00f6nnen wir den attack: -Parameter verwenden: sample :loop_amen, attack: 1 W\u00e4hle f\u00fcr ein k\u00fcrzeres Einblenden einen k\u00fcrzeren Attack-Wert: sample :loop_amen, attack: 0.3","title":"Amen-H\u00fcllkurven"},{"location":"#auto-sustain","text":"Wo sich das Verhalten der ADSR-H\u00fcllkurve von der H\u00fcllkurve f\u00fcr Standard-Synths unterscheidet ist der Sustain -Wert. Bei der H\u00fcllkurve f\u00fcr Standard-Synths steht der Sustain standardm\u00e4\u00dfig auf 0 - solange du den Wert nicht ausdr\u00fccklich setzt. Bei Samples steht der Sustain-Wert standardm\u00e4\u00dfig auf automagical - das ist in jedem Moment die Zeit, die es braucht, bis der Rest des Samples abgelaufen ist. Darum h\u00f6ren wir das Sample komplett, wenn wir keine Default-Werte \u00fcbergeben. Wenn die Werte f\u00fcr Attack, Decay, Sustain und Release alle auf 0 st\u00fcnden, w\u00fcrden wir keinen Pieps h\u00f6ren. Daher berechnet Sonic Pi, wie lange das Sample an sich dauert, zieht jegliche Werte f\u00fcr Attack, Decay und Release davon ab und setzt die restliche Zeit als Sustain-Wert. Wenn die Werte von Attack, Decay und Release zusammengerechnet l\u00e4nger dauern als das gesamte Sample, wird der Sustain-Wert einfach auf 0 gesetzt.","title":"Auto-Sustain"},{"location":"#ausblenden","text":"Um das auszuprobieren, schauen wir uns den Amen-Break im Detail an. Wenn wir Sonic Pi fragen, wie lang das Sample ist: print sample_duration :loop_amen Wird 1.753310657596372 ausgeben, was der L\u00e4nge des Sample in Sekunden entspricht. Wir runden das zur Vereinfachung auf 1.75 ab. Wenn wir nun den Release-Wert auf 0.75 setzen, wird etwas erstaunliches passieren: sample :loop_amen, release: 0.75 Die erste Sekunde des Sample wird mit voller Lautst\u00e4rke gespielt, danach wird \u00fcber eine Periode von 0.75 Sekunden ausgeblendet. Das ist der Auto-Sustain in Aktion. Standardm\u00e4\u00dfig berechnet Sonic Pi den Release immer vom Ende des Samples aus gesehen. Wenn unser Sample 10.75 Sekunden lang w\u00e4re, w\u00fcrden die ersten 10 Sekunden in voller Lautst\u00e4rke gespielt, bevor \u00fcber 0.75 Sekunden das Ausblenden erfolgt. Merke: Normalerweise blendet release: das Ende des Sample aus.","title":"Ausblenden"},{"location":"#ein-und-ausblenden","text":"Wir k\u00f6nnen beide, attack: und release: , gemeinsam mit dem Auto-Sustain nutzen, um \u00fcber die Dauer des Samples ein- und auszublenden: sample :loop_amen, attack: 0.75, release: 0.75 Da die Gesamtdauer des Sample 1.75s betr\u00e4gt und unsere Attack- und Release-Phasen zusammen 1.5s ergeben, erh\u00e4lt die Sustain-Phase automatisch eine L\u00e4nge von 0.25s. So ist es ganz einfach, das Sample ein- und auszublenden.","title":"Ein- und Ausblenden"},{"location":"#ausdrucklicher-sustain","text":"Wir k\u00f6nnen ohne weiteres wieder das normale Synth-ADSR-Verhalten aktivieren, indem wir sustain: auf den Wert 0 setzen: sample :loop_amen, sustain: 0, release: 0.75 Jetzt spielt unser Sample insgesamt nur f\u00fcr 0.75 Sekunden. Mit dem Standardwert 0 f\u00fcr attack: und decay: springt das Sample direkt auf die volle Lautst\u00e4rke, bleibt dort f\u00fcr 0s und f\u00e4llt dann innerhalb der Release-Phase mit einer Dauer von 0.75s auf die Lautst\u00e4rke 0 ab.","title":"Ausdr\u00fccklicher Sustain"},{"location":"#perkussive-becken","text":"Wir k\u00f6nnen dieses Verhalten gut dazu benutzen, um l\u00e4nger klingende Samples in k\u00fcrzere, perkussivere Versionen zu verwandeln. Sieh dir das Sample :drum_cymbal_open an: sample :drum_cymbal_open Du kannst h\u00f6ren, wie das Becken eine Zeit lang ausklingt. Mit einer leicht ver\u00e4nderten H\u00fcllkurve k\u00f6nnen wir es perkussiver klingen lassen: sample :drum_cymbal_open, attack: 0.01, sustain: 0, release: 0.1 Du kannst den Eindruck eines Anschlagens und Abd\u00e4mpfens des Beckens erzeugen, indem du die Sustain-Phase erh\u00f6hst: sample :drum_cymbal_open, attack: 0.01, sustain: 0.3, release: 0.1 Jetzt versuche H\u00fcllkurven \u00fcber Samples zu legen. Ver\u00e4ndere auch die Samplerate - damit kannst du wirklich interessante Ergebnisse erzielen.","title":"Perkussive Becken"},{"location":"#section-03-5","text":"Dieser Abschnitt schlie\u00dft unsere Erkundung von Sonic Pi's Sample-Player ab. Fassen wir noch einmal zusammen. Wir haben uns angesehen, wie wir Samples abspielen k\u00f6nnen: sample :loop_amen Dann haben wir gesehen, dass wir die Samplerate \u00e4ndern k\u00f6nnen - etwa um ein Sample mit halber Geschwindigkeit abzuspielen: sample :loop_amen, rate: 0.5 Als n\u00e4chstes haben wir einen Blick darauf geworfen, wie wir ein Sample ein- und ausblenden k\u00f6nnen (z. B. mit halber Geschwindigkeit): sample :loop_amen, rate: 0.5, attack: 1 Wir haben uns auch angeschaut, wie wir einen Sample-Anfang perkussiver klingen lassen k\u00f6nnen, indem wir sustain: ausdr\u00fccklich einen Wert zuweisen, und sowohl Attack als auch Release auf kurze Werte setzen: sample :loop_amen, rate: 2, attack: 0.01, sustain: 0, release: 0.35 W\u00e4re es aber nicht toll, wenn wir ein Sample nicht immer vom Anfang starten lassen m\u00fcssten? W\u00e4re es nicht auch toll, wenn wir das Sample nicht immer erst am Ende stoppen k\u00f6nnten?","title":"3.5 Teil-Samples"},{"location":"#einen-startpunkt-bestimmen","text":"Es ist m\u00f6glich einen beliebigen Startpunkt in einem Sample als Wert zwischen 0 und 1 auszuw\u00e4hlen. Dabei ist 0 der Anfang, 1 das Ende und 0.5 die Mitte des Samples. Versuchen wir also jetzt nur die zweite H\u00e4lfte des Amen Break zu spielen: sample :loop_amen, start: 0.5 Wie w\u00e4re es mit nur dem letzten Viertel des Samples: sample :loop_amen, start: 0.75","title":"Einen Startpunkt bestimmen"},{"location":"#einen-endpunkt-bestimmen","text":"Auf \u00e4hnliche Weise k\u00f6nnen wir mit einem Wert zwischen 0 und 1 einen beliebigen Endpunkt im Sample festlegen. Beenden wir den Amen-Break nach der ersten H\u00e4lfte: sample :loop_amen, finish: 0.5","title":"Einen Endpunkt bestimmen"},{"location":"#start-und-endpunkt-bestimmen","text":"Nat\u00fcrlich k\u00f6nnen wir diese beiden auch kombinieren, um so einen beliebigen Abschnitt des Samples abzuspielen. Wie w\u00e4re es mit nur einem kurzen Abschnitt in der Mitte: sample :loop_amen, start: 0.4, finish: 0.6 Was passiert, wenn wir eine Startposition hinter der Endposition ausw\u00e4hlen? sample :loop_amen, start: 0.6, finish: 0.4 Cool! Es spielt r\u00fcckw\u00e4rts!","title":"Start- und Endpunkt bestimmen"},{"location":"#kombinieren-mit-samplerate","text":"Wir k\u00f6nnen diese neue F\u00e4higkeit, beliebige Abschnitte eines Klangs zu spielen, unserem Freund rate: kombinieren. Zum Beispiel k\u00f6nnen wir einen sehr kurzen Abschnitt des Amen-Breaks sehr langsam spielen: sample :loop_amen, start: 0.5, finish: 0.7, rate: 0.2","title":"Kombinieren mit Samplerate"},{"location":"#kombinieren-mit-hullkurven","text":"Und schlie\u00dflich k\u00f6nnen wir all dies mit unseren ADSR-H\u00fcllkurven kombinieren, um interessante Ergebnisse hervorzubringen: sample :loop_amen, start: 0.5, finish: 0.8, rate: -0.2, attack: 0.3, release: 1 Jetzt leg los und vermansche Samples mit all diesem spa\u00dfigen Zeug...","title":"Kombinieren mit H\u00fcllkurven"},{"location":"#section-03-6","text":"W\u00e4hrend die mitgelieferten Samples die schnell an den Start bringen und loslegen lassen, m\u00f6chtest du vielleicht aber mit anderen aufgenommenen Kl\u00e4ngen in deiner Musik experimentieren. Sonic Pi unterst\u00fctzt das ausdr\u00fccklich. Lass uns aber zun\u00e4chst \u00fcber die \u00dcbertragbarkeit deines St\u00fccks sprechen.","title":"3.6 Externe Samples"},{"location":"#ubertragbarkeit","text":"Wenn du dein St\u00fcck nur basierend auf den eingebauten Synths und Samples komponierst, braucht es nur den Code, um deine Musik originalgetreu wiederzugeben. Denke einen Augenblick dar\u00fcber nach - das ist erstaunlich! Ein einfaches St\u00fcck Text, das du per E-Mail herumschicken oder in einem Gist ablegen kannst, repr\u00e4sentiert alles, was du brauchst, um deine Kl\u00e4nge zu reproduzieren. Das macht es sehr einfach mit deinen Freunden zu teilen. Sie brauchen nur den Code von dir. Wie auch immer, wenn du anf\u00e4ngst selbst aufgenommene Samples zu verwenden, verlierst du diese \u00dcbertragbarkeit. Das liegt daran, dass die Leute, um deine Musik zu reproduzieren nicht nur den Code, sondern auch deine Samples ben\u00f6tigen. Das schr\u00e4nkt die M\u00f6glichkeit f\u00fcr andere ein, mit deiner Arbeit zu experimentieren, sie zu ver\u00e4ndern, sie zu vermanschen (mash-up). Nat\u00fcrlich sollte dich das nicht davon abhalten deine eigenen Samples zu verwenden, es ist nur etwas, das du in deine \u00dcberlegungen einbeziehen solltest.","title":"\u00dcbertragbarkeit"},{"location":"#lokale-samples","text":"Wie geht das nun, eine beliebige WAV-, AIFF- oder FLAC-Datei von deinem Computer abzuspielen? Alles was du daf\u00fcr tun musst ist sample den Pfad zu der Datei zu \u00fcbergeben: # Raspberry Pi, Mac, Linux sample \"/Users/sam/Desktop/my-sound.wav\" # Windows sample \"C:/Users/sam/Desktop/my-sound.wav\" Sonic Pi wird das Sample nun automatisch laden und spielen. Du kannst auch all die Standard-Parameter, die du bereits kennst, an sample \u00fcbergeben: # Raspberry Pi, Mac, Linux sample \"/Users/sam/Desktop/my-sound.wav\", rate: 0.5, amp: 0.3 # Windows sample \"C:/Users/sam/Desktop/my-sound.wav\", rate: 0.5, amp: 0.3","title":"Lokale Samples"},{"location":"#section-03-7","text":"Hinweis: Dieser Abschnitt des Tutorials behandelt das fortgeschrittene Thema der Arbeit mit gro\u00dfen Verzeichnissen deiner eigenen Samples. Dies wird n\u00fctzlich sein, wenn du deine eigenen Sample Packs heruntergeladen oder gekauft hast und diese in Sonic Pi nutzen m\u00f6chtest. \u00dcberspringe diesen Abschnitt, wenn dir die mitgelieferten Samples f\u00fcr die Arbeit ausreichen. Wenn du mit gro\u00dfen Ordnern mit externen Samples arbeitest, kann es m\u00fchselig sein, jedes Mal den vollst\u00e4ndigen Pfad eingeben zu m\u00fcssen, um ein bestimmtes Sample abzuspielen. Sagen wir, du hast zum Beispiel folgenden Ordner auf deinem Computer: /pfad/zu/meinen/samples/ Wenn wir in diesen Ordner schauen, finden wir die folgenden Samples: 100_A#_melody1.wav 100_A#_melody2.wav 100_A#_melody3.wav 120_A#_melody4.wav 120_Bb_guit1.wav 120_Bb_piano1.wav \u00dcblicherweise k\u00f6nnen wir den vollst\u00e4ndigen Pfad nutzen um das Piano-Sample abzuspielen: sample \"/pfad/zu/meinen/samples/120_Bb_piano1.wav\" Wenn wir dann das Gitarren-Sample abspielen wollen, k\u00f6nnen wir ebenfalls den vollst\u00e4ndigen Pfad nutzen: sample \"/pfad/zu/meinen/samples/120_Bb_guit.wav\" Wie auch immer, beide Aufrufe verlangen von uns, dass wir die Namen der Samples innerhalb des Verzeichnisses kennen . Was, wenn wir einfach nur schnell die einzelnen Samples nacheinander abh\u00f6ren wollen?","title":"3.7 Sample-Pakete"},{"location":"#sample-packs-indizieren","text":"Wenn wir das erste Sample in einem Verzeichnis abspielen wollen, m\u00fcssen wir nur den Verzeichnisnamen an sample und den Index 0 eingeben. Folgenderma\u00dfen: sample \"/pfad/zu/meinen/samples/\", 0 Wir k\u00f6nnen sogar eine Verkn\u00fcpfung zu unserem Verzeichnispfad anlegen, indem wir eine Variable nutzen: samps = \"/pfad/zu/meinen/samples/\" sample samps, 0 Wenn wir nun das zweite Sample in unserem Verzeichnis abspielen wollen, m\u00fcssen wir lediglich 1 zu unserem Index hinzuf\u00fcgen: samps = \"/pfad/zu/meinen/samples/\" sample samps, 1 Beachte, dass wir nicht mehr die Namen der Samples im Verzeichnis kennen m\u00fcssen - wir m\u00fcssen nur das Verzeichnis selbst kennen (oder eine Verkn\u00fcpfung dort hin). Wenn wir nach einer Index-Zahl fragen, die gr\u00f6\u00dfer ist als die Anzahl an Samples, f\u00e4ngt die Liste einfach von vorne an - wie bei Ringen. Also egal welche Index-Zahl wir nutzen, es ist garantiert, dass wir eines der Samples aus dem Verzeichnis bekommen.","title":"Sample-Packs indizieren"},{"location":"#sample-packs-filtern","text":"Gew\u00f6hnlich reicht das Indizieren aus, aber manchmal ben\u00f6tigen wir machtvollere Mittel, um unsere Samples zu organisieren. Gl\u00fccklicherweise packen viele Sample-Packs n\u00fctzliche Informationen in die Dateinamen. Lass uns einen weiteren Blick auf die Dateinamen der Samples in unserem Verzeichnis werfen: 100_A#_melody1.wav 100_A#_melody2.wav 100_A#_melody3.wav 120_A#_melody4.wav 120_Bb_guit1.wav 120_Bb_piano1.wav Achte darauf, dass In diesen Dateinamen einiges an Informationen enthalten ist. Zuerst haben wir die BPM (\"beats per minute\") des Samples am Beginn. D.h. das Piano-Sample ist in 120 BPM und unsere ersten drei Melodien sind in 100 BPM. Au\u00dferdem steht in den Sample-Namen die Tonart. Das Gitarren-Sample ist in Bb, und die Melodien sind in A#. Diese Information ist f\u00fcr das Mixen der Samples mit unserem Code sehr wichtig. Zum Beispiel wissen wir, dass wir das Piano-Sample nur mit Code verwenden k\u00f6nnen, der 120 BPM und die Tonart Bb hat. Es stellt sich heraus, dass wir dies spezielle Namensgebung unserer Sample-Sets im Code nutzen k\u00f6nnen, um die Samples herauszufiltern, die wir wollen. Wenn wir zum Beispiel mit 120 BPM arbeiten, k\u00f6nnen wir mit folgendem Code alle Samples filtern, deren Name den String \"120\" enth\u00e4lt: samps = \"/pfad/zu/meinen/samples/\" sample samps, \"120\" Dieser Code wird uns das erste passende Sample abspielen. Wenn wir das zweite passende Sample abspielen wollen, m\u00fcssen wir nur eine Index-Zahl nutzen: samps = \"/pfad/zu/meinen/samples/\u201c sample samps, \"120\", 1 Wir k\u00f6nnen sogar mehrere Filter gleichzeitig nutzen. Wenn wir ein Sample wollen, dessen Name sowohl den String \"120\" als auch den String \"A#\" enth\u00e4lt, k\u00f6nnen wir das leicht mit dem folgenden Code erreichen: samps = \"/pfad/zu/meinen/samples/\" sample samps, \"120\", \"A#\" Schlie\u00dflich k\u00f6nnen wir auch noch unsere \u00fcblichen Optionen dem sample -Aufruf anh\u00e4ngen: samps = \"/pfad/zu/meinen/samples/\" sample samps, \"120\", \"Bb\", 1, lpf: 70, amp: 2","title":"Sample-Packs filtern"},{"location":"#quellen","text":"Das Filter-System f\u00fcr Samples versteht zwei Typen von Informationen: Quellen und Filter. Quellen sind Informationen, um eine Liste m\u00f6glicher Kandidaten zu versammeln. Eine Quelle kann in zwei Formen angegeben werden: \"/pfad/zu/samples\" - eine Zeichenkette (string), die einen g\u00fcltigen Pfad zu einem Verzeichnis angibt \"/pfad/zu/samples/foo.wav\" - eine Zeichenkette (string), die einen g\u00fcltigen Pfad zu einem Sample angibt Die sample -Funktion sammelt alle Quellen und erzeugt daraus eine lange Liste von Kandidaten. F\u00fcr diese Liste durchsucht die Funktion zun\u00e4chst alle g\u00fcltigen Verzeichnispfade und f\u00fcgt dann alle darin enthaltenen Dateien in den Formaten .flac , .aif , .aiff , .wav , .wave hinzu. Schau Dir z. B. den folgenden Code an: samps = \"/pfad/zu/meinen/samples/\" samps2 = \"/pfad/zu/meinen/samples2/\" path = \"/pfad/zu/meinen/samples3/foo.wav\" sample samps, samps2, path, 0 Hier kombinieren wir alle Samples aus zwei Verzeichnissen und f\u00fcgen noch ein einzelnes Sample hinzu. Wenn \"/pfad/zu/meinen/samples/\" 3 Samples und \"/path/to/my/samples2/\" 12 Samples enthielte, h\u00e4tten wir insgesamt 16 m\u00f6gliche Samples, die wir indexieren und filtern k\u00f6nnen (3 + 12 + 1). Standardm\u00e4\u00dfig werden nur die Sample-Dateien des angegebenen Verzeichnisses in der Kandidatenliste gesammelt. Manchmal m\u00f6chtest du vielleicht eine ganze Reihe ineinander verschachtelter Ordner mit Samples durchsuchen und filtern. Das kannst du mit einer rekursiven Suche nach allen Samples in allen Unterordnern erreichen, indem du ** an das Ende des Pfads h\u00e4ngst: samps = \"/path/to/nested/samples/**\" sample samps, 0 Beachte jedoch, dass eine Suche \u00fcber viele Verzeichnisse hinweg viel Zeit in Anspruch nehmen kann. Allerdings wird der Inhalt aller Ordner, die du als Quellen angegeben hast, zwischengespeichert - die Verz\u00f6gerung wird also nur bei der ersten Suche auftreten. Ein wichtiger Punkt zum Abschluss: Die Quelle muss als erstes angegeben werden . Wenn keine Quelle angegeben wird, werden die mitgelieferten Samples als die Standardliste der Kandidaten ausgew\u00e4hlt, mit denen du dann weiter arbeitest.","title":"Quellen"},{"location":"#filter","text":"Wenn du erst einmal eine Kandidatenliste hast, kannst du die folgenden Filtertypen nutzen, um die Auswahl weiter einzugrenzen: \"foo\" filtert alle Dateinamen, in denen diese Zeichenkette vorkommt (abz\u00fcglich des Verzeichnispfades und der Dateiendung). /fo[oO]/ filtert alle Dateinamen, die diesem regul\u00e4ren Ausdruck entsprechen (abz\u00fcglich des Verzeichnispfades und der Dateiendung). :foo - filtert alle Kandidaten, bei denen dieses Schl\u00fcsselwort genau dem Dateinamen entspricht (abz\u00fcglich des Verzeichnispfades und der Dateiendung). lambda{|a| ... } - Procs mit einem Argument werden als Filter f\u00fcr Kandidaten oder Generator-Funktionen behandelt. Diesem wird die Liste der aktuellen Kandidaten \u00fcbergeben, und er gibt eine neue Liste von Kandidaten zur\u00fcck (eine Liste g\u00fcltiger Pfade zu Sample-Dateien). 1 - Zahlen w\u00e4hlen direkt den Kandidaten aus, dessen Indexposition dieser Zahl entspricht (wenn n\u00f6tig wird wie bei einem Ring von vorne begonnen). Wir k\u00f6nnen z. B. alle Samples in einem Verzeichnis herausfiltern, deren Dateinamen die Zeichenkette \"foo\" enthalten, und davon das erste passende Sample mit halber Geschwindigkeit spielen: sample \"/path/to/samples\", \"foo\", rate: 0.5 Sieh' dir die Hilfe zu sample an, sie enth\u00e4lt viele detaillierte Anwendungsbeispiele. Achte darauf, welche Rolle die Sortierung der Filter spielt.","title":"Filter"},{"location":"#verbunde","text":"Abschlie\u00dfend sei gesagt, dass du Listen \u00fcberall verwenden kannst, wo du eine Quelle oder einen Filter einsetzt. Die Liste wird automatisch eingebettet und ihre Inhalte behandelt wie normale Quellen- oder Filterangaben. Daher sind die folgenden Aufrufe von sample alle gleichbedeutend: sample \"/path/to/dir\", \"100\", \"C#\" sample [\"/path/to/dir\", \"100\", \"C#\"] sample \"/path/to/dir\", [\"100\", \"C#\"] sample [\"/path/to/dir\", [\"100\", [\"C#\"]]]","title":"Verb\u00fcnde"},{"location":"#zum-abschluss","text":"Das war ein fortgeschrittener Abschnitt f\u00fcr Leute, die machtvollere M\u00f6glichkeiten ben\u00f6tigen, um mit Sample-Paketen zu hantieren und sie zu nutzen. Wenn vieles davon f\u00fcr dich im Moment noch wenig Sinn ergeben hat, keine Sorge. Es ist gut m\u00f6glich, dass du vieles davon jetzt noch nicht brauchst. Dennoch, du wirst merken, wann du es brauchst, und du kannst zur\u00fcckkommen und den Abschnitt noch einmal lesen, wenn du anf\u00e4ngst mit umfangreicheren Sample-Sammlungen zu hantieren.","title":"Zum Abschluss"},{"location":"#section-04","text":"Eine tolle M\u00f6glichkeit deine Musik interessant zu gestalten ist die Nutzung von Zufallszahlen. Sonic Pi bietet einige tolle Funktionen, um deiner Musik Zuf\u00e4lligkeiten hinzuzuf\u00fcgen. Aber bevor wir damit anfangen, musst du noch eine schockierende Wahrheit erfahren: In Sonic Pi bedeutet zuf\u00e4llig nicht wirklich zuf\u00e4llig . Was zum Teufel soll das hei\u00dfen? Nun, das werden wir sehen.","title":"4 Zuf\u00e4lligkeit"},{"location":"#wiederholbarkeit","text":"Eine wirklich n\u00fctzliche Zufallsfunktion ist rrand . Sie liefert dir einen zuf\u00e4lligen Wert zwischen zwei Zahlen - einem Minimal- und einem Maximalwert - ( rrand ist ein K\u00fcrzel f\u00fcr ranged random , also eine Zufallszahl aus einem bestimmten Zahlenbereich). Versuchen wir mal eine zuf\u00e4llig ausgew\u00e4hlte Note zu spielen: play rrand(50, 95) Oh, es hat eine zuf\u00e4llige Note gespielt. Es hat Note 83.7527 gespielt. Eine nette zuf\u00e4llige Note zwischen 50 und 100. Aber halt, habe ich gerade diese angeblich zuf\u00e4llige Note exakt bestimmt? Da ist doch etwas nicht ganz sauber. Lasse den Programm-Code noch einmal laufen. Wie bitte? Es hat wieder 83.7527 gew\u00e4hlt? Das kann kein Zufall sein! Die Antwort ist, es ist nicht wirklich zuf\u00e4llig, es ist pseudo-zuf\u00e4llig. Sonic Pi liefert dir zufalls\u00e4hnliche Zahlen, die sich wiederholen. Das ist sehr n\u00fctzlich, um sicherzustellen, dass die Musik die du auf deinem Rechner erzeugst, auf jedem anderen Rechner identisch klingt - auch dann, wenn du Zuf\u00e4lligkeiten in deiner Komposition verwendest. Klar, wenn es, in einem bestimmten Musikst\u00fcck, jedes Mal 'zuf\u00e4llig' die 83.7527 w\u00e4hlen w\u00fcrde, dann w\u00e4re das nicht besonders interessant. Aber das tut es auch nicht. Probiere folgendes: loop do play rrand(50, 95) sleep 0.5 end Ja! Jetzt klingt es zuf\u00e4llig. Innerhalb eines gegebenen Programmlaufes liefern weitere Aufrufe von Zufallsfunktionen auch zuf\u00e4llige Werte. Trotzdem wird der n\u00e4chste Programmlauf genau die selbe Abfolge von Zufallswerten liefern und entsprechend auch genau gleich klingen. Es ist als ob Sonic Pi Code immer an denselben Zeitpunkt zur\u00fcckspringt, wenn der Ausf\u00fchren-Schalter geklickt wird. Das ist der Murmeltier-Tag der musikalischen Synthese!","title":"Wiederholbarkeit"},{"location":"#gesiterglocken","text":"Ein sch\u00f6nes Beispiel von Zuf\u00e4lligkeit in Aktion ist das Geisterglocken-Beispiel, in dem das :perc_bell -Sample mit einer zuf\u00e4lligen Samplerate und Pausenzeit zwischen den Glockenkl\u00e4ngen abgespielt wird: loop do sample :perc_bell, rate: (rrand 0.125, 1.5) sleep rrand(0.2, 2) end","title":"Gesiterglocken"},{"location":"#zufallige-begrenzung","text":"Ein anderes unterhaltsames Beispiel f\u00fcr Zuf\u00e4lligkeit ist, einen Synth-Klang zuf\u00e4llig in der Tonh\u00f6he zu begrenzen. Ein toller Synth um das auszuprobieren ist der :tb303 -Emulator: use_synth :tb303 loop do play 50, release: 0.1, cutoff: rrand(60, 120) sleep 0.125 end","title":"Zuf\u00e4llige Begrenzung"},{"location":"#zufallsstartpunkte","text":"Was, wenn dir eine bestimmte Zufallsabfolge, die Sonic Pi liefert, dir nicht gef\u00e4llt? Nun, mit use_random_seed l\u00e4sst sich sehr gut ein anderer Startpunkt f\u00fcr diese Zufallsabfolge w\u00e4hlen. Der Standard-Startpunkt ist die 0, w\u00e4hle also einen anderen Startpunkt, und du machst eine andere Zufallserfahrung! Sieh dir folgenden Code an: 5.times do play rrand(50, 100) sleep 0.5 end Jedes Mal, wenn du diesen Programm-Code laufen l\u00e4sst, h\u00f6rst du dieselbe Folge von 5 Noten. Um eine andere Folge zu bekommen, setze einen anderen Startpunkt: use_random_seed 40 5.times do play rrand(50, 100) sleep 0.5 end Nun produziert Sonic Pi eine andere Folge aus 5 T\u00f6nen. Indem du den Startpunkt \u00e4nderst und dir die Ergebnisse anh\u00f6rst, kannst du eine Folge finden, die dir gef\u00e4llt - und wenn du den Code an andere weitergibst, werden sie genau das h\u00f6ren, was auch du geh\u00f6rt hast. Schauen wir uns noch einige andere n\u00fctzliche Zufallsfunktionen an.","title":"Zufallsstartpunkte"},{"location":"#auswahlen","text":"Eine Sache, die sehr h\u00e4ufig gemacht wird, ist aus einer Liste bekannter Elemente eines zuf\u00e4llig auszuw\u00e4hlen. Zum Beispiel m\u00f6chte ich vielleicht einen Ton aus der folgenden Liste spielen: 60, 65 oder 72. Das kann ich mit choose erreichen, das mich ein Element aus einer Liste w\u00e4hlen l\u00e4sst. Zuerst musst ich meine Zahlen in eine Liste packen, indem ich sie, durch Kommas getrennt, in eckige Klammern setze. Danach muss ich sie einfach nur an choose \u00fcbergeben: choose([60, 65, 72]) H\u00f6ren wir uns das mal an: loop do play choose([60, 65, 72]) sleep 1 end","title":"Ausw\u00e4hlen"},{"location":"#rrand","text":"Wir haben rrand schon kennengelernt, aber sehen wir uns das noch einmal genauer an. Es liefert eine zuf\u00e4llige Zahl zwischen zwei Werten - ausschlie\u00dflich dieser Werte selbst. Das bedeutet, dass weder der minimale noch der maximale Wert jemals ausgegeben werden, immer nur was zwischen den beiden liegt. Diese Zahl wird immer eine Gleitkommazahl (floating point number) sein - also keine ganze Zahl, sondern eine Bruchzahl (Erinnere dich: Computer verwenden f\u00fcr Rechenoperationen stets die englische Schreibweise - daher Punkt, nicht Komma!). Hier Beispiele f\u00fcr Gleitkommazahlen beim Aufruf von rrand(20, 110) : 87.5054931640625 86.05255126953125 61.77825927734375","title":"rrand"},{"location":"#rrand_i","text":"Gelegentlich wirst du jedoch eine ganze Zahl wollen, keine Gleitkommazahl. Hier kommt rrand_i ( i f\u00fcr englisch integer, ganze Zahl) zur Hilfe. Es funktioniert \u00e4hnlich wie rrand , kann jedoch auch den minimalen oder maximalen Wert als m\u00f6gliche Zufallszahl liefern. (was bedeutet, dass es einschlie\u00dflich der begrenzenden Werte funktioniert und nicht ausschlie\u00dflich). Beispiele w\u00e4ren die Werte, die von rand_i(20,110) ausgeben werden: 88 86 62","title":"rrand_i"},{"location":"#rand","text":"Dies wird eine zuf\u00e4llige Gleitkommazahl zwischen 0 (inklusiv) und einem von dir spezifizierten Maximalwert (exklusiv) zur\u00fcckgeben. Standardm\u00e4\u00dfig wird ein Wert zwischen 0 und 1 ausgegeben. Daher ist es n\u00fctzlich f\u00fcr eine Auswahl zuf\u00e4lliger Werte f\u00fcr amp: : loop do play 60, amp: rand sleep 0.25 end","title":"rand"},{"location":"#rand_i","text":"\u00c4hnlich wie im Verh\u00e4ltnis von rrand_i zu rrand , wird rand_i eine zuf\u00e4llige ganze Zahl zwischen 0 und dem angegebenen Maximalwert zur\u00fcckgeben.","title":"rand_i"},{"location":"#dice","text":"Manchmal wirst du so tun wollen, als w\u00fcrdest du w\u00fcrfeln (dice) - dies ist ein Sonderfall von rrand_i , bei dem der kleinste Wert immer die 1 ist. Ein Aufruf von dice verlangt von dir die Anzahl von Seiten zu bestimmen, die der W\u00fcrfel haben soll. Ein normaler W\u00fcrfel hat 6 Seiten, dice(6) wird dem entsprechend einen der Werte 1, 2, 3, 4, 5 oder 6 zur\u00fcckgeben. Wie auch immer, in einem Rollenspiel w\u00fcrdest auch Nutzen in einem 4-seitigen W\u00fcrfel sehen, oder einem 12-seitigen, oder einem 20-seitigen, vielleicht sogar in einem 120-seitigem!","title":"dice"},{"location":"#one_in","text":"Schlie\u00dflich k\u00f6nnte es noch so sein, dass du so tun willst, als ob du beim W\u00fcrfeln mit einem Standardw\u00fcrfel eine 6 hast - also den h\u00f6chsten Wert. one_in gibt daf\u00fcr mit einer Wahrscheinlichkeit von 1 im Verh\u00e4ltnis zur Anzahl W\u00fcrfelseiten den Wert wahr (true) zur\u00fcck. Daher wird one_in(6) mit einer Wahrscheinlichkeit von 1 zu 6 wahr, ansonsten falsch (false). Wahr- und Falsch-Werte sind sehr n\u00fctzlich bei if -Anweisungen, welche wir in einem sp\u00e4teren Abschnitt dieses Tutorials behandeln werden. Jetzt los, bringe deinen Code mit ein wenig Zuf\u00e4lligkeit durcheinander!","title":"one_in"},{"location":"#section-05","text":"Jetzt, da du die Grundlagen f\u00fcr die Erzeugung von Kl\u00e4ngen mit play und sample und die Erzeugung von Melodien und Rhythmen durch den Einsatz von sleep zwischen den Kl\u00e4ngen gelernt hast, fragst du dich vielleicht, was dir die Welt des Codes dar\u00fcber hinaus zu bieten hat... Nun, ich denke, da kommen noch einige aufregende Sachen auf dich zu! Es ist n\u00e4mlich so, dass grundlegende Programmstrukturen wie Schleifen (loops), Bedingungen (conditionals), Funktionen (functions) und Str\u00e4nge (threads) unglaublich machtvolle Werkzeuge sind, um deine musikalischen Ideen auszudr\u00fccken. Sehen wir uns die Grundlagen eingehender an...","title":"5 Programmstrukturen"},{"location":"#section-05-1","text":"Eine Struktur, der du in Sonic Pi h\u00e4ufig begegnen wirst, ist der Block. Bl\u00f6cke erlauben uns, mit gr\u00f6\u00dferen Abschnitten von Programm-Code n\u00fctzliche Dinge zu tun. Z. B. konnten wir bisher mit Synth- und Sample-Parametern etwas ver\u00e4ndern, das in einer einzelnen Zeile des Codes geschah. Manchmal aber m\u00f6chten wir etwas Sinnvolles mit einer ganzen Abfolge von Code-Zeilen anstellen. Zum Beispiel m\u00f6chten wir diese in einer Schleife ablaufen lassen, Hall hinzuf\u00fcgen, sie nur 1 von 5 Malen ablaufen lassen etc. Sieh dir folgenden Code an: play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 Um etwas auf einen mehrzeiligen Code-Abschnitt anzuwenden, m\u00fcssen wir Sonic Pi sagen, wo der Code-Block anf\u00e4ngt , und wo er aufh\u00f6rt . Wir verwenden do f\u00fcr den Anfang und end f\u00fcr das Ende. So zum Beispiel: do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end Das ist aber noch nicht vollst\u00e4ndig und wird nicht funktionieren (versuche es, und du wirst eine Fehlermeldung erhalten), weil wir Sonic Pi noch nicht gesagt haben, was wir mit diesem do/end-Block anstellen wollen. Wir teilen es Sonic Pi mit, indem wir noch einen speziellen Ausdruck vor das do setzen. Wir werden sp\u00e4ter in diesem Tutorial noch eine Reihe solcher Ausdr\u00fccke kennenlernen. F\u00fcr den Moment ist wichtig zu wissen, dass, wenn du deinen Code zwischen do und end zusammenfasst, dies Sonic Pi sagt, dass du mit diesem Codeabschnitt etwas Bestimmtes machen willst.","title":"5.1 Bl\u00f6cke"},{"location":"#section-05-2","text":"Bislang haben wir viel Zeit damit verbracht, uns die unterschiedliche Kl\u00e4nge anzusehen, die du mit play - und sample -Bl\u00f6cken erzeugen kannst. Wir haben auch gelernt, wie wir das Triggern dieser Kl\u00e4nge mit sleep steuern k\u00f6nnen. Du hast ja wahrscheinlich herausgefunden, dass du mit diesen Grundbausteinen schon viel Spa\u00df haben kannst. Eine ganz neue Dimension er\u00f6ffnet sich jedoch, wenn du anf\u00e4ngst die Macht des Programm-Codes zu nutzen, um deine Musiken und Kompositionen zu strukturieren. In den n\u00e4chsten Abschnitten sehen wir uns einige wirkungsvolle neue Werkzeuge daf\u00fcr an. Als erstes kommen Iterationen (wiederholte Abl\u00e4ufe) und Schleifen (Loops) dran.","title":"5.2 Wiederholung und Schleifen"},{"location":"#wiederholung","text":"M\u00f6chtest du Code, den du geschrieben hast, einige Male wiederholen? Vielleicht hast du z. B. so etwas: play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 Was, wenn du das drei Male wiederholen wolltest? Nun, wir k\u00f6nnten etwas ganz Einfaches tun, es kopieren und dreimal hintereinander einf\u00fcgen: play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 Nun, das ist eine Menge Code! Was w\u00e4re, wenn du das Sample in :elec_plip \u00e4ndern wolltest? Du m\u00fcsstest alle Stellen mit :elec_blub finden und sie \u00e4ndern. Und dar\u00fcber hinaus: Was, wenn du den urspr\u00fcnglichen Code-Block 50 oder 1000 Mal wiederholen wolltest? Das w\u00e4re wirklich eine Menge Code, und eine Menge Zeilen, die du bearbeiten m\u00fcsstest, wenn du etwas \u00e4ndern wolltest.","title":"Wiederholung"},{"location":"#iteration","text":"Tats\u00e4chlich, Programm-Code wiederholt ablaufen zu lassen sollte so einfach sein wie zu sagen, mache das drei Mal . Nun, so ist es auch in etwa. Erinnere dich an unseren Freund, den Code-Block? Wir k\u00f6nnen damit den Anfang und das Ende des Codes markieren, den wir drei Mal wiederholen wollen. Daf\u00fcr benutzen wir den speziellen Ausdruck 3.times . Anstelle von mache das drei Mal schreiben wir 3.times do - das ist nicht besonders schwer. Denke daran an das Ende des Codes, den du wiederholen m\u00f6chtest, end zu schreiben: 3.times do play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 sleep 0.25 end Na, ist das nicht viel eleganter als zu kopieren und einzuf\u00fcgen? Wir k\u00f6nnen dies verwenden um viele sch\u00f6ne sich wiederholende Strukturen zu erzeugen: 4.times do play 50 sleep 0.5 end 8.times do play 55, release: 0.2 sleep 0.25 end 4.times do play 50 sleep 0.5 end","title":"Iteration"},{"location":"#iterationen-verschachteln","text":"Wir k\u00f6nnen Iterationen in anderen Iterationen verpacken, um interessante Muster zu erzeugen. Zum Beispiel: 4.times do sample :drum_heavy_kick 2.times do sample :elec_blip2, rate: 2 sleep 0.25 end sample :elec_snare 4.times do sample :drum_tom_mid_soft sleep 0.125 end end","title":"Iterationen verschachteln"},{"location":"#schleifen-abspielen","text":"Wenn du etwas sehr oft wiederholen m\u00f6chtest, k\u00f6nnte es sein, dass du mit sehr hohen Zahlen arbeiten musst, wie zum Beispiel 1000.times do . In einem solchen Fall ergibt es m\u00f6glicherweise mehr Sinn Sonic Pi zu bitten, den Code endlos zu wiederholen (zumindest, bis du auf die Stopp-Schaltfl\u00e4che klickst!). Lass uns den Amen-Break unendlich oft wiederholen: loop do sample :loop_amen sleep sample_duration :loop_amen end Eine wichtige Sache bei Schleifen (Loops) ist, dass es sich mit ihnen f\u00fcr den Code wie mit schwarzen L\u00f6chern verh\u00e4lt. Wenn der Code einmal in einer Schleife abl\u00e4uft, kann er diese nicht verlassen, bis du auf Stopp klickst - ansonsten wird er f\u00fcr immer in dieser Schleife weiterlaufen. Das bedeutet, wenn hinter deiner Schleife noch weiterer Code steht, wirst du diesen nie h\u00f6ren. Zum Beispiel wird das Becken hinter dieser Schleife niemals spielen: loop do play 50 sleep 1 end sample :drum_cymbal_open Jetzt fang an und strukturiere deinen Code mit Iterationen und Schleifen!","title":"Schleifen abspielen"},{"location":"#section-05-3","text":"Was du dir wahrscheinlich w\u00fcnschen wirst, ist nicht einfach nur eine zuf\u00e4llige Note zu spielen (siehe auch den letzten Abschnitt \u00fcber Zuf\u00e4lligkeit), sondern auch eine zuf\u00e4llige Entscheidung treffen zu k\u00f6nnen, und je nachdem wie diese ausf\u00e4llt, den einen oder den anderen Code ablaufen zu lassen. Zum Beispiel k\u00f6nnte es sein, dass du einer Zuf\u00e4lligkeit folgend entweder eine Trommel oder ein Becken abspielen m\u00f6chtest. Das k\u00f6nnen wir mit einem if -Ausdruck erreichen.","title":"5.3 Bedingungen"},{"location":"#eine-munze-werfen","text":"Werfen wir also ein M\u00fcnze: Bei Kopf, spiele eine Trommel, bei Zahl, ein Becken. Das ist leicht. Wir k\u00f6nnen den M\u00fcnzwurf mit unserer one_in -Funktion nachbilden (eingef\u00fchrt im Kapitel \u00fcber Zuf\u00e4lligkeit), indem wir eine Wahrscheinlichkeit von 1 aus 2 angeben: one_in(2) . Das Ergebnis dieser Berechnung k\u00f6nnen wir nutzen, um zwischen zwei Code-Abschnitten auszuw\u00e4hlen, entweder den Code, um die Trommel zu spielen oder den Code, um das Becken zu spielen: loop do if one_in(2) sample :drum_heavy_kick else sample :drum_cymbal_closed end sleep 0.5 end Merke dir, dass if -Anweisungen drei Teile haben: Die Frage, die gestellt wird Die Auswahl von Programm-Code, der laufen soll (wenn die Antwort auf die Frage ein Ja ist) Die zweite Auswahl von Programm-Code, der laufen soll (wenn die Antwort auf die Frage ein Nein ist) In Programmiersprachen steht typischerweise f\u00fcr das Ja der Ausdruck true und f\u00fcr das Nein der Ausdruck false . Also m\u00fcssen wir eine Frage finden, auf die wir eine Antwort erhalten, die entweder true (wahr) oder false (falsch) ist. Das ist genau das, was one_in tut. Beachte, wie hier die erste Wahl zwischen dem if und dem else und die zweite Wahl zwischen dem else und dem end eingeschlossen wird. So wie bei den do/end-Bl\u00f6cken kannst du beliebig viele Codezeilen an beiden Stellen einf\u00fcgen. Zum Beispiel: loop do if one_in(2) sample :drum_heavy_kick sleep 0.5 else sample :drum_cymbal_closed sleep 0.25 end end Dieses Mal lassen wir den Code unterschiedlich lange schlafen, je nachdem welche Auswahl getroffen wird.","title":"Eine M\u00fcnze werfen"},{"location":"#einfaches-if","text":"Manchmal m\u00f6chtest du wahlweise nur eine Code-Zeile ausf\u00fchren. Das ist m\u00f6glich, indem du ein if setzt und dahinter die Frage an das Ende, zum Beispiel: use_synth :dsaw loop do play 50, amp: 0.3, release: 2 play 53, amp: 0.3, release: 2 if one_in(2) play 57, amp: 0.3, release: 2 if one_in(3) play 60, amp: 0.3, release: 2 if one_in(4) sleep 1.5 end Dieses Beispiel spielt Akkorde, bestehend aus verschiedenen Noten, wobei die Chance gespielt zu werden f\u00fcr die einzelnen Noten jeweils eine andere Wahrscheinlichkeit hat.","title":"Einfaches if"},{"location":"#section-05-4","text":"Nun hast du also eine Killer-Basslinie und einen krassen Beat gebaut. Wie kannst du beide zur selben Zeit spielen lassen? Eine M\u00f6glichkeit ist, beide Sounds per Hand miteinander zu verweben - spiele erst den Bass ein bisschen, dann das Schlagzeug, dann den Bass etwas mehr... Beides zeitlich aufeinander abzustimmen wird jedoch gedanklich bald immer schwieriger, vor allem, wenn noch mehr Kl\u00e4nge dazukommen sollen. Was, wenn Sonic Pi Kl\u00e4nge automatisch f\u00fcr dich miteinander verweben k\u00f6nnte? Nun, das kann es, und zwar erreichst du das mit einem besonderen Ding, welches Thread ( Strang ) genannt wird.","title":"5.4 Threads"},{"location":"#unendliche-schleifen","text":"Damit dieses Beispiel nicht zu kompliziert wird, musst du dir einfach vorstellen, dass dies deine Killer-Basslinie und dein krasser Beat sind: loop do sample :drum_heavy_kick sleep 1 end loop do use_synth :fm play 40, release: 0.2 sleep 0.5 end Wir haben das fr\u00fcher schon besprochen, Schleifen sind wie schwarze L\u00f6cher f\u00fcr ein Programm. L\u00e4uft es einmal in die Schleife kommt es da nicht mehr raus, bis du auf Stopp klickst. Wie also k\u00f6nnen wir beide Schleifen zur selben Zeit abspielen? Wir m\u00fcssen Sonic Pi sagen, dass wir einen bestimmten Abschnitt gleichzeitig mit dem Rest des Codes starten m\u00f6chten. Hierbei helfen uns Reihenfolgen (threads).","title":"Unendliche Schleifen"},{"location":"#threads-als-rettung","text":"in_thread do loop do sample :drum_heavy_kick sleep 1 end end loop do use_synth :fm play 40, release: 0.2 sleep 0.5 end Indem wir die erste Schleife in einen in_thread -do/end-Block hinein packen, sagen wir Sonic Pi, es soll den Inhalt dieses do/end-Blocks genau zur selben Zeit wie n\u00e4chste Anweisung nach dem do/end-Block ausf\u00fchren (und das ist in diesem Fall die zweite Schleife). Probiere es aus, und du wirst den Beat und die Basslinie miteinander verwoben h\u00f6ren! Mal angenommen, wir wollten dar\u00fcber noch einen Synth hinzuf\u00fcgen. Ungef\u00e4hr so: in_thread do loop do sample :drum_heavy_kick sleep 1 end end loop do use_synth :fm play 40, release: 0.2 sleep 0.5 end loop do use_synth :zawa play 52, release: 2.5, phase: 2, amp: 0.5 sleep 2 end Jetzt haben wir das gleiche Problem wie vorhin. Die erste Schleife wird durch das in_thread zur selben Zeit wie die zweite gespielt. Aber die dritte Schleife wird nie erreicht . Also brauchen wir einen weiteren Thread: in_thread do loop do sample :drum_heavy_kick sleep 1 end end in_thread do loop do use_synth :fm play 40, release: 0.2 sleep 0.5 end end loop do use_synth :zawa play 52, release: 2.5, phase: 2, amp: 0.5 sleep 2 end","title":"Threads als Rettung"},{"location":"#ausfuhren-als-thread","text":"Was dich vielleicht erstaunt: Wenn du auf Ausf\u00fchren klickst, erzeugst du eigentlich einen neuen Thread, innerhalb dessen der Programm-Code abl\u00e4uft. Deshalb entstehen immer neue Klangschichten, wenn du wiederholt auf Ausf\u00fchren klickst. Weil diese Abl\u00e4ufe jeweils f\u00fcr sich Threads sind, werden sie automatisch die Kl\u00e4nge f\u00fcr dich miteinander verweben.","title":"Ausf\u00fchren als Thread"},{"location":"#bereich","text":"W\u00e4hrend du Sonic Pi besser zu meistern lernst, wirst du auch herausfinden, dass Threads die wichtigsten Bausteine f\u00fcr deine Musik sind. Eine der wichtigen Aufgaben die sie ausf\u00fchren, ist die aktuellen Einstellungen , die f\u00fcr einen Thread gelten, von anderen Threads zu isolieren. Was genau bedeutet das? Nun, wenn du etwa einen Synth mit use_synth durch einen anderen ersetzt, dann ver\u00e4nderst du den Synth lediglich f\u00fcr den aktuellen Thread - bei keinem anderen der laufenden Threads wird der Synth ersetzt. Sehen wir uns das mal in Aktion an: play 50 sleep 1 in_thread do use_synth :tb303 play 50 end sleep 1 play 50 Bemerke, wie sich der mittlere Klang von den anderen beiden unterschieden hat? Die use_synth -Anweisung hat sich nur auf den Thread ausgewirkt, in dem sie auch stand, aber nicht auf den \u00e4u\u00dferen ausf\u00fchrenden Thread.","title":"Bereich"},{"location":"#vererbung","text":"Wenn du einen neuen Thread mit in_thread erzeugst, wird der neue Thread alle Einstellungen automatisch vom vorherigen Thread erben. Sehen wir uns das an: use_synth :tb303 play 50 sleep 1 in_thread do play 55 end Achte darauf, dass der zweite Ton mit dem :tb303 -Synth gespielt wird, obwohl er in einem anderen Thread l\u00e4uft? Jede der Einstellungen, vorgenommen mit den unterschiedlichen use_* -Ausdr\u00fccken, wird sich genauso verhalten. Wenn neue Threads erzeugt werden, erben sie alle Einstellungen von ihren Eltern. Aber \u00c4nderungen der Einstellungen innerhalb dieser neuen Threads haben umgekehrt keinen Einfluss auf die Eltern.","title":"Vererbung"},{"location":"#threads-benennen","text":"Und schlie\u00dflich k\u00f6nnen wir unseren Threads auch Namen geben: in_thread(name: :bass) do loop do use_synth :prophet play chord(:e2, :m7).choose, release: 0.6 sleep 0.5 end end in_thread(name: :drums) do loop do sample :elec_snare sleep 1 end end Achte auf das Protokoll-Fenster, wenn du diesen Code laufen l\u00e4sst. Siehst du, wie das Protokoll mit den Nachrichten auch die Namen der Threads ausgibt? [Run 36, Time 4.0, Thread :bass] |- synth :prophet, {release: 0.6, note: 47}","title":"Threads benennen"},{"location":"#nur-ein-thread-pro-name-erlaubt","text":"Eine letzte Anmerkung zu Threads mit Namen: Es kann nur ein Thread gleichen Namens zur selben Zeit laufen. Probieren wir das aus. Sieh dir folgenden Code an: in_thread do loop do sample :loop_amen sleep sample_duration :loop_amen end end Kopiere das einmal in einen Puffer und klicke auf Ausf\u00fchren . Klicke noch ein paar mal darauf. H\u00f6r dir diese Kakophonie mehrerer Amen-Breaks an, die rhythmisch nicht unbedingt passend zueinander ablaufen. Ok, du kannst jetzt Stopp klicken. Dieses Verhalten haben wir bereits \u00f6fter gesehen - wenn du die Ausf\u00fchren -Schaltfl\u00e4che klickst, legen sich Kl\u00e4nge \u00fcber alle bereits laufenden Kl\u00e4nge. Wenn du eine Schleife hast und dreimal auf Ausf\u00fchren klickst, bekommst du drei Ebenen mit Schleifen, die gleichzeitig spielen. Bei benannten Threads jedoch ist das anders: in_thread(name: :amen) do loop do sample :loop_amen sleep sample_duration :loop_amen end end Versuche bei diesem Code den Ausf\u00fchren -Schalter mehrmals zu klicken. Du wirst immer nur eine Amen-Break-Schleife h\u00f6ren. Das kannst Du auch im Protokoll sehen: ==> Skipping thread creation: thread with name :amen already exists. Sonic Pi teilt dir mit, dass ein Thread mit dem Namen :amen bereits l\u00e4uft und es deshalb keinen weiteren erzeugt. Vielleicht erscheint dir dieses Verhalten im Moment noch nicht n\u00fctzlich - aber es wird sehr n\u00fctzlich sein, wenn wir ins Live-Coding einsteigen ...","title":"Nur ein Thread pro Name erlaubt"},{"location":"#section-05-5","text":"Wenn du einmal damit angefangen hast gr\u00f6\u00dfere Mengen Programm-Code zu schreiben, dann wirst du nach Wegen suchen, wie du die Dinge organisieren und strukturieren kannst, um sie sauberer und verst\u00e4ndlicher zu machen. Funktionen sind ein sehr wirkungsvoller Weg das zu tun. Sie geben uns die M\u00f6glichkeit, einem Haufen Programm-Code einen Namen zu geben. Sehen wir uns das an.","title":"5.5 Funktionen"},{"location":"#funktionen-definieren","text":"define :foo do play 50 sleep 1 play 55 sleep 2 end Hier haben wir eine neue Funktion mit dem Namen foo definiert. Wir machen das mit unserem alten Freund, dem do/end-Block und dem Zauberwort define , gefolgt von dem Namen, den wir unserer Funktion geben m\u00f6chten. Wir m\u00fcssen die Funktion nicht unbedingt foo nennen, wir k\u00f6nnen sie auch irgendwie anders nennen; zum Beispiel bar , baz oder idealerweise einen f\u00fcr dich bedeutsamen Namen wie haupt_sektion oder hintergrund_akkorde . Denke daran, bei der Definition einer Funktion ihrem Namen einen Doppelpunkt : voranzustellen.","title":"Funktionen definieren"},{"location":"#funktionen-aufrufen","text":"Wenn wir unsere Funktion definiert haben, k\u00f6nnen wir sie \u00fcber die Eingabe ihres Namens aufrufen: define :foo do play 50 sleep 1 play 55 sleep 0.5 end foo sleep 1 2.times do foo end Wir k\u00f6nnen foo sogar in Blocks mit Iterationen verwenden - oder \u00fcberall da, wo wir sonst auch play oder sample schreiben w\u00fcrden. Das gibt uns eine sehr weit gehende M\u00f6glichkeit uns auszudr\u00fccken, und k\u00f6nnen sinnvolle Worte einsetzen, um sie in unseren Kompositionen zu verwenden.","title":"Funktionen aufrufen"},{"location":"#funktionen-bleiben-in-erinnerung","text":"Wenn du bisher auf Ausf\u00fchren geklickt hast, ist Sonic Pi jedes Mal aufs Neue ohne irgendwelche Vorgaben gestartet. Es ber\u00fccksichtigt dabei nichts, au\u00dfer dem, was im jeweiligen Puffer steht. Du kannst dich nicht auf irgendwelchen Programm-Code beziehen, der in einem anderen Puffer oder in einem anderen Thread steht. Funktionen \u00e4ndern das jedoch. Wenn du eine Funktion definierst, dann erinnert sich Sonic Pi daran. Probieren wir das aus. L\u00f6sche den gesamten Code in deinem Puffer und ersetze ihn durch: foo Klicke auf Ausf\u00fchren - und h\u00f6re deine Funktion spielen. Wo wurde dieser Code gespeichert? Woher wusste Sonic Pi, was es zu spielen hat? Sonic Pi hat sich deine Funktion einfach gemerkt - sogar, nachdem du den Programm-Code aus dem Puffer gel\u00f6scht hast, wusste Sonic Pi noch, was du geschrieben hattest. Dies funktioniert nur mit Funktionen, die du mit define (und defonce ) erzeugt hast.","title":"Funktionen bleiben in Erinnerung"},{"location":"#funktionen-parametrisieren","text":"Es wird dich vielleicht interessieren, dass so wie du rrand einen Minimal- und Maximalwert \u00fcbergeben kannst, du auch deinen Funktionen beibringen kannst Argumente zu akzeptieren. Sehen wir uns das an: define :my_player do |n| play n end my_player 80 sleep 0.5 my_player 90 Das ist nicht besonders aufregend, zeigt aber, worum es hier geht. Wir haben unsere eigene Version von play mit dem Namen my_player erschaffen. Diese ist parametrisiert - sie akzeptiert also Argumente. Die Parameter m\u00fcssen hinter dem do des define -do/end-Blocks stehen, umgeben von senkrechten Strichen (pipes) | und durch Kommas , getrennt. Du kannst beliebige W\u00f6rter als Parameternamen verwenden. Die Magie passiert innerhalb des define -do/end-Blocks. Du kannst die Parameternamen so benutzen, als w\u00e4ren sie wirkliche Werte. In diesem Beispiel spiele ich den Ton n . Du kannst die Parameter als eine Art Versprechen ansehen, dass wenn der Programm-Code l\u00e4uft, sie durch wirkliche Werte ersetzt werden. Du machst das, indem du der Funktion beim Aufruf einen Parameter mitgibst. Ich tue das hier mit my_player 80 , um die Note 80 zu spielen. Innerhalb der Funktionsdefinition wird n nun durch 80 ersetzt, sodass play n sich in play 80 verwandelt. Wenn ich die Funktion erneut mit my_player 90 aufrufe, wird n durch 90 ersetzt, sodass sich jetzt play n in play 90 verwandelt. Sehen wir uns ein interessanteres Beispiel an: define :chord_player do |root, repeats| repeats.times do play chord(root, :minor), release: 0.3 sleep 0.5 end end chord_player :e3, 2 sleep 0.5 chord_player :a3, 3 chord_player :g3, 4 sleep 0.5 chord_player :e3, 3 Hier habe ich repeats so benutzt, als ob es eine Zahl in der Zeile repeats.times do w\u00e4re. Zus\u00e4tzlich habe ich roots so verwendet, als ob es ein Notenname in meinem Aufruf von play w\u00e4re. Sieh dir an, wie wir hier etwas sehr Ausdrucksstarkes und leicht zu Lesendes schreiben konnten, indem wir vieles von unserer Programmlogik in Funktionen verschieben!","title":"Funktionen parametrisieren"},{"location":"#section-05-6","text":"Beim Programmieren ist es sehr n\u00fctzlich, Namen f\u00fcr Dinge zu vergeben. Sonic Pi vereinfacht dies sehr: Du schreibst den Namen, den du verwenden m\u00f6chtest, dann ein Gleichheitszeichen ( = ) und dann das Ding, welches du dir merken m\u00f6chtest: sample_name = :loop_amen Hier haben wir uns das Symbol :loop_amen mit der Variablen sample_name gemerkt . Wir k\u00f6nnen nun sample_name \u00fcberall da verwenden, wo wir auch loop_amen verwenden w\u00fcrden. Zum Beispiel: sample_name = :loop_amen sample sample_name Es gibt drei wesentliche Gr\u00fcnde Variablen in Sonic Pi zu nutzen: Bedeutung vermitteln, Wiederholung steuern und Ergebnisse erfassen und speichern.","title":"5.6 Variablen"},{"location":"#bedeutung-vermitteln","text":"Wenn du Programm-Code schreibst, ist es leicht zu denken, dass du dem nur Computer sagst, wie er etwas tun soll - solange der Computer das versteht, ist das in Ordnung. Vergiss aber nicht, dass nicht nur der Computer deinen Code lesen wird. Andere Leute k\u00f6nnten den Code auch lesen und versuchen zu verstehen, was da vor sich geht. Es ist m\u00f6glich, dass du den Code sp\u00e4ter auch selbst noch einmal lesen wirst und verstehen willst, was er bedeutet. Obwohl dir jetzt alles noch ganz offensichtlich erscheint - wahrscheinlich ist es f\u00fcr andere nicht ganz so offensichtlich und vielleicht auch nicht f\u00fcr dich in der Zukunft! Ein Weg um andere darin zu unterst\u00fctzen deinen Programm-Code zu verstehen, ist das Schreiben von Kommentaren (wie wir im vorherigen Abschnitt gesehen haben). Ein andererr besteht darin sinnvolle Namen f\u00fcr deine Variablen verwenden. Sie dir diesen Code an: sleep 1.7533 Warum steht hier die Zahl 1.7533 ? Woher kommt diese Zahl? Was bedeutet sie? Sieh dir zum Vergleich diesen Code an: loop_amen_duration = 1.7533 sleep loop_amen_duration Nun, es ist viel klarer, was 1.7533 bedeutet: Es ist die Dauer des Samples :loop_amen ! Nat\u00fcrlich k\u00f6nntest du jetzt sagen, warum nicht einfach schreiben: sleep sample_duration(:loop_amen) Was nat\u00fcrlich auch ein sehr guter Weg ist, die Absicht hinter dem Code mitzuteilen.","title":"Bedeutung vermitteln"},{"location":"#wiederholungen-steuern","text":"Oft wirst du in deinem Programm-Code Wiederholungen begegnen, und wenn du eine Sache \u00e4ndern willst, musst du das an vielen Stellen tun. Schau dir diesen Code an: sample :loop_amen sleep sample_duration(:loop_amen) sample :loop_amen, rate: 0.5 sleep sample_duration(:loop_amen, rate: 0.5) sample :loop_amen sleep sample_duration(:loop_amen) Wir machen hier eine ganze Menge mit dem :loop_amen ! Was w\u00e4re, wenn wir es mit einem anderen Loop-Sample h\u00f6ren wollten, wie zum Beispiel :loop_garzul ? Wir m\u00fcssten alle :loop_amen suchen und mit :loop_garzul ersetzen. Das mag in Ordnung sein, wenn du viel Zeit hast - aber was, wenn du gerade auf der B\u00fchne stehst und performst? Manchmal hast du nicht den Luxus der Zeit - vor allem dann nicht, wenn du willst, dass die Leute weiter tanzen. Was w\u00e4re, wenn du den Code so geschrieben h\u00e4ttest: sample_name = :loop_amen sample sample_name sleep sample_duration(sample_name) sample sample_name, rate: 0.5 sleep sample_duration(sample_name, rate: 0.5) sample sample_name sleep sample_duration(sample_name) Das tut genau dasselbe wie der Code weiter oben (probiere es aus). Und es gibt uns auch die M\u00f6glichkeit, dass wir nur eine Zeile von sample_name = :loop_amen in sample_name = :loop_garzul \u00e4ndern - und damit zugleich an vielen anderen Stellen durch die Magie der Variablen.","title":"Wiederholungen steuern"},{"location":"#ergebnisse-speichern","text":"Schlie\u00dflich, eine gute Motivation Variablen zu verwenden ist die Ergebnisse von etwas festzuhalten. Z. B. m\u00f6chtest du vielleicht irgendetwas mit der Dauer eines Samples anstellen: sd = sample_duration(:loop_amen) Wir k\u00f6nnen nun sd \u00fcberall dort einsetzen, wo wir die L\u00e4nge von :loop_amen brauchen. Vielleicht noch wichtiger, erlaubt uns eine Variable das Ergebnis eines Aufrufs von play oder sample zu speichern: s = play 50, release: 8 Jetzt haben wir s als Variable festgehalten und gespeichert, das erlaubt es uns einen Synth zu steuern, w\u00e4hrend er l\u00e4uft: s = play 50, release: 8 sleep 2 control s, note: 62 Wir werden uns die Steuerung von Synths in einem sp\u00e4teren Abschnitt noch detaillierter ansehen.","title":"Ergebnisse speichern"},{"location":"#warnung-variablen-und-threads","text":"W\u00e4hrend Variablen sehr gut dazu geeignet sind, Dingen Namen zu geben oder ein Ergebnis festzuhalten, ist es wichtig zu wissen, dass sie typischerweise nur im lokalen Kontext eines Threads verwendet werden sollten. Zum Beispiel, tu das hier nicht : a = (ring 6, 5, 4, 3, 2, 1) live_loop :sorted do a = a.sort sleep 0.5 puts \"sorted: \", a end live_loop :shuffled do a = a.shuffle sleep 0.5 end In dem Beispiel oben weisen wir einen Ring aus Zahlen einer Variablen a zu und verwenden sie dann in zwei separaten live_loop . Innerhalb der ersten Schleife sortieren wir alle 0.5 Sekunden den Ring (zu (ring 1, 2, 3, 4, 5, 6) ) und geben dies im Protokoll aus. Wenn du nun den Code ausf\u00fchrst, wirst du bemerken, dass die ausgegebene Liste nicht immer sortiert ist! . Das k\u00f6nnte dich \u00fcberraschen - insbesondere, da manchmal die Liste sortiert ist und manchmal nicht. Dies wird als nicht-vorhersagbares Verhalten bezeichnet, und ist das Ergebnis eines eher \u00fcblen Problems, 'Race-Condition' genannt. Das Problem resultiert aus der Tatsache, dass die zweite Schleife ebenfalls die Liste ver\u00e4ndert (in diesem Fall wird sie gemischt) und zum Zeitpunkt der Ausgabe die Liste manchmal sortiert und manchmal gemischt ist. Beide Schleifen befinden sich im Wettlauf miteinander die selbe Variable zu ver\u00e4ndern, und es gewinnt manchmal die eine und manchmal die andere. Hierzu gibt es zwei L\u00f6sungen: Zun\u00e4chst, verwende nie die gleiche Variable in mehreren Live-Loops oder Threads . Beispielsweise gibt der folgende Code die Liste immer richtig sortiert aus, da jeder Live-Loop eine eigene Variable verwendet: live_loop :shuffled do a = (ring 6, 5, 4, 3, 2, 1) a = a.shuffle sleep 0.5 end live_loop :sorted do a = (ring 6, 5, 4, 3, 2, 1) a = a.sort sleep 0.5 puts \"sorted: \", a end Allerdings wollen wir manchmal auch Werte zwischen verschiedene Threads teilen, zum Beispiel die aktuelle Tonart, BPM , den aktuellen Synth etc. In diesen F\u00e4llen ist die beste L\u00f6sung Sonic Pi spezielles Thread-Safe-State-System mit Hilfe der Funktionen get und set zu verwenden. Dies werden wir etwas sp\u00e4ter in Abschnitt 10 behandeln.","title":"Warnung: Variablen und Threads"},{"location":"#section-05-7","text":"Sobald du ausreichend vertraut damit bist, mit mehreren gleichzeitig ablaufenden Funktionen und Threads live zu programmieren, wirst du bemerken, dass es ziemlich leicht ist in einem einzelnen Thread einen Fehler zu machen, der ihn zum Absturz bringt. Das ist nicht weiter schlimm, da du den Thread ja mit einem Klick auf Ausf\u00fchren einfach neu starten kannst. Wenn du den Thread aber neu startest, dann l\u00e4uft er nicht mehr im Takt mit den anderen Threads.","title":"5.7 Threads synchronisieren"},{"location":"#vererbte-zeit","text":"Wie wir bereits vorher gesehen haben, erben neue Threads die mit in_thread erzeugt werden alle ihre Einstellungen von einem Eltern-Thread. Das schlie\u00dft auch die aktuelle Zeit mit ein. Das bedeutet, dass Threads immer miteinander im Takt sind, wenn sie gleichzeitig gestartet werden. Wenn du aber einen Thread f\u00fcr sich alleine startest, spielt dieser in seinem eigenen Takt, der wahrscheinlich nicht mit irgendeinem der anderen gerade laufenden Threads synchron ist.","title":"Vererbte Zeit"},{"location":"#cue-und-sync","text":"Sonic Pi bietet mit den Funktionen cue und sync eine L\u00f6sung f\u00fcr dieses Problem. cue erlaubt es uns, mit einem Taktgeber regelm\u00e4\u00dfig Signale an alle anderen Threads zu versenden. Normalerweise zeigen die anderen Threads an solchen Takt-Signalen kein Interesse und ignorieren sie. Mit der sync -Funktion kann du jedoch erreichen, dass ein anderer Thread Interesse zeigt. Wichtig ist dabei sich dar\u00fcber bewusst zu sein, dass sync \u00e4hnlich wie sleep funktioniert, indem es den aktuellen Thread f\u00fcr eine bestimmte Dauer anh\u00e4lt. Allerdings legst du bei sleep fest, wie lange du warten willst, w\u00e4hrend du bei sync nicht wei\u00dft, wie lange gewartet werden wird - da sync auf den n\u00e4chsten cue eines anderen Threads wartet - was eine k\u00fcrzere oder l\u00e4ngere Dauer sein kann. Sehen wir uns das im Detail an: in_thread do loop do cue :tick sleep 1 end end in_thread do loop do sync :tick sample :drum_heavy_kick end end Hier haben wir zwei Threads - einer arbeitet wie ein Metronom, er spielt nichts, aber sendet bei jedem Schlag das Taktgeber-Signal :tick . Der zweite Thread synchronisiert sich mit den tick -Signalen, und wenn er ein Signal erh\u00e4lt, erbt er dadurch den Takt vom cue -Thread und l\u00e4uft weiter. Im Ergebnis h\u00f6ren wir das :drum_heavy_kick -Sample genau dann, wenn der andere Thread das :tick -Signal sendet, auch dann wenn die Ausf\u00fchrung beider Threads gar nicht zur selben Zeit gestartet war: in_thread do loop do cue :tick sleep 1 end end sleep(0.3) in_thread do loop do sync :tick sample :drum_heavy_kick end end Der dreiste Aufruf von sleep w\u00fcrde normalerweise den zweiten Thread gegen\u00fcber dem ersten aus dem Takt bringen. Da wir jedoch cue und sync verwenden, synchronisieren wir beide Threads automatisch und umgehen dabei ungewollte Abweichungen in der Zeit.","title":"Cue und Sync"},{"location":"#cue-namen","text":"Du kannst deine cue -Signale benennen, wie du willst - nicht nur mit :tick . Du musst nur sicherstellen, dass jegliche anderen Threads, die sich mit sync synchronisieren, auch diesen Namen verwenden - ansonsten werden sie endlos warten (oder zumindest so lange bis du auf Stopp klickst). Lass uns mit ein paar Namen f\u00fcr cue spielen: in_thread do loop do cue [:foo, :bar, :baz].choose sleep 0.5 end end in_thread do loop do sync :foo sample :elec_beep end end in_thread do loop do sync :bar sample :elec_flip end end in_thread do loop do sync :baz sample :elec_blup end end Hier haben wir eine taktgebende cue -Schleife, die auf Zufallsbasis einen der drei Taktgeber-Namen :foo , :bar oder :baz aussendet. Wir haben au\u00dferdem drei Schleifen-Threads, die sich unabh\u00e4ngig voneinander, jeder f\u00fcr sich, mit einem der Namen synchronisieren und dann jeweils ein anderes Sample spielen. Im Endeffekt h\u00f6ren wir jeden halben Schlag einen Klang, da jeder der sync -Threads mit dem cue -Thread auf Zufallsbasis synchronisiert ist und entsprechend sein Sample abspielt. Das funktioniert nat\u00fcrlich auch, wenn du die Reihenfolge der Threads umkehrst, da die sync -Threads einfach dasitzen und auf den n\u00e4chsten cue warten.","title":"Cue-Namen"},{"location":"#section-06","text":"Einer der lohnendsten und unterhaltsamsten Aspekte von Sonic Pi ist, dass du deinen Kl\u00e4ngen sehr einfach Studio-Effekte hinzuf\u00fcgen kannst. Zum Beispiel m\u00f6chtest du vielleicht Teilen deines St\u00fcckes etwas Hall (Reverb) hinzuf\u00fcgen, oder etwas Echo, oder vielleicht sogar deine Basslinien verzerren (Distortion) oder wabern lassen (Wobble). Sonic Pi bietet einen sehr einfachen aber m\u00e4chtigen Weg Effekte hinzuzuf\u00fcgen. Es erlaubt dir sogar sie miteinander verketten (so dass du einen Klang durch Verzerrung, dann Echo und dann Hall schicken kannst) und auch jeden Effekt einzeln mit Parametern zu steuern (ganz \u00e4hnlich wie Parameter an Synths und Samples \u00fcbergeben werden). Du kannst die Parameter eines Effektes sogar \u00e4ndern, w\u00e4hrend er noch l\u00e4uft. Zum Beispiel k\u00f6nntest du so den Hall auf deiner Basslinie im Verlauf des St\u00fcckes anheben ...","title":"6 Effekte"},{"location":"#gitarren-pedale","text":"Wenn sich das alles etwas kompliziert anh\u00f6ren sollte, keine Sorge! Wenn du ein wenig damit herumspielst, wird dir das alles ziemlich klar erscheinen. Aber bevor du loslegst: Ein einfacher Vergleich ist der mit Effektpedalen f\u00fcr Gitarren. Es gibt viele Arten solcher Effektpedale. Manche f\u00fcgen Hall hinzu, andere verzerren etc. Eine Gitarristin oder ein Gitarrist w\u00fcrde ihre bzw. seine Gitarre an ein Effektpedal anstecken - z. B. einen Verzerrer - und dann ein weiteres Kabel nehmen und noch ein Hall-Effektpedal verbinden (verketten). Der Ausgang des Hall-Effektpedals kann dann an einen Verst\u00e4rker angesteckt werden: Gitarre -> Verzerrer -> Hall -> Verst\u00e4rker So etwas nennt sich Effektkette. Und das ist genau das, was Sonic Pi unterst\u00fctzt. Zus\u00e4tzlich haben Effektpedale oftmals einige Drehkn\u00f6pfe und Schieberegler, die dir erlauben zu steuern, wieviel Verzerrung, Hall, oder Echo hinzugef\u00fcgt werden sollen. Sonic Pi unterst\u00fctzt auch diese Art der Steuerung. Und abschlie\u00dfend stell dir einmal, wie eine Person Gitarre spielt, w\u00e4hrend eine andere die Effekte steuert, w\u00e4hrend sie spielt. Sonic Pi unterst\u00fctzt das auch - aber anstatt f\u00fcr die Effekt-Steuerung auf eine andere Person angewiesen zu sein, springt hier der Computer ein. Lass uns Effekte ausprobieren!","title":"Gitarren-Pedale"},{"location":"#section-06-1","text":"In diesem Abschnitt sehen wir uns zwei Effekte an: Hall und Echo. Wir werden sehen, wie diese Effekte verwendet werden, wie ihre Parameter gesteuert werden, und wie sie verketten werden. Das Effekt-System von Sonic Pi verwendet so genannte Code-Bl\u00f6cke. Falls du Abschnitt 5.1 des Tutorials noch nicht gelesen hast, wirf einen kurzen Blick darauf und komme dann hierher zur\u00fcck.","title":"6.1 Effekte hinzuf\u00fcgen"},{"location":"#hall","text":"Um den Hall-Effekt zu benutzen schreiben wir with_fx :reverb als speziellen Programm-Code zu unserem Code-Block. Und zwar so: with_fx :reverb do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end F\u00fchre diesen Code-Block aus, und du wirst ihn mit Hall h\u00f6ren. H\u00f6rt sich gut an, nicht wahr! t Mit Hall h\u00f6rt sich alles recht h\u00fcbsch an. Lass uns schauen, was passiert, wenn wir Programm-Code au\u00dferhalb des do/end-Blocks hinzuf\u00fcgen: with_fx :reverb do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end sleep 1 play 55 Beachte wie das letzte play 55 nicht mit Hall abgespielt wird. Der Grund daf\u00fcr ist, dass es sich au\u00dferhalb des do/end-Blocks befindet und deshalb nicht von unserem Hall erfasst wird. Entsprechend werden Kl\u00e4nge, die du vor dem do/end-Block einf\u00fcgst, auch nicht von dem Hall-Effekt erfasst: play 55 sleep 1 with_fx :reverb do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end sleep 1 play 55","title":"Hall"},{"location":"#echo","text":"Es stehen viele Effekte zur Auswahl. Wie w\u00e4re es mit etwas Echo? with_fx :echo do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end Einer der machtvollen Aspekte von Effekt-Bl\u00f6cken in Sonic PI ist, dass wir ihnen opts \u00fcbergeben k\u00f6nnen, genauso wie wir es schon bei play und sample gesehen haben. Ein spannender Echo-Parameter ist zum Beispiel phase: , der die Dauer des Echos in Beats darstellt. Lass uns das Echo langsamer machen: with_fx :echo, phase: 0.5 do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end Lass uns das Echo auch schneller machen: with_fx :echo, phase: 0.125 do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end Lassen wir nun das Echo langsamer ausschwingen, indem wir den decay: -Wert auf 8 Schl\u00e4ge setzen: with_fx :echo, phase: 0.5, decay: 8 do play 50 sleep 0.5 sample :elec_plip sleep 0.5 play 62 end","title":"Echo"},{"location":"#effekte-verschachteln","text":"Einer der m\u00e4chtigsten Aspekte von Effekt-Bl\u00f6cken ist, dass du sie verschachteln kannst. Das erlaubt dir Effekte ganz einfach aneinanderzuh\u00e4ngen. Was, zum Beispiel, wenn du einen Code-Block zuerst mit Echo und dann mit Hall versehen willst? Ganz einfach, verschachtele die Code-Bl\u00f6cke ineinander: with_fx :reverb do with_fx :echo, phase: 0.5, decay: 8 do play 50 sleep 0.5 sample :elec_blup sleep 0.5 play 62 end end Stell dir das was du h\u00f6rst, als etwas vor, das von innen nach au\u00dfen flie\u00dft. Der Klang aus dem gesamten Programm-Code im inneren do/end-Block, wie play 50 , wird zuerst zu dem Echo-Effekt gesendet, und der Echo-Effekt danach zu dem Hall-Effekt. Wir k\u00f6nnen sehr tiefe Verschachtelungen verwenden und verr\u00fcckte Ergebnisse erzielen. Aber sei gewarnt, die Effekte k\u00f6nnen eine Menge Ressourcen verbrauchen, und wenn du sie verschachtelst, l\u00e4sst du effektiv mehrere Effekte gleichzeitig laufen. Sei also sparsam bei deinem Gebrauch von Effekten, besonders auf nicht so kraftvollen Plattformen wie dem Raspberry Pi.","title":"Effekte verschachteln"},{"location":"#effekte-entdecken","text":"Sonic Pi bringt eine Vielzahl von Effekten mit, die du verwenden kannst. Um herauszufinden, welche verf\u00fcgbar sind, klicke links unten im Men\u00fc des Hilfe-Fensters auf FX, und du siehst eine Liste der verf\u00fcgbaren Optionen. Hier eine Liste einiger meiner Favoriten: Wobble, Reverb, Echo, Distortion, Slicer Nun werde wild und f\u00fcge \u00fcberall Effekte hinzu - f\u00fcr ein paar tolle neue Kl\u00e4nge!","title":"Effekte entdecken"},{"location":"#section-06-2","text":"Auch wenn sie \u00e4u\u00dferlich sehr einfach aussehen, sind Effekte in Sonic Pi doch h\u00f6chst komplexe Gebilde. Ihre anscheinende Einfachheit verleitet Leute oft dazu, zu viele Effekte in ihren St\u00fccken zu verwenden. Das mag Spa\u00df machen, wenn du \u00fcber einen sehr starken Computer verf\u00fcgst. Aber falls du - so wie ich - einen Raspberry Pi zum Jammen benutzt, musst du darauf achten, wieviel Arbeit du der Maschine abverlangst, wenn du sicher gehen willst, dass die Beats weiter im Takt laufen. Sieh dir den folgenden Programm-Code an: loop do with_fx :reverb do play 60, release: 0.1 sleep 0.125 end end In diesem Programm-Code spielen wir die Note 60 mit einer sehr kurzen Release-Zeit und erzeugen somit einen kurze Note. Wir wollen au\u00dferdem einen Hall-Effekt, also haben wir ihn in einen Reverb-Block gepackt. Soweit ist alles gut, abgesehen von ... Lass uns ansehen, was der Code hier macht. Zun\u00e4chst haben wir einen loop -Befehl, was bedeutet, dass alles darin f\u00fcr immer in einer Schleife wiederholt wird. Dann haben wir einen with_fx: -do/end-Block. Das bedeutet, dass wir mit jeder Wiederholung der Schleife einen neuen Hall-Effekt erzeugen. Und das ist so, als ob wir f\u00fcr jedes Mal, wenn wir eine Gitarrenseite spielen, ein zus\u00e4tzliches Hall-Effekt-Pedal an die Effektkette h\u00e4ngen w\u00fcrden. Es ist cool, dass du das machen kannst, aber es ist m\u00f6glicherweise nicht das, was du eigentlich willst. So wird zum Beispiel dieser Programm-Code Schwierigkeiten haben fl\u00fcssig auf einem Raspberry Pi zu laufen. Die gesamte Arbeit den Hall zu erzeugen und dann abzuwarten, bis er gestoppt und entfernt werden muss, wird von with_fx: f\u00fcr dich erledigt - daf\u00fcr werden Prozessor-Ressourcen ben\u00f6tigt, die vielleicht anderweitig wertvoll w\u00e4ren. Wie k\u00f6nnen wir einen Code-Block schreiben, der einem traditionellen Aufbau entspricht, bei dem die Gitarre nur ein Hall-Effekt-Pedal benutzt, durch das der gesamte Klang geschickt wird? Einfach: with_fx :reverb do loop do play 60, release: 0.1 sleep 0.125 end end Wir haben unsere Schleife ins Innere des with_fx: -Blocks gepackt. So erzeugen wir nur noch einen einzelnen Hall-Effekt f\u00fcr alle Noten, die in der Schleife gespielt werden. Dieser Programm-Code ist sehr viel effizienter und w\u00fcrde auch auf einem Raspberry Pi gut funktionieren. Ein Kompromiss ist with_fx: \u00fcber eine Iteration innerhalb einer Schleife zu verwenden: loop do with_fx :reverb do 16.times do play 60, release: 0.1 sleep 0.125 end end end Somit wird die with_fx: -Funktion aus dem Inneren Teil der Schleife geholt, und der Programm-Code erzeugt jetzt nur noch alle 16 Noten einen neuen Hall-Effekt. Dieser Muster taucht so h\u00e4ufig auf, dass with_fx eine Option akzeptiert, die erlaubt genau dies zu tun, ohne den 16.times -Block zu schreiben: loop do with_fx :reverb, reps: 16 do play 60, release: 0.1 sleep 0.125 end end Beide, das reps: 16 - und das 16.times do -Beispiel verhalten sich identisch. reps: 16 wiederholt den Programm-Code im do/end -Block 16 mal, sodass du beide Ausdr\u00fccke austauschbar verwenden und den ausw\u00e4hlen kannst, der sich am besten f\u00fcr dich anf\u00fchlt. Denke daran, es gibt keine Fehler, nur M\u00f6glichkeiten! Wie auch immer, einige dieser Ans\u00e4tze werden sich klanglich unterscheiden und auch unterschiedlich verhalten. Spiel also herum, und verwende den Ansatz, der f\u00fcr dich am besten klingt und zugleich innerhalb der Beschr\u00e4nkungen deiner Plattform funktioniert.","title":"6.2 Praktische Anwendung von Effekten"},{"location":"#section-07","text":"Bisher haben wir uns angesehen, wie du Synths und Samples starten und ihre Standard-Parameter wie Lautst\u00e4rke, Position im Stereofeld, H\u00fcllkurven und so weiter anpassen kannst. Jeder gespielte Klang ist im Grunde genommen ein eigener Klang mit einer eigenen Liste an Optionen, gesetzt f\u00fcr die Dauer, w\u00e4hrend der er klingt. W\u00e4re es nicht auch cool, wenn du die Parameter eines Klanges ver\u00e4ndern k\u00f6nntest - noch w\u00e4hrend er erklingt - etwa so, wie du an einer Gitarrensaite ziehen w\u00fcrdest, w\u00e4hrend sie noch schwingt? Gl\u00fcck gehabt - dieser Abschnitt wird dir zeigen, wie du genau das tun kannst.","title":"7 Steuerung"},{"location":"#section-07-1","text":"Bisher haben wir uns nur damit befasst neue Kl\u00e4nge und Effekte zu triggern. Mit Sonic Pi kannst du aber laufende Kl\u00e4nge auch steuern und ver\u00e4ndern. Um das zu tun, fassen wir eine Referenz zu einem Synth in einer Variable: s = play 60, release: 5 Jetzt haben wir eine lokal ausgef\u00fchrte Variable s , die einen Synth repr\u00e4sentiert, der die Note 60 spielt. Beachte, dass sie lokal ausgef\u00fchrt wird - das bedeutet, du kannst nicht von andere Ausf\u00fchrungen, wie z. B. Funktionen auf sie zugreifen. Sobald wir s gesetzt haben, k\u00f6nnen wir es mit der control -Funktion steuern: s = play 60, release: 5 sleep 0.5 control s, note: 65 sleep 0.5 control s, note: 67 sleep 3 control s, note: 72 Wichtig zu bemerken ist hier, dass wir nicht 4 verschiedene Synths starten - wir starten nur einen Synth und \u00e4ndern dann seine Tonh\u00f6he dreimal im Nachhinein, w\u00e4hrend er noch spielt. Wir k\u00f6nnen jeden der Standard-Parameter an die control -Funktion \u00fcbergeben, so kannst du Dinge wie amp: , cutoff: oder pan: steuern.","title":"7.1 Steuerung laufender Synths"},{"location":"#nicht-steuerbare-parameter","text":"Manche der Optionen k\u00f6nnen nach dem Start des Synths nicht mehr kontrolliert werden. Das ist der Fall bei allen ADSR-H\u00fcllkurven-Parametern. Welche Opts steuerbar sind, kannst du herausfinden, indem du ihre Dokumentation im Hilfe-Fenster ansiehst. Wenn dort steht Can not be changed once set , dann wei\u00dft du, dass es nicht m\u00f6glich ist diese Option zu steuern, nachdem der Synth gestartet ist.","title":"Nicht-steuerbare Parameter"},{"location":"#section-07-2","text":"Es ist auch m\u00f6glich Effekte zu steuern, allerdings funktioniert das ein wenig anders: with_fx :reverb do |r| play 50 sleep 0.5 control r, mix: 0.7 play 55 sleep 1 control r, mix: 0.9 sleep 1 play 62 end Anstatt eine Variable zu verwenden, nutzen wir die Parameter zwischen den so genannten Pipes des do/end-Blocks. Innerhalb dieser Pipes | , m\u00fcssen wir einen eindeutigen Namen f\u00fcr unseren laufenden Effekt vergeben, den wir dann innerhalb des do/end-Blocks verwenden. Dieses Verhalten ist das gleiche wie bei parametrisierten Funktionen. Jetzt los - steuere ein paar Synths und Effekte!","title":"7.2 Steuerung von Effekten"},{"location":"#section-07-3","text":"W\u00e4hrend du die Synth- und Effekt-Optionen erforscht hast, ist dir vielleicht aufgefallen, dass einige von ihnen auf _slide enden. Vielleicht hast du sogar ausprobiert sie aufzurufen und keinen Effekt bemerkt. Das liegt daran, dass dies keine normalen Parameter sind, sie sind besondere Opts, die nur dann funktionieren, wenn du Synths steuerst, wie im letzten Abschnitt beschrieben. Schau dir das folgende Beispiel an: s = play 60, release: 5 sleep 0.5 control s, note: 65 sleep 0.5 control s, note: 67 sleep 3 control s, note: 72 Hier kannst du h\u00f6ren, wie sich die Tonh\u00f6he des Synth unmittelbar bei jedem Aufruf von control \u00e4ndert. Vielleicht m\u00f6chtest du aber, dass die Tonh\u00f6he sich gleitend zwischen den Aufrufen ver\u00e4ndert. Wenn wir die Opt note: verwenden, m\u00fcssen wir, um gleitende \u00dcberg\u00e4nge zu erhalten, den note_slide: -Parameter des Synth setzen: s = play 60, release: 5, note_slide: 1 sleep 0.5 control s, note: 65 sleep 0.5 control s, note: 67 sleep 3 control s, note: 72 Nun h\u00f6ren wir, wie die Noten zwischen den control -Aufrufen gezogen werden. H\u00f6rt sich gut an, oder? Mit einer k\u00fcrzeren Dauer wie beispielsweise note_slide: 0,2 kannst du den \u00dcbergang beschleunigen, oder ihn mit einer l\u00e4ngeren Slide-Dauer verlangsamen. Jeder steuerbare Parameter hat einen entsprechenden _slide -Parameter, mit dem du spielen kannst.","title":"7.3 Gleitende Parameter"},{"location":"#gleiten-ist-klebrig","text":"Nachdem du einmal einen _slide Parameter auf einem laufenden Synth gesetzt hast, wird er erinnert - und er wird jedes mal genutzt, wenn du den dazu geh\u00f6renden Parameter nutzt. Um das Gleiten zu stoppen, musst du den _slide Wert vor dem n\u00e4chsten control -Aufruf auf 0 setzen.","title":"Gleiten ist klebrig"},{"location":"#gleitende-effekt-parameter","text":"Es ist ebenso m\u00f6glich, Effekt-Opts gleiten zu lassen: with_fx :wobble, phase: 1, phase_slide: 5 do |e| use_synth :dsaw play 50, release: 5 control e, phase: 0.025 end Und jetzt hab Spa\u00df damit die Dinge ein wenig herumgleiten zu lassen - f\u00fcr weiche \u00dcberg\u00e4nge und Steuerung der Abl\u00e4ufe ...","title":"Gleitende Effekt-Parameter"},{"location":"#section-08","text":"Ein sehr praktisches Werkzeug im Werkzeugkasten jeder Programmiererin und jedes Programmierers sind Datenstrukturen. Manchmal m\u00f6chtest du mehr als ein einzelnes Ding darstellen oder verwenden. Du k\u00f6nntest z. B. n\u00fctzlich finden, eine Reihe von Noten zu haben und sie dann nacheinander abzuspielen. Programmiersprachen verwenden Datenstrukturen f\u00fcr genau diesen Zweck. Es gibt einige aufregende und exotische Datenstrukturen die Programmiererinnen und Programmierern zur Verf\u00fcgung stehen - und es werden immer noch weitere erfunden. F\u00fcr unsere Zwecke jedoch ben\u00f6tigen wir vorerst nur eine, sehr einfache, Datenstruktur - die Liste. Lass uns das im Detail ansehen. Wir werden uns die Grundform einer Liste anschauen und wie man sie verwendet, um Skalen und Akkorde abzubilden.","title":"8 Datenstrukturen"},{"location":"#section-08-1","text":"In diesem Abschnitt werden wir uns eine sehr n\u00fctzliche Datenstruktur ansehen - die Liste. Wir hatten schon einmal in dem Abschnitt \u00fcber Zuf\u00e4lligkeit kurz mit ihr zu tun, als wir die zu spielenden Noten zuf\u00e4llig aus einer Liste ausgew\u00e4hlt haben: play choose([50, 55, 62]) In diesem Abschnitt erforschen wir, wie wir Akkorde und Skalen mit Listen darstellen k\u00f6nnen. Zuerst rufen wir uns wieder in Erinnerung, wie wir einen Akkord spielen k\u00f6nnten. Erinnere dich, dass ohne sleep alle T\u00f6ne zur gleichen Zeit gespielt werden: play 52 play 55 play 59 Lass uns weitere M\u00f6glichkeiten ansehen diesen Programm-Code zu schreiben.","title":"8.1 Listen"},{"location":"#abspielen-einer-liste","text":"Eine M\u00f6glichkeit ist, alle Noten aus einer Liste heraus abzuspielen: [52, 55, 59] . Unsere freundliche Funktion play ist schlau genug, um zu wissen, wie man eine Liste von Noten abspielt. Probiere es aus: play [52, 55, 59] Oh, das l\u00e4sst sich schon viel besser lesen. Eine Liste von Noten abzuspielen hindert dich nicht daran, alle Parameter so zu verwenden wie sonst auch: play [52, 55, 59], amp: 0.3 Nat\u00fcrlich kannst du auch die traditionellen Notennamen anstelle der MIDI-Nummern verwenden: play [:E3, :G3, :B3] Die Gl\u00fccklichen unter euch, die ein wenig Musiktheorie gelernt haben, haben den Akkord vielleicht erkannt: Es ist E-Moll , gespielt in der 3. Oktave.","title":"Abspielen einer Liste"},{"location":"#auf-listen-zugreifen","text":"Ein weiteres sehr n\u00fctzliches Merkmal von Listen ist, dass man die in ihnen enthaltenen Informationen auslesen kann. Das klingt vielleicht etwas eigenartig, aber es ist nicht komplizierter, als eine Person zu bitten Seite 23 in einem Buch aufzuschlagen. Eine Liste fragst du einfach, was das Element mit der Indexnummer 23 ist. Das einzig seltsame in diesem Fall ist , dass beim Programmieren Indizes \u00fcblicherweise bei 0 beginnen - nicht bei 1. Listen-Indizes z\u00e4hlen wir also nicht 1, 2, 3 ... sondern 0, 1 ,2 ... Lass uns das im Detail ansehen. Sieh dir diese Liste an: [52, 55, 59] Nichts besonders Be\u00e4ngstigendes. Was ist das zweite Element in dieser Liste? Nat\u00fcrlich, es ist 55 . Das war einfach. Lass uns sehen, ob wir nicht auch den Computer dazu bringen k\u00f6nnen, die Frage f\u00fcr uns zu beantworten: puts [52, 55, 59][1] OK, das sieht etwas seltsam aus, wenn du so etwas noch nie gesehen hast. Aber vertrau mir, es ist nicht allzu schwer. Die Zeile oben besteht aus drei Teilen: dem Wort puts , unserer Liste 52, 55, 59 und unserem Index [1] . Zuerst sagen wir puts , weil wir wollen, dass Sonic Pi die Antwort f\u00fcr uns ins Protokoll schreibt. Als n\u00e4chstes \u00fcbergeben wir unsere Liste, und am Ende fragen wir mit dem Index nach dem zweiten Element in der Liste. Den Index m\u00fcssen wir mit eckigen Klammern umschlie\u00dfen, und da das Z\u00e4hlen mit 0 beginnt, ist die Index-Zahl f\u00fcr das zweite Element 1 . Schau: # indexes: 0 1 2 [52, 55, 59] Versuche mal, den Programm-Code puts [52, 55, 59][1] auszuf\u00fchren, dann wirst du sehen, dass 55 im Protokoll erscheint. \u00c4ndere den Index 1 in andere Indizes, probiere l\u00e4ngere Listen aus - und denke dar\u00fcber nach, wie du Listen einsetzen k\u00f6nntest, wenn du demn\u00e4chst Code live programmieren und damit jammen willst. Zum Beispiel, welche musikalischen Strukturen k\u00f6nnten als eine Reihe von Zahlen geschrieben werden ...","title":"Auf Listen zugreifen"},{"location":"#section-08-2","text":"Sonic Pi bietet dir auch Unterst\u00fctzung dabei, dir den Namen eines Akkords in eine Liste seiner T\u00f6ne zu \u00fcbersetzen. Probiere es selbst aus: play chord(:E3, :minor) Damit kommen wir nun wirklich weiter. Das sieht schon viel besser aus als einfache Listen (und es ist f\u00fcr andere viel leichter zu lesen). Welche Akkordaufl\u00f6sungen unterst\u00fctzt Sonic Pi noch? Naja, viele . Probiere ein paar hiervon aus: chord(:E3, :m7) chord(:E3, :minor) chord(:E3, :dim7) chord(:E3, :dom7)","title":"8.2 Akkorde"},{"location":"#arpeggios","text":"Wir k\u00f6nnen Akkorde leicht in Arpeggios umwandeln, indem wir die Funktion play_pattern verwenden: play_pattern chord(:E3, :m7) Ok, that's not so fun - it played it really slowly. play_pattern will play each note in the list with a call to sleep 1 after each call to play . We can use another function play_pattern_timed to specify our own timings and speed things up: play_pattern_timed chord(:E3, :m7), 0.25 Wir k\u00f6nnen sogar eine Liste von Zeiten \u00fcbergeben, die nacheinander verwendet und wiederholt werden: play_pattern_timed chord(:E3, :m13), [0.25, 0.5] Das bedeutet das gleiche wie: play 52, sustain: 0.25 sleep 0.25 play 55, sustain: 0.5 sleep 0.5 play 59, sustain: 0.25 sleep 0.25 play 62, sustain: 0.5 sleep 0.5 play 66, sustain: 0.25 sleep 0.25 play 69, sustain: 0.5 sleep 0.5 play 73, sustain: 0.25 sleep 0.25 Was w\u00fcrdest du lieber schreiben? Note that play_pattern and play_pattern_timed alter the sustain of the notes to fill the times. You can remove this behavior by setting the sustain: opt to 0 : play_pattern_timed chord(:E3, :m13), [0.25, 0.5], sustain: 0","title":"Arpeggios"},{"location":"#section-08-3","text":"Sonic Pi unterst\u00fctzt weite Auswahl von Tonleitern. Wie w\u00e4re es mit einer C3-Dur-Skala? play_pattern_timed scale(:c3, :major), 0.125, release: 0.1 Wir k\u00f6nnen sie auch \u00fcber mehrere Oktaven spielen lassen: play_pattern_timed scale(:c3, :major, num_octaves: 3), 0.125, release: 0.1 Und wie w\u00e4re es mit allen Noten einer pentatonischen Skala? play_pattern_timed scale(:c3, :major_pentatonic, num_octaves: 3), 0.125, release: 0.1","title":"8.3 Skalen"},{"location":"#zufallige-noten","text":"Akkorde und Skalen sind gute Methoden, um eine zuf\u00e4llige Auswahl auf etwas Bedeutungsvolles einzugrenzen. Spiele einmal mit diesem Beispiel, das zuf\u00e4llig Noten aus dem E-Moll-Akkord in der 3. Oktave ausw\u00e4hlt: use_synth :tb303 loop do play choose(chord(:E3, :minor)), release: 0.3, cutoff: rrand(60, 120) sleep 0.25 end Probiere auch verschiedene Akkord-Namen und Cut-Off-Bereiche aus.","title":"Zuf\u00e4llige Noten"},{"location":"#akkorde-und-skalen-entdecken","text":"Um herauszufinden, welche Skalen und Akkorde Sonic Pi unterst\u00fctzt, klicke einfach auf die Codes -Schaltfl\u00e4che unten links in diesem Tutorial und w\u00e4hle entweder chord (Akkord) oder scale (Skala, Tonleiter) aus der API-Liste. Im Info-Bereich im Hauptfenster scrolle nach unten, bist du eine lange Liste von Akkorden oder Skalen findest (je nach dem auf welches Fenster du gerade schaust). Viel Spa\u00df und nicht vergessen: Es gibt keine Fehler, nur M\u00f6glichkeiten.","title":"Akkorde und Skalen entdecken"},{"location":"#section-08-4","text":"Eine interessanter Dreh bei einfachen Listen sind Ringe. Wenn du ein bisschen Programmiererfahrung hast, bist du vielleicht schon einmal auf Ring-Buffer (Ringspeicher) oder Ring-Arrays gesto\u00dfen. Wir nennen sie hier - kurz und einfach - Ring. Im vorherigen Abschnitt \u00fcber Listen haben wir gesehen, wie wir \u00fcber den Index-Mechanismus Elemente aus einer Liste holen k\u00f6nnen: puts [52, 55, 59][1] Was passiert jetzt wohl, wenn du den Index 100 abfragen willst? Nun, es gibt offensichtlich kein Element mit dem Index 100, da die Liste nur drei Elemente enth\u00e4lt. Also gibt Sonic Pi nil zur\u00fcck, das steht f\u00fcr 'nichts'. Stell dir jedoch vor, du hast einen Z\u00e4hler, wie den aktuellen Beat (Schlag), der kontinuierlich w\u00e4chst. Lass uns damit unseren Z\u00e4hler und unsere Liste anlegen: counter = 0 notes = [52, 55, 59] Wir k\u00f6nnen jetzt unseren Z\u00e4hler verwenden, um auf eine Note in unserer Liste zuzugreifen: puts notes[counter] Super, da kam 52 heraus. Nun Lass uns den Z\u00e4hler erh\u00f6hen (increment) und auf eine andere Note zugreifen: counter = (inc counter) puts notes[counter] Gut, jetzt kommt 55 und beim folgenden Mal 59 heraus. Wenn wir das jedoch noch einmal machen, werden wir keine Zahlen mehr in unserer Liste haben, und wir bekommen nil zur\u00fcck. Was w\u00e4re, wenn wir in diesem Fall einfach wieder vom Anfang der Liste an z\u00e4hlen wollten? Genau daf\u00fcr gibt es Ringe.","title":"8.4 Ringe"},{"location":"#ringe-erzeugen","text":"Wir k\u00f6nnen Ringe auf zwei Arten erzeugen. Entweder wir nutzen die ring -Funktion, mit den gew\u00fcnschten Elementen aus dem Rings als Parameter: (ring 52, 55, 59) Oder wir nehmen eine normale Liste und wandeln sie mit der Nachricht .ring in einen Ring um: [52, 55, 59].ring","title":"Ringe erzeugen"},{"location":"#ringe-indizieren","text":"Sobald du einen Ring hast, kannst du ihn genauso verwenden wie du eine normale Liste verwenden w\u00fcrdest, mit einer Ausnahme: Du kannst darauf auch solche Indizes verwenden, die negativ oder gr\u00f6\u00dfer als der Ringinhalt sind - diese machen dann eine Schleife wieder zum Anfang, um immer auf ein Element des Rings zu verweisen: (ring 52, 55, 59)[0] #=> 52 (ring 52, 55, 59)[1] #=> 55 (ring 52, 55, 59)[2] #=> 59 (ring 52, 55, 59)[3] #=> 52 (ring 52, 55, 59)[-1] #=> 59","title":"Ringe indizieren"},{"location":"#ringe-verwenden","text":"Lass uns annehmen, wir verwenden eine Variable, die stets die aktuelle Schlagzahl abbildet. Wir k\u00f6nnen diese Variable in unserem Ring als Index verwenden, um so Noten, Release-Zeiten oder andere sinnvolle Dinge abzurufen, unabh\u00e4ngig davon bei welcher Schlagzahl wir uns gerade befinden.","title":"Ringe verwenden"},{"location":"#skalen-und-akkorde-sind-ringe","text":"Es ist n\u00fctzlich zu wissen, das die Listen, die von scale und chord zur\u00fcckgegeben werden, auch Ringe sind und du so mit beliebigen Indizes auf sie zugreifen kannst.","title":"Skalen und Akkorde sind Ringe"},{"location":"#ring-konstruktoren","text":"Zus\u00e4tzlich zu ring gibt es eine Anzahl weiterer Funktionen, die Ringe f\u00fcr uns erzeugen. range l\u00e4dt dich dazu ein, einen Startpunkt, einen Endpunkt und eine Schrittgr\u00f6\u00dfe festzulegen. bools erlaubt dir 1 en und 0 en als Kurzform f\u00fcr boolesche Werte zu nutzen. knit erlaubt dir, eine Abfolge zu wiederholender Werte zu stricken (to knit). spread erzeugt einen Ring boolescher Werte in euklidischer Verteilung. F\u00fcr weitere Information sieh dir die Dokumentation zur jeweiligen Funktion an.","title":"Ring-Konstruktoren"},{"location":"#section-08-5","text":"Neben der Verwendung von Konstruktoren wie range und spread k\u00f6nnen wir neue Ringe auch dadurch erzeugen, das wir bereits existierende Ringe ver\u00e4ndern.","title":"8.5 Ring-Ketten"},{"location":"#befehle-verketten","text":"Um dies auszuprobieren, verwende einen einfachen Ring: (ring 10, 20, 30, 40, 50) Was, wenn wir diese Reihe umkehren wollen? Nun, wir verwenden den Verkettungsbefehl .reverse , um den Ring umzudrehen: (ring 10, 20, 30, 40, 50).reverse #=> (ring 50, 40, 30, 20, 10) Ok, und wenn wir nur die ersten 3 Werte aus dem Ring haben wollten? (ring 10, 20, 30, 40, 50).take(3) #=> (ring 10, 20, 30) Und schlie\u00dflich, wenn wir den Ring mischen wollten? (ring 10, 20, 30, 40, 50).shuffle #=> (ring 40, 30, 10, 50, 20)","title":"Befehle verketten"},{"location":"#mehrfache-ketten","text":"Auf diese Art haben wir bereits m\u00e4chtige M\u00f6glichkeiten neue Ringe zu erzeugen. Noch m\u00e4chtiger werden sie allerdings, wenn du mehrere dieser Befehle verkettest. Wie w\u00e4re es den Ring zu mischen, das erste Element wegzulassen, und dann die 3 folgenden Elemente zu verwenden? Lass uns das Schritt f\u00fcr Schritt durchgehen: (ring 10, 20, 30, 40, 50) - dein anf\u00e4nglicher Ring (ring 10, 20, 30, 40, 50).shuffle - mischt ihn zu - (ring 40, 30, 10, 50, 20) (ring 10, 20, 30, 40, 50).shuffle.drop(1) - mischt und l\u00e4sst dann das erste Element weg - (ring 30, 10, 50, 20) (ring 10, 20, 30, 40, 50).shuffle.drop(1).take(3) - mischt, l\u00e4sst das erste Element weg und nimmt 3 - (ring 30, 10, 50) Kannst du sehen, wie wir eine lange Kette dieser Methoden einfach dadurch erzeugen k\u00f6nnen, dass wir sie aneinander kleben ? Wir k\u00f6nnen das in jeder beliebigen Reihenfolge tun, und damit haben wir einen extrem m\u00e4chtigen Weg, um neue Ringe aus bereits bestehenden zu erzeugen.","title":"Mehrfache Ketten"},{"location":"#unveranderlichkeit","text":"Diese Ringe haben eine m\u00e4chtige und wichtige Eigenschaft. Sie sind unver\u00e4nderlich (immutable) - sie k\u00f6nnen nicht ver\u00e4ndert werden. Das bedeutet, dass die Verkettungsmethoden, von denen wir in diesem Abschnitt sprechen, die Ringe nicht ver\u00e4ndern sondern eher neue Ringe erzeugen . Das bedeutet, du kannst Ringe \u00fcber verschiedene Threads hinweg teilen und anfangen sie innerhalb eines Threads zu verketten, ohne dabei irgend einen anderen Thread zu ver\u00e4ndern, der auf den gleichen Ring zugreift.","title":"Unver\u00e4nderlichkeit"},{"location":"#verfugbare-verkettungsmethoden","text":"Dies ist eine Liste der Verkettungsmethoden, mit denen du spielen kannst: .reverse - gibt eine umgedrehte Version des Ringes zur\u00fcck .sort - erzeugt eine sortierte Version des Ringes .shuffle - erzeugt eine gemischte Version des Ringes .pick - liefert einen Ring mit den Resultaten wie 1 mal .choose .pick(3) - liefert einen Ring mit den selben Resultaten wie 3 mal .choose .take(5) - liefert einen Ring, der nur die ersten 5 Elemente enth\u00e4lt .drop(3) - liefert einen Ring, der alles au\u00dfer den ersten 3 Elementen enth\u00e4lt .butlast - liefert einen Ring ohne das letzte Element .drop_last(3) - liefert einen Ring ohne die letzten 3 Elemente .take_last(6) - liefert einen Ring, der nur die letzten 6 Elemente enth\u00e4lt .stretch(2) - wiederholt jedes Element im Ring zweimal .repeat(3) - wiederholt den Ring als Ganzes 3 mal .mirror - h\u00e4ngt eine umgekehrte Version des Rings an den Ring an .reflect - wie .mirror , verdoppelt aber nicht den mittleren Wert .scale(2) - liefert einen neuen Ring mit allen Elementen multipliziert mit 2 (setzt voraus, dass der Ring nur Zahlen enth\u00e4lt) Nat\u00fcrlich k\u00f6nnen solche Verkettungsmethoden, die Zahlenparameter annehmen auch andere Werte annehmen. So kannst du anstelle von .drop(3) z. B. auch .drop(5) aufrufen, wenn du die ersten f\u00fcnf Elemente wegfallen lassen willst.","title":"Verf\u00fcgbare Verkettungsmethoden"},{"location":"#section-09","text":"Einer der aufregendsten Aspekte von Sonic Pi ist, dass es dir erm\u00f6glicht den Programm-Code f\u00fcr deine Musik live zu schreiben und zu ver\u00e4ndern, ganz so wie wenn du mit einer Gitarre live auftreten w\u00fcrdest. Ein Vorteil dieses Ansatzes ist, dass du mehr R\u00fcckmeldung erh\u00e4ltst, noch w\u00e4hrend du komponierst - bringe eine einfache Schleife (Loop) an den Start und bearbeite sie so lange, bis sie perfekt klingt. Wie auch immer, der eigentliche Vorteil besteht darin, dass du Sonic Pi mit auf die B\u00fchne nehmen und damit einen Auftritt absolvieren kannst. In diesem Abschnitt behandeln wir die Grundlagen davon, wie du deine statischen Programm-Code-Kompositionen in dynamische Performances verwandeln kannst. Halt dich fest ...","title":"9 Live-Coding"},{"location":"#section-09-1","text":"Inzwischen haben wir genug gelernt, um tats\u00e4chlich mit dem Spa\u00df anzufangen. In diesem Abschnitt verwenden wir alles, was wir in den vorherigen Abschnitten behandelt haben und zeigen dir, wie du damit beginnen kannst, deine Musik live zu komponieren und in eine Performance zu verwandeln. Dazu ben\u00f6tigen wir 3 wesentliche Zutaten: Die F\u00e4higkeit Programm-Code zu schreiben, der Kl\u00e4nge erzeugt - CHECK! Die F\u00e4higkeit Funktionen zu schreiben - CHECK! Die F\u00e4higkeit Threads (mit Namen) zu verwenden - CHECK! Ok, lass uns loslegen. Lass uns unsere ersten Kl\u00e4nge live programmieren. Zuerst brauchen wir eine Funktion, die den abzuspielenden Code enth\u00e4lt. Lass uns einfach beginnen. Au\u00dferdem wollen wir Aufrufe an diese Funktion in einer Schleife in einem Thread ausf\u00fchren: define :my_sound do play 50 sleep 1 end in_thread(name: :looper) do loop do my_sound end end Wenn dir das ein bisschen zu kompliziert vorkommt, lies bitte noch einmal die Abschnitte \u00fcber Funktionen und Threads durch. Es ist nicht mehr so kompliziert, wenn du sie erstmal verstanden hast. Was wir hier haben, ist die Definition einer Funktion, welche einfach die Note 50 spielt und danach einen Schlag lang schl\u00e4ft. Dann definieren wir einen Thread (mit Namen) - wir nennen ihn :looper - und er ruft in einer Schleife my_sound auf. Wenn du diesen Code ausf\u00fchrst, wirst du immer und immer wieder die Note 50 h\u00f6ren...","title":"9.1 Live-Coding: Grundlagen"},{"location":"#einen-gang-hochschalten","text":"Nun, hier f\u00e4ngt der Spa\u00df an. W\u00e4hrend der Code noch l\u00e4uft , \u00e4ndere die 50 in eine andere Zahl, sagen wir 55, und klicke nochmals auf Ausf\u00fchren . Wow! Es hat sich ge\u00e4ndert! Live! Es hat keine neue Ebene hinzugef\u00fcgt, da wir einen benannten Thread verwendet haben und es f\u00fcr jeden Namen nur einen Thread geben kann. Der Klang hat sich ge\u00e4ndert, weil wir die Funktion umdefiniert haben. Wir haben also :my_sound eine neue Definition gegeben. W\u00e4hrend im :looper -Thread die Schleife lief, hat er darin einfach die neue Definition aufgerufen. Ver\u00e4ndere die Definition der Funktion noch einmal, \u00e4ndere die Note, \u00e4ndere die Pausenzeit. Und wie w\u00e4re es eine use_synth -Aussage hinzuzuf\u00fcgen? Z. B. \u00e4ndere die Funktion in: define :my_sound do use_synth :tb303 play 50, release: 0.3 sleep 0.25 end Jetzt klingt es schon ganz interessant, wir k\u00f6nnen es aber noch ein bisschen interessanter machen. Anstatt immer wieder die gleiche Note zu spielen, versuche einen Akkord zu spielen: define :my_sound do use_synth :tb303 play chord(:e3, :minor), release: 0.3 sleep 0.5 end Und wie w\u00e4re es damit, zuf\u00e4llige T\u00f6ne des Akkords zu spielen: define :my_sound do use_synth :tb303 play choose(chord(:e3, :minor)), release: 0.3 sleep 0.25 end Oder einen zuf\u00e4lligen Cut-Off-Wert: define :my_sound do use_synth :tb303 play choose(chord(:e3, :minor)), release: 0.2, cutoff: rrand(60, 130) sleep 0.25 end Und schlie\u00dflich, f\u00fcge etwas Schlagzeug hinzu: define :my_sound do use_synth :tb303 sample :drum_bass_hard, rate: rrand(0.5, 2) play choose(chord(:e3, :minor)), release: 0.2, cutoff: rrand(60, 130) sleep 0.25 end Jetzt wird die Sache langsam aufregend! Wie auch immer, bevor du jetzt aufspringst und anf\u00e4ngst mit Funktionen und Threads live zu programmieren, h\u00f6r mit dem was du gerade machst auf und lies den n\u00e4chsten Abschnitt \u00fcber live_loop - das wird die Art wie du in Sonic Pi programmierst, f\u00fcr immer ver\u00e4ndern ...","title":"Einen Gang hochschalten"},{"location":"#section-09-2","text":"Ok, dieser Abschnitt des Tutorials ist ein echtes Juwel. Wenn du nur einen einzigen Abschnitt lesen w\u00fcrdest, sollte es dieser sein. Wenn du den letzten Abschnitt \u00fcber die Grundlagen von Live-Coding gelesen hast - live_loop ist eine einfache Art genau das gleiche zu tun, aber ohne dass du so viel schreiben musst. Falls du den letzten Abschnitt nicht gelesen hast - live_loop ist der beste Weg, um mit Sonic Pi zu jammen. Lass uns spielen. Schreibe Folgendes in einen neuen Puffer: live_loop :foo do play 60 sleep 1 end Jetzt klicke auf Ausf\u00fchren . Du h\u00f6rst mit jedem Schlag ein einfaches Piepen. Nichts unterhaltsames daran. Klicke aber noch nicht auf Stopp . \u00c4ndere die 60 in 65 und klicke wieder Ausf\u00fchren . Wow! Es hat sich automatisch ge\u00e4ndert ohne einen Schlag auszulassen. Das ist Live-Coding. Warum es nicht ein wenig mehr nach Bass klingen lassen? Aktualisiere deinen Programm-Code, w\u00e4hrend er abl\u00e4uft: live_loop :foo do use_synth :prophet play :e1, release: 8 sleep 8 end Dann klicke auf Ausf\u00fchren . Lassen wir den Cut-Off sich ein wenig bewegen: live_loop :foo do use_synth :prophet play :e1, release: 8, cutoff: rrand(70, 130) sleep 8 end Klicke wieder auf Ausf\u00fchren . F\u00fcge etwas Schlagzeug hinzu: live_loop :foo do sample :loop_garzul use_synth :prophet play :e1, release: 8, cutoff: rrand(70, 130) sleep 8 end Wechsle die Note von e1 zu c1 : live_loop :foo do sample :loop_garzul use_synth :prophet play :c1, release: 8, cutoff: rrand(70, 130) sleep 8 end Nun h\u00f6re nicht weiter mir zu - spiele selbst herum! Viel Spa\u00df!","title":"9.2 Live-Loops"},{"location":"#section-09-3","text":"Sieh dir den folgenden Live-Loop an: live_loop :foo do play 50 sleep 1 end Vielleicht fragst du dich, warum er den Namen :foo braucht. Dieser Name ist wichtig, weil er bedeutet, dass sich dieser Live-Loop von allen anderen Live-Loops unterscheidet. Es kann nie zwei Live-Loops mit dem selben Namen geben, die zur gleichen Zeit laufen . Das bedeutet, wenn wir mehrere Live-Loops gleichzeitig laufen lassen wollen, m\u00fcssen wir ihnen einfach nur verschiedene Namen geben: live_loop :foo do use_synth :prophet play :c1, release: 8, cutoff: rrand(70, 130) sleep 8 end live_loop :bar do sample :bd_haus sleep 0.5 end Du kannst jetzt beide Live-Loops unabh\u00e4ngig voneinander ver\u00e4ndern, und alles funktioniert - einfach so.","title":"9.3 Mehrere Live-Loops"},{"location":"#live-loops-synchronisieren","text":"Du hast vielleicht schon bemerkt, dass Live-Loops automatisch mit dem Thread-Cue-Mechanismus arbeiten, den wir uns bereits angeschaut haben. Mit jedem Mal wenn der Live-Loop einen Durchlauf beginnt, generiert er ein neues Cue-Ereignis, das den Namen des Live-Loops erh\u00e4lt. Wir k\u00f6nnen daher mit diesen Cues in sync bleiben und so sicherstellen, dass unsere Schleifen sich synchronisieren, ohne dass wir etwas anhalten m\u00fcssen. Schau dir diesen schlecht synchronisierten Code an: live_loop :foo do play :e4, release: 0.5 sleep 0.4 end live_loop :bar do sample :bd_haus sleep 1 end Lass uns versuchen das Timing zu korrigieren ohne den Live-Loop zu stoppen. Zuerst lass uns den Live-Loop :foo reparieren, indem wir seine Sleep-Zeit zu einem Divisor von 1 machen - so etwas wie 0.5 wird z. B. funktionieren: live_loop :foo do play :e4, release: 0.5 sleep 0.5 end live_loop :bar do sample :bd_haus sleep 1 end Damit sind wir aber noch nicht ganz fertig - du wirst bemerken, dass die Beats nicht so recht zusammenpassen. Der Grund daf\u00fcr ist, dass die Live-Loops out of phase sind. Lass uns das reparieren, indem wir den einen mit dem anderen synchronisieren: live_loop :foo do play :e4, release: 0.5 sleep 0.5 end live_loop :bar do sync :foo sample :bd_haus sleep 1 end Toll, jetzt passt das Timing perfekt - ohne dass wir die Live-Loops anhalten mussten. Jetzt leg los und programmiere live mit Live-Loops!","title":"Live-Loops synchronisieren"},{"location":"#section-09-4","text":"Du wirst sehen, dass du beim Live-Coding sehr h\u00e4ufig Ringe in deinen Live-Loops verwenden wirst. Du wirst Noten in Ringen setzen f\u00fcr Melodien, Pausen f\u00fcr Rhythmen, und du wirst aus ihnen Akkordfolgen, Klangvariatonen und \u00e4hnliches generieren.","title":"9.4 Ticks verwenden"},{"location":"#ticks-und-ringe","text":"Sonic Pi bietet ein sehr praktisches Werkzeug, um in einem live_loop mit Ringen zu arbeiten. Es nennt sich Tick-System. In dem Abschnitt \u00fcber Ringe haben wir \u00fcber den Counter gesprochen, der etwas fortw\u00e4hrend hochz\u00e4hlt, wie z. B. eine Schlagzahl. Tick hat diese Idee eingebaut. Du kannst damit durch einen Ring ticken . Lass uns ein Beispiel ansehen: counter = 0 live_loop :arp do play (scale :e3, :minor_pentatonic)[counter], release: 0.1 counter += 1 sleep 0.125 end Das ist gleichbedeutend mit: live_loop :arp do play (scale :e3, :minor_pentatonic).tick, release: 0.1 sleep 0.125 end Hier nehmen wir einfach die pentatonische E3-Moll-Skala (Tonleiter) und ticken durch jedes einzelne Element. Daf\u00fcr wird .tick an das Ende der Tonleiter-Deklaration angef\u00fcgt. Dieser Tick gilt nur lokal f\u00fcr diesen Live-Loop, so dass jeder Live-Loop seinen eigenen unabh\u00e4ngigen Tick haben kann: live_loop :arp do play (scale :e3, :minor_pentatonic).tick, release: 0.1 sleep 0.125 end live_loop :arp2 do use_synth :dsaw play (scale :e2, :minor_pentatonic, num_octaves: 3).tick, release: 0.25 sleep 0.25 end","title":"Ticks und Ringe"},{"location":"#tick","text":"Du kannst tick als eine Standard-Funktion abfragen und den Wert als Index verwenden: live_loop :arp do idx = tick play (scale :e3, :minor_pentatonic)[idx], release: 0.1 sleep 0.125 end Aber eigentlich ist es viel einfacher, wenn du .tick am Ende anf\u00fcgst. Die tick -Funktion ist daf\u00fcr gedacht aufwendigere damit Dinge zu machen, oder wenn du Ticks f\u00fcr andere Dinge verwenden m\u00f6chtest, als Werte aus einem Ring zu erhalten.","title":"Tick"},{"location":"#look","text":"Das Magische an Tick ist, dass er nicht nur nach jedem Aufruf einen neuen Index zur\u00fcck gibt (oder den Wert aus dem Ring an diesem Indexpunkt), er stellt auch sicher, dass du beim n\u00e4chsten Aufruf von Tick auch den n\u00e4chsten Wert bekommst. Schau dir im Hilfe-Fenster die Beispiele f\u00fcr .tick an, um die vielen M\u00f6glichkeiten seiner Verwendung zu entdecken. F\u00fcr den Moment jedoch ist es wichtig zu betonen, dass du manchmal nur den aktuellen Tick-Wert sehen willst, ohne den Tick hochzuz\u00e4hlen . Daf\u00fcr gibt es die look -Funktion. Du kannst look als Standard-Funktion aufrufen oder indem du .look an einen Ring anf\u00fcgst.","title":"Look"},{"location":"#namen-fur-ticks","text":"Schlie\u00dflich wirst du gelegentlich auch mal mehr als einen Tick pro Live-Loop brauchen. das erreichst du, indem du deinem Tick einen Namen gibst: live_loop :arp do play (scale :e3, :minor_pentatonic).tick(:foo), release: 0.1 sleep (ring 0.125, 0.25).tick(:bar) end In diesem Beispiel verwenden wir zwei Ticks, einen f\u00fcr die Note und einen zweiten Tick f\u00fcr die Pausenwerte. Da beide sich im gleichen Live-Loop befinden, m\u00fcssen wir ihnen zur Unterscheidung eindeutige Namen geben. Das ist exakt das gleiche Prinzip wie bei der Benennung von Live-Loops - wir \u00fcbergeben einfach ein : gefolgt vom Namen. Im obigen Beispiel haben wir einen Tick :foo genannt und den anderen :bar . Auch wenn wir den Tick-Wert mit look nur abfragen wollen, m\u00fcssen wir den Namen \u00fcbergeben.","title":"Namen f\u00fcr Ticks"},{"location":"#mache-es-nicht-zu-kompliziert","text":"Die meisten machtvollen Dinge im Tick-System sind wenig sinnvoll, wenn du gerade erst anf\u00e4ngst. Versuche nicht alles in diesem Abschnitt gleich zu lernen. Konzentriere darauf durch einen einzelnen Ring zu ticken. Das wird dir schon sehr viel von der Freude und der Einfachheit des Tickens in deinen live_loop s bringen. Schau dir die Dokumentation f\u00fcr tick an - es gibt dort viele n\u00fctzliche Beispiele. Viel Spa\u00df beim Ticken!","title":"Mache es nicht zu kompliziert"},{"location":"#section-10","text":"Oftmals ist es sinnvoll, Informationen zu haben, die \u00fcber verschiedenen Threads or Live-Loops geteilt werden kann . Beispielsweise m\u00f6chtest du vielleicht die aktuelle Tonart, BPM oder auch abstraktere Konzepte wie z. B. die aktuelle 'Komplexit\u00e4t' (die wiederum in den verschiedenen Threads unterschiedlich interpretiert werden k\u00f6nnte) teilen. Wenn wir dies tun, m\u00f6chten wir aber auch nicht auf die garantierte Bestimmbarkeit von Sonic Pi verzichten. In anderen Worten: Wir m\u00f6chten immer noch Programm-Code mit anderen teilen und sicherstellen k\u00f6nnen, dass wir genau wissen, was sie h\u00f6ren, wenn sie ihn ausf\u00fchren. Am Ende des Abschnitts 5.6. dieses Tutorials haben wir kurz dar\u00fcber gesprochen, warum wir Variablen nicht nutzen sollten, um Informationen zwischen Threads zu teilen , da wir dadurch diese Vorhersagbarkeit verlieren (aufgrund von Race Conditions). Sonic Pi's L\u00f6sung f\u00fcr das Problem auf einfache Art mit globalen Variablen in einer vorhersagbaren Weise zu arbeiten, ist ein neuartiges System, das es Time-State (Stand der Zeit) nennt. Es mag erstmal komplex und schwierig klingen (Programmieren mit mehrfachen Threads und geteiltem Speicher werden normalerweise erst in der Universit\u00e4t behandelt). Allerdings wie du sehen wirst, genau wie beim Spielen deiner ersten Note, macht es dir Sonic Pi unglaublich einfach, einen Zustand \u00fcber mehrere Threads zu teilen und dabei dennoch deine Programme *thread-safe und vorhersagbar\" bleiben zu lassen. Sag Hallo zu get und set ...","title":"10 Time-State (Stand der Zeit)"},{"location":"#section-10-1","text":"Sonic Pi verf\u00fcgt \u00fcber einen globalen Speicherbereich, der Time-State genannt wird. Die beiden wesentliche damit m\u00f6glichen Dinge sind das Setzen von Informationen (Set) und das Holen von Information (Get). Lass uns das genauer ansehen ...","title":"10.1 Set und Get"},{"location":"#set","text":"Um Informationen in den Time-State zu speichern ben\u00f6tigen wir zwei Dinge: die Information, die wir speichern wollen, einen eindeutigen Namen (Schl\u00fcssel) f\u00fcr die Information. Zum Beispiel wollen wir vielleicht die Zahl 3000 unter dem Schl\u00fcsselnamen :intensity speichern. Das ist m\u00f6glich mit der set -Funktion: set :intensity, 3000 Wir k\u00f6nnen f\u00fcr den Schl\u00fcssel einen beliebigen Namen verwenden. Wurde unter diesem Schl\u00fcsselnamen bereits Information gespeichert, wird unser neuer set -Befehl diese \u00fcberschreiben: set :intensity, 1000 set :intensity, 3000 In dem obigen Beispiel haben wir beide Werte unter dem gleichen Schl\u00fcsselnamen abgespeichert, und der letzte set -Befehl 'gewinnt', so dass die Zahl 3000 mit :intensity assoziiert wird, also unser erster set -Befehl damit \u00fcberschrieben wurde.","title":"Set"},{"location":"#get","text":"Um Informationen aus dem Time-State wiederzuholen, ben\u00f6tigen wir nur den Schl\u00fcssel, den wir bei set verwendet haben, also in unserem Fall :intensity . Wir m\u00fcssen jetzt nur get[:intensity] aufrufen, und das Ergebnis wird uns im Protokoll angezeigt: print get[:intensity] #=> prints 3000 Beachte, dass Aufrufe von get Informationen zur\u00fcckgeben k\u00f6nnen, die bei einem vorherigem Programm-Lauf gesetzt wurden. Wurde eine Information einmal mit Hilfe von set gesetzt, bleibt sie solange verf\u00fcgbar, bis sie entweder \u00fcberschrieben wird (so wie wir den Wert 1000 von intensity mit 3000 vertauscht haben) oder Sonic Pi beendet wird.","title":"Get"},{"location":"#mehrere-threads","text":"Der wesentliche Vorteil des Time-State-Systems ist, dass es auf sichere Art und Weise zwischen Threads und zwischen Live-Loops verwendet werden kann. Beispielsweise k\u00f6nnte ein Live-Loop Informationen setzen und ein anderer diese auslesen: live_loop :setter do set :foo, rrand(70, 130) sleep 1 end live_loop :getter do puts get[:foo] sleep 0.5 end Das Sch\u00f6ne an der Verwendung von get und set \u00fcber Threads hinweg ist, dass immer das gleiche Ergebnis ausgegeben wird, wenn der Programm-Code gestartet wird. Los, probiere es selbst. Sieh nach, ob dir das Folgende im Protokoll ausgegeben wird: {run: 0, time: 0.0} \u2514\u2500 125.72265625 {run: 0, time: 0.5} \u2514\u2500 125.72265625 {run: 0, time: 1.0} \u2514\u2500 76.26220703125 {run: 0, time: 1.5} \u2514\u2500 76.26220703125 {run: 0, time: 2.0} \u2514\u2500 114.93408203125 {run: 0, time: 2.5} \u2514\u2500 114.93408203125 {run: 0, time: 3.0} \u2514\u2500 75.6048583984375 {run: 0, time: 3.5} \u2514\u2500 75.6048583984375 Starte das Programm einfach mehrmals hintereinander - du siehst, dass das Ergebnis jedes Mal das Gleiche ist. Wir bezeichnen dies als deterministisches (vorhersagbares) Verhalten, und es ist sehr wichtig, wenn wir unsere Musik als Programm-Code weitergeben, zu wissen, dass die Person, die den Code ausf\u00fchrt, genau das h\u00f6ren wird, was wir sie h\u00f6ren lassen wollten (\u00e4hnlich wie beim Abspiel einer MP3 oder beim Streamen f\u00fcr alle H\u00f6rer dasselbe zu h\u00f6ren ist).","title":"Mehrere Threads"},{"location":"#ein-einfaches-deterministisches-state-system","text":"In Abschnitt 5.6 haben wir dar\u00fcber gesprochen, wie die Nutzung von Variablen \u00fcber verschiedenen Threads hinweg zu zuf\u00e4lligen Resultaten f\u00fchren kann. Das hindert uns daran Programm-Code wie diesen zuverl\u00e4ssig zu reproduzieren: ## Ein Beispiel f\u00fcr ein nicht-deterministisches Verhalten ## (aufgrund von Race Conditions, die durch ## mehrfache Live-Loops ausgel\u00f6st werden, die den Wert ## der selben Variable ver\u00e4ndern). ## ## Wenn du den Code startest, siehst du, ## dass die Liste, die ausgegeben wird, ## nicht immer sortiert ist! a = (ring 6, 5, 4, 3, 2, 1) live_loop :shuffled do a = a.shuffle sleep 0.5 end live_loop :sorted do a = a.sort sleep 0.5 puts \"sorted: \", a end Lass uns sehen, wie wir hier get und set einsetzen k\u00f6nnten: ## Ein Beispiel f\u00fcr deterministisches Verhalten ## (trotz gleichzeitigem Zugriff auf einen geteilten Zustand) ## mit Hilfe des Sonic Pi Time State Systems. ## ## Bei Ausf\u00fchrung dieses Codes, ## wird die Liste immer sortiert ausgegeben! set :a, (ring 6, 5, 4, 3, 2, 1) live_loop :shuffled do set :a, get[:a].shuffle sleep 0.5 end live_loop :sorted do set :a, get[:a].sort sleep 0.5 puts \"sorted: \", get[:a] end Beachte, dass dieser Code fast identisch ist mit dem Code, der eine Variable zum Teilen der Information verwendet hat. Wenn du ihn ausf\u00fchrst verh\u00e4lt er sich allerdings so, wie du es bei jedem typischen Sonic Pi Code erwarten w\u00fcrdest - er verh\u00e4lt sich immer gleich , in diesem Fall dank des Time-State-Systems. Deshalb verwende f\u00fcr ein vorhersagbares und reproduzierbares Verhalten anstelle von Variablen immer get und set , wenn du Daten zwischen Live-Loops und zwischen Threads teilst.","title":"Ein einfaches deterministisches State-System"},{"location":"#section-10-2","text":"In Abschnitt 5.7 haben wir die Funktionen cue und sync vorgestellt, f\u00fcr die Synchronisierung von Threads. Was wir dort nicht erkl\u00e4rt haben ist, dass es das Time-State-System ist, das diese Funktionalit\u00e4t bereitstellt. Tats\u00e4chlich ist set eine Variation von cue und baut auf er selben Kernfunktion auf, Informationen im Time-State-System zu hinterlegen. Dar\u00fcber hinaus ist sync so gestaltet, dass es unmittelbar mit Time-State arbeitet - jegliche Information, die wir zuk\u00fcnftig im Time State ablegen wollen, kann auch zur Synchronisierung verwendet werden. Mit anderen Worten - wir synchronisieren auf Ereignisse, die erst noch im Time-State gespeichert werden .","title":"10.2 Synchronisation"},{"location":"#warten-auf-ereignisse","text":"Lass uns mal ansehen, wie sync verwendet wird, um auf neue Ereignisse zu warten, die dem Time-State hinzugef\u00fcgt werden: in_thread do sync :foo sample :ambi_lunar_land end sleep 2 set :foo, 1 In diesem Beispiel erstellen wir zuerst einen Thread, der darauf wartet, dass ein Ereignis ':foo' dem Time-State hinzugef\u00fcgt wird. Nach dieser Thread-Deklaration schlafen wir f\u00fcr 2 Schl\u00e4ge, und dann setzen wir mit 'set' den Wert f\u00fcr ':foo' auf '1'. Dies entfernt sync , was dann auf die n\u00e4chste Zeile \u00fcbergeht, in der das ':ambi_lunar_land'-Sample getriggert wird. Beachte, dass sync immer auf zuk\u00fcnftige Ereignisse wartet, und dass es den gegenw\u00e4rtigen Thread blockieren wird, w\u00e4hrend es auf ein neues Ereignis wartet. Zus\u00e4tzlich erbt es die logische Zeit des Threads, der es via set oder cue getriggert hat, sodass sich hierdurch auch die Zeit von zwei Threads synchronisieren l\u00e4sst.","title":"Warten auf Ereignisse"},{"location":"#ubergabe-von-werten-an-die-zukunft","text":"In diesem Beispiel setzen wir ':foo' auf '1', dar\u00fcber hinaus haben wir damit nichts angefangen. Diesen Wert k\u00f6nnen wir im Thread tats\u00e4chlich abfragen ('get'), indem wir sync aufrufen: in_thread do amp = sync :foo sample :ambi_lunar_land, amp: amp end sleep 2 set :foo, 0.5 Beachte, dass Werte die mit Hilfe von set und `cue \u00fcbergeben werden, thread-safe sein m\u00fcssen - dies sind unver\u00e4nderliche Ringe (immutable rings), Zahlen, Symbole oder eingefrorene Zeichenketten (frozen strings). Sonic Pi gibt einen Fehler aus, falls du einen Wert im Time-Store ablegen willst, der nicht g\u00fctig ist.","title":"\u00dcbergabe von Werten an die Zukunft"},{"location":"#section-10-3","text":"Beim Holen und Setzen von Informationen unter Verwendung von Time-State lassen sich komplexere Schl\u00fcssel verwenden als einfache Symbole wie :foo und :bar . Du kannst auch Zeichenketten in der Art von URLs verwenden, wie z.B. \"/foo/bar/baz\" . Sobald wir anfangen mit Pfaden zu arbeiten, k\u00f6nnen wir auch die Vorteile des ausgekl\u00fcgelten Muster-Abgleich-Systems von Sonic Pi nutzen, um get und sync mit '\u00e4hnlichen' und nicht mit 'identischen' Pfaden zu synchronisieren. Lass uns einen Blick darauf werfen.","title":"10.3 Muster-Abgleich"},{"location":"#abgleich-mit-allen-pfad-segmenten","text":"Lass uns annehmen wir m\u00f6chten auf das n\u00e4chste Ereignis warten, das die folgenden drei Pfad-Segmente enth\u00e4lt: sync \"/*/*/*\" Dieses Muster wird zu jedem Time-State-Ereignis passen, das aus exakt drei Pfadsegmenten besteht, unabh\u00e4ngig von deren Namen. Zum Beispiel: cue \"/foo/bar/baz\" cue \"/foo/baz/quux\" cue \"/eggs/beans/toast\" cue \"/moog/synths/rule\" Allerdings wird es nicht zu Ereignissen mit wenigeren oder mehr Pfad-Segmente passen. Die folgenden w\u00fcrden nicht passen: cue \"/foo/bar\" cue \"/foo/baz/quux/quaax\" cue \"/eggs\" Jeder * bedeutet jeder Inhalt . Das bedeutet, wir k\u00f6nnen Pfade mit nur einem Segment mit /* oder Pfade aus f\u00fcnf Segmenten mit /*/*/*/*/* abgleichen","title":"Abgleich mit allen Pfad-Segmenten"},{"location":"#abgleich-mit-teilsegmenten","text":"Wenn wir wissen, womit das Segment beginnen oder enden wird, k\u00f6nnen wir ein * zus\u00e4tzlich zum Namen eines Teilsegments verwenden. Zum Beispiel: \"/foo/b*/baz\" passt zu jedem Pfad, der drei Segmente hat, von denen das erste foo , das letzte baz und das mittlere Segment alles sein kann, was mit b beginnt. Also, es w\u00fcrde passen zu: cue \"/foo/bar/baz\" cue \"/foo/baz/baz\" cue \"/foo/beans/baz\" Allerdings w\u00fcrde es nicht zu Folgendem passen: cue \"/foo/flibble/baz\" cue \"/foo/abaz/baz\" cue \"/foo/beans/baz/eggs\" Du kannst das * auch an den Anfang des Segments setzen, um die letzten Zeichen eines Segments anzugeben: \"/foo/*zz/baz\" , wird zu jedem cue or set bestehend aus 3 Segmenten passen, wo das erste Segment foo , das letzte baz ist und das mittlere Segment auf zz endet, so wie \"cue \"/foo/whizz/baz\" .","title":"Abgleich mit Teilsegmenten"},{"location":"#abgleich-mit-verschachtelten-pfadsegmenten","text":"Manchmal wei\u00dft du nicht, wie viele Pfadsegmente du abgleichen m\u00f6chtest. In diesen F\u00e4llen kannst du den m\u00e4chtigen Doppelstern ** verwenden, wie in \"/foo/**/**/baz\" , das \u00fcbereinstimmt mit: cue \"/foo/bar/baz\" cue \"/foo/bar/beans/baz\" cue \"/foo/baz\" cue \"/foo/a/b/c/d/e/f/baz\"","title":"Abgleich mit verschachtelten Pfadsegmenten"},{"location":"#abgleich-mit-einzelnen-buchstaben","text":"Du kannst das ? verwenden, um mit einem beliebigen einzelnen Zeichen abzugleichen. \"/?oo/bar/baz\" passt zu: cue \"/foo/bar/baz\" cue \"/goo/bar/baz\" cue \"/too/bar/baz\" cue \"/woo/bar/baz\"","title":"Abgleich mit einzelnen Buchstaben"},{"location":"#abgleich-mit-mehreren-wortern","text":"Wenn du wei\u00dft, das ein Segment eines aus einer bestimmten Reihe von W\u00f6rtern ist, kannst du eine Auswahlliste zwischen { und } setzen, so wie \"/foo/{bar,beans,eggs}/quux\" , was nur auf das Folgende passt: cue \"/foo/bar/quux\" cue \"/foo/beans/quux\" cue \"/foo/eggs/quux\"","title":"Abgleich mit mehreren W\u00f6rtern"},{"location":"#abgleich-mit-mehreren-zeichen","text":"Schlie\u00dflich kannst du auch noch gegen eine Auswahl von Buchstaben abgleichen, indem du eine Auswahlliste zwischen { und } setzt, so wie \"/foo/[abc]ux/baz\" , was nur passen wird zu: cue \"/foo/aux/baz\" cue \"/foo/bux/baz\" cue \"/foo/cux/baz\" Du kannst mit - auch Buchstabenbereiche angeben. Zum Beispiel \"/foo/[a-e]ux/baz\" , was nur passt zu: cue \"/foo/aux/baz\" cue \"/foo/bux/baz\" cue \"/foo/cux/baz\" cue \"/foo/dux/baz\" cue \"/foo/eux/baz\"","title":"Abgleich mit mehreren Zeichen"},{"location":"#kombination-von-abgleichen","text":"Wenn du sync oder get aufrufst, kannst du Abgleiche mit Mustern in beliebiger Reihenfolge miteinander kombinieren, um sehr effektiv jedes beliebige Time-State-Ereignis, das durch cue oder set erzeugt wurde, zu erkennen. Lass uns ein verr\u00fccktes Beispiel anschauen: in_thread do sync \"/?oo/[a-z]*/**/ba*/{quux,quaax}/\" sample :loop_amen end sleep 1 cue \"/foo/beans/a/b/c/d/e/bark/quux/\"","title":"Kombination von Abgleichen"},{"location":"#osc-musterabgleich","text":"For those curious, these matching rules are based on the Open Sound Control pattern matching specification which is explained in detail here: https://opensoundcontrol.stanford.edu/spec-1_0.html","title":"OSC Musterabgleich"},{"location":"#section-11","text":"Wenn du es geschafft hast Programm-Code in Musik zu verwandeln, fragst du dich vielleicht - was kommt als n\u00e4chstes? Manchmal sind die Beschr\u00e4nkungen, die darin bestehen nur mit Sonic Pis Syntax und Soundsystem zu arbeiten, aufregend und versetzen dich in eine neue kreative Lage. Manchmal jedoch ist es nochmal etwas grundlegend anderes, aus dem Programm-Code auszubrechen - in die reale Welt. Wir brauchen zwei zus\u00e4tzliche Dinge: Die M\u00f6glichkeit Ereignisse in der realen Welt in Sonic-Pi-Ereignisse umzuwandeln, um damit zu programmieren Die M\u00f6glichkeit Sonic Pis starkes Takt-Modell und Semantik zu nutzen, um Objekte in der realen Welt zu steuern und zu ver\u00e4ndern Gl\u00fccklicherweise gibt es ein Protokoll, das schon seit den 80ern existiert, das genau diese Art von Interaktion m\u00f6glich macht - MIDI. Es gibt eine unglaubliche Anzahl an externen Ger\u00e4ten, unter anderem Keyboards, Controller, Sequencer, und professionelle Audio Software, die alle MIDI unterst\u00fctzen. Wir k\u00f6nnen MIDI nutzen, um Daten zu empfangen und auch um Daten zu senden. Sonic Pi bietet vollst\u00e4ndige Unterst\u00fctzung f\u00fcr das MIDI Protokoll, was es dir erlaubt deinen Live-Code mit der realen Welt zu verbinden. Lass uns das genauer untersuchen ...","title":"11 MIDI"},{"location":"#section-11-1","text":"In diesem Abschnitt werden wir lernen einen MIDI-Controller anzuschlie\u00dfen, um Ereignisse an Sonic Pi zu senden, mit denen unsere Synths und Kl\u00e4nge steuern. Besorge dir einen MIDI-Controller, wie z. B. ein Keyboard oder eine Controller-Oberfl\u00e4che und lass uns handgreiflich werden!","title":"11.1 MIDI In"},{"location":"#midi-controller-verbinden","text":"Um Informationen von einem externen MIDI-Ger\u00e4t in Sonic Pi zu bekommen m\u00fcssen wir es zun\u00e4chst an unseren Computer anschlie\u00dfen. Normalerweise wird das mittels einer USB-Verbindung sein, \u00e4ltere Ger\u00e4te hingegen haben einen 5-Pol-DIN-Stecker f\u00fcr den du Hardwareunterst\u00fctzung in deinem Computer brauchst (manche Audio-Interfaces bzw. Soundkarten haben MIDI-DIN-Stecker). Nachdem du dein Ger\u00e4t angeschlossen hast, starte Sonic Pi und wirf einen Blick auf den I/O-Bereich in den Einstellungen. Du solltest dein Ger\u00e4t dort aufgelistet finden. Falls nicht, klicke auf 'MIDI zur\u00fccksetzen' und sieh nach, ob es auftaucht. Wenn du immer noch keinen Eintrag in der Liste findest, ist der n\u00e4chste Schritt zu versuchen in der MIDI-Konfiguration deines Betriebssystems nachzusehen, um zu sehen ob dein Ger\u00e4t erkannt wird. Wenn das alles fehlschl\u00e4gt, kannst du gerne in unserem freundlichen \u00f6ffentlichen Forum Fragen dazu stellen: https://in-thread.sonic-pi.net","title":"MIDI-Controller verbinden"},{"location":"#midi-ereignisse-empfangen","text":"Sobald dein Ger\u00e4t verbunden ist, wird Sonic Pi automatisch Ereignisse empfangen. Du kannst das selbst nachpr\u00fcfen indem du dein MIDI-Ger\u00e4t bedienst und auf das Cue-Protokoll unten rechts im Anwendungsfenster unterhalb des Protokolls schaust (falls es nicht sichtbar ist, gehe zu Einstellungen->Editor->Ein-/Ausblenden und aktiviere 'Zeige Cue-Protokoll'). Du wirst einen Datenstrom von Ereignissen sehen wie: /midi:nanokey2_keyboard:0:1/note_off [55, 64] /midi:nanokey2_keyboard:0:1/note_on [53, 102] /midi:nanokey2_keyboard:0:1/note_off [57, 64] /midi:nanokey2_keyboard:0:1/note_off [53, 64] /midi:nanokey2_keyboard:0:1/note_on [57, 87] /midi:nanokey2_keyboard:0:1/note_on [55, 81] /midi:nanokey2_keyboard:0:1/note_on [53, 96] /midi:nanokey2_keyboard:0:1/note_off [55, 64] Wenn du einen Strom von Signalen wie diesen siehst, hast du dein MIDI-Ger\u00e4t erfolgreich verbunden. Gl\u00fcckwunsch, lass uns schauen, was wir damit machen k\u00f6nnen!","title":"MIDI-Ereignisse empfangen"},{"location":"#midi-time-state","text":"Diese Ereignisse sind in zwei Abschnitte unterteilt. Als Erstes steht da der Name des Ereignisses, wie z. B. /midi:nanokey2_keyboard:0:1/note_on und zum Zweiten gibt es die Werte des Ereignisses wie z. B. [18, 62] . Interessanterweise sind das die zwei Dinge, die wir brauchen, um Ereignisse in Time-State zu speichern. Sonic Pi f\u00fcgt eingehende MIDI-Ereignisse automatisch in Time-State ein . Das bedeutet du kannst auf den letzten MIDI -Wert mit get zugreifen, und auch mit sync auf den n\u00e4chsten MIDI-Wert warten - dabei kannst du alles anwenden, was wir in Abschnitt 10 dieses Tutorials gelernt haben.","title":"MIDI-Time-State"},{"location":"#programm-code-steuern","text":"Nachdem wir jetzt ein MIDI-Ger\u00e4t verbunden haben, dessen Ereignisse im Cue-Protokoll sehen konnten und wissen, dass unsere Kenntnisse \u00fcber Time-State alles sind, was wir zum Arbeiten mit Ereignissen brauchen - k\u00f6nnen wir jetzt anfangen Spa\u00df zu haben. Lass uns ein einfaches MIDI-Piano bauen: live_loop :midi_piano do note, velocity = sync \"/midi:nanokey2_keyboard:0:1/note_on\" synth :piano, note: note end Es passieren einige Dinge im obigen Code, einschlie\u00dflich einiger Probleme. Zun\u00e4chst haben wir da einen einfachen live_loop , der den Code zwischen dem do / end Block unendlich wiederholt. Das wurde im Abschnitt 9.2 behandelt. Danach rufen wir sync auf, um auf das n\u00e4chste Time-State-Ereignis zu warten. Wir benutzen eine Zeichenkette, die das MIDI-Signal repr\u00e4sentiert, nach dem wir suchen (es ist dasselbe, das uns im Cue-Protokoll angezeigt wurde). Achte darauf, wie dir Sonic Pi die vollst\u00e4ndige Zeichenkette mit seinem Autovervollst\u00e4ndigungssystem erstellt, sodass du sie nicht komplett von Hand eintippen musst. Im Protokoll haben wir gesehen, dass es zwei Werte f\u00fcr jedes MIDI-Note-on-Ereignis gab, also weisen wir das Ergebnis zwei separaten Variablen note und velocity zu. Schlie\u00dflich triggern wir den :piano -Synth und \u00fcbergeben unsere Note. Jetzt probiere du es. Gib den obigen Programm-Code ein, ersetzte in sync den Schl\u00fcssel mit einer Zeichenkette, die zu deinem spezifischen MIDI-Ger\u00e4t passt und klicke auf Ausf\u00fchren. Hey, und schon hast du ein funktionierendes Klavier! Wahrscheinlich fallen dir jedoch ein paar Probleme auf: Unabh\u00e4ngig davon wie stark du die Tasten anschl\u00e4gst, klingen die Noten immer gleich laut. Das l\u00e4sst sich leicht dadurch beheben, dass wir den MIDI-Wert f\u00fcr Velocity (Anschlagst\u00e4rke) nutzen und zu Lautst\u00e4rke wandeln. Da MIDI einen Wertebereich von 0-127 hat, m\u00fcssen wir diese Zahl in einen Wert zwischen 0->1 zu konvertieren, indem wir sie einfach durch 127 teilen: live_loop :midi_piano do note, velocity = sync \"/midi:nanokey2_keyboard:0:1/note_on\" synth :piano, note: note, amp: velocity / 127.0 end Aktualisiere deinen Code und klicke nochmals auf Ausf\u00fchren. Jetzt wird der Anschlagst\u00e4rke des Keyboards ber\u00fccksichtigt. Als n\u00e4chstes lass uns diese nervige Pause loswerden.","title":"Programm-Code steuern"},{"location":"#latenz-entfernen","text":"Bevor wir die Pause entfernen k\u00f6nnen, m\u00fcssen wir herausfinden, warum sie da ist. Um alle Synths und Effekte auf einer Vielzahl von unterschiedlich starken CPUs gut getaktet zu halten, setzt Sonic Pi Audio-Ereignisse standardm\u00e4\u00dfig 0,5 Sekunden im Voraus an. (Beachte, dass diese zus\u00e4tzliche Latenz \u00fcber die Funktionen set_sched_ahead_time! und use_sched_ahead_time konfiguriert werden kann). Diese 0,5 Sekunden Latenz werden zu unseren :piano Synth-Triggern hinzugef\u00fcgt, so wie bei allen Synths, die von Sonic Pi getriggert werden. Typischerweise wollen wir diese hinzugef\u00fcgte Latenz, weil sie bedeutet, dass alle Synths gut getaktet laufen werden. Das ergibt jedoch nur Sinn bei Synths, die von Programm-Code durch play und sleep getriggert werden. In diesem Fall triggern wir den :piano -Synth jedoch tats\u00e4chlich mit unserem externen MIDI-Ger\u00e4t und m\u00f6chten daher nicht, dass Sonic Pi das Timing f\u00fcr uns steuert. Wir k\u00f6nnen diese Latenz mit dem Befehl use_real_time ausschalten, der f\u00fcr den aktuellen Thread die Latenz ausschaltet. Das bedeutet, dass du den Echtzeitmodus use_real_time f\u00fcr Live-Loops verwenden kannst, die ihr Timing mittels sync mit externen Ger\u00e4ten synchronisieren, und f\u00fcr alle anderen Live-Loops die normale Latenz behalten kannst. Lass mal sehen: live_loop :midi_piano do use_real_time note, velocity = sync \"/midi:nanokey2_keyboard:0:1/note_on\" synth :piano, note: note, amp: velocity / 127.0 end Passe deinen Code entsprechend dem obigen Code an und klicke nochmals auf Ausf\u00fchren. Jetzt haben wir ein Piano mit niedriger Latenz und variabler Anschlagst\u00e4rke mit nur 5 Zeilen programmiert. Wenn das nicht einfach war!","title":"Latenz entfernen"},{"location":"#werte-erhalten","text":"Schlie\u00dflich, da unsere MIDI-Ereignisse direkt in den Time-State gehen, k\u00f6nnen wir die get -Funktion benutzen, um den letzten gesehenen Wert zu erhalten. Dies blockiert nicht den aktuellen Thread und gibt nil zur\u00fcck, wenn es keinen Wert gibt (was du \u00fcberschreiben kannst, indem du einen Standardwert \u00fcbergibst - sieh dir daf\u00fcr die Dokumentation f\u00fcr get an). Erinnere dich, dass du get in jedem Thread und zu jeder Zeit aufrufen kannst, um den letzten passenden Time-State-Wert zu erhalten. Du kannst sogar time_warp benutzen, um in der Zeit zur\u00fcck zu springen und mit get vergangene Events angezeigt zu bekommen ...","title":"Werte erhalten"},{"location":"#jetzt-hast-du-die-kontrolle","text":"Das eigentlich Aufregende ist, dass du dieselben Code-Strukturen verwenden kannst, um mittels sync und get MIDI-Informationen mit jedem beliebigen MIDI-Ger\u00e4t zu synchronisieren und du mit diesen Werten tun kannst, was du willst. Jetzt kannst du entscheiden, was dein MIDI-Ger\u00e4t tun wird!","title":"Jetzt hast du die Kontrolle"},{"location":"#section-11-2","text":"Zus\u00e4tzlich zum Empfangen von MIDI-Ereignissen k\u00f6nnen wir auch MIDI-Ereignisse aussenden, um externe Hardware-Synths, Keyboards und andere Ger\u00e4te zu triggern und zu steuern. Sonic Pi bietet einen vollst\u00e4ndigen Satz von Funktionen zum Senden verschiedener MIDI-Signale wie z. B: Note an - midi_note_on Note aus - midi_note_off Steuerungs\u00e4nderung - midi_cc Tonh\u00f6hen\u00e4nderung - midi_pitch_bend Taktgeber - midi_clock_tick Es gibt noch eine Menge weiterer MIDI-Signale, die unterst\u00fctzt werden \u2013 sieh dir in der API-Dokumentation alle weiteren Funktionen an, die mit midi_ beginnen.","title":"11.2 MIDI-Ausgabe"},{"location":"#mit-einem-midi-gerat-verbinden","text":"Um ein MIDI-Signal an ein externes Ger\u00e4t zu senden, muss es zun\u00e4chst angeschlossen sein. F\u00fcr weitere Details sieh dir den Unterabschnitt 'Anschlie\u00dfen eines MIDI-Controllers' in Abschnitt 11.1 an. Beachte, dass, wenn du dich \u00fcber USB mit einem Ger\u00e4t verbindest, an das du sendest (anstatt zu empfangen) die Prozedur jeweils die gleiche ist. Wenn du jedoch die klassischen DIN-Anschl\u00fcsse verwendest, stelle sicher, dass du es mit dem MIDI-Ausgang deines Computers verbindest. Du solltest dein MIDI-Ger\u00e4t in den Einstellungen sehen.","title":"Mit einem MIDI-Ger\u00e4t verbinden"},{"location":"#midi-ereignisse-senden","text":"Die vielen midi_* -Funktionen arbeiten ebenso wie play , sample und synth , indem sie ein Signal zur aktuellen (logischen) Zeit schicken . Um zum Beispiel Aufrufe an die midi_* -Funktionen zu verteilen, musst du sleep in der gleichen Weise benutzen wie du es bei play getan hast. Lass uns das ansehen: midi_note_on :e3, 50 Dies sendet ein MIDI-Note-on-Ereignis an das angeschlossene MIDI-Ger\u00e4t mit Anschlagst\u00e4rke 50. (Beachte, dass Sonic Pi Noten in der Form von :e3 automatisch in ihre entsprechenden MIDI-Nummern konvertiert, wie z. B. 52 in diesem Fall.) Wenn dein MIDI-Ger\u00e4t ein Synthesizer ist, solltest du h\u00f6ren k\u00f6nnen, wie er eine Note spielt. Um dies zu deaktivieren verwende midi_note_off : midi_note_off :e3","title":"MIDI-Ereignisse senden"},{"location":"#auswahl-eines-midi-gerates","text":"Standardm\u00e4\u00dfig wird Sonic Pi jedes MIDI-Signal an alle angeschlossenen Ger\u00e4te auf allen MIDI-Kan\u00e4len senden. Auf diese Art ist es leicht mit einem einzelnen verbundenen Ger\u00e4t zu arbeiten, ohne zuvor etwas einstellen zu m\u00fcssen. Allerdings kann es sein, dass ein MIDI-Ger\u00e4t MIDI-Kan\u00e4le auf spezielle Art handhabt (m\u00f6glicherweise hat jede Note einen eigenen Kanal) - und au\u00dferdem m\u00f6chtest vielleicht mehr als ein MIDI-Ger\u00e4t zur gleichen Zeit anschlie\u00dfen. Und bei etwas komplizierteren Setups, m\u00f6chtest du wahrscheinlich genauer bestimmen, welches Ger\u00e4t welche(s) Signal(e) erh\u00e4lt, und auf welchem Kanal. Wir k\u00f6nnen festlegen an welches Ger\u00e4t wir senden, indem wir die port: -Option verwenden, in der wir den Ger\u00e4tenamen verwenden, wie er in den Einstellungen angezeigt wird: midi_note_on :e3, port: \"moog_minitaur\" Wir k\u00f6nnen ebenfalls angeben, an welchen Kanal gesendet werden soll, indem wir die Option channel: (mit einem Wert im Bereich 1-16) verwenden: midi_note_on :e3, channel: 3 Nat\u00fcrlich k\u00f6nnen wir auch beides zugleich festlegen, um an ein bestimmtes Ger\u00e4t auf einen bestimmten Kanal zu senden: midi_note_on :e3, port: \"moog_minitaur\", channel: 5","title":"Auswahl eines MIDI-Ger\u00e4tes"},{"location":"#midi-studio","text":"Und schlie\u00dflich ist es eine wirklich spannende Sache, den Audio-Ausgang deines MIDI-Synthesizers mit einem der Audio-Eing\u00e4nge deiner Soundkarte zu verbinden. So kannst du deinen Synthesizer mit den midi_* Funktionen steuern und gleichzeitig die erzeugten Kl\u00e4nge mit live_audio und Effekten ver\u00e4ndern: with_fx :reverb, room: 1 do live_audio :moog end live_loop :moog_trigger do midi (octs :e1, 3).tick, sustain: 0.1 sleep 0.125 end (Die midi -Funktion ist eine handliche Kurzform, um note on - und note off -Ereignisse mit einem einzigen Befehl zu senden. F\u00fcr weitere Informationen wirf einen Blick in ihre Dokumentation).","title":"MIDI-Studio"},{"location":"#section-12","text":"Es gibt neben MIDI in Sonic Pi noch einen Weg \u00fcber das Netzwerk ein- und ausgehende Informationen zu \u00fcbertragen - das ist OSC - Open-Sound-Control, ein einfaches Netzwerkprotokoll. Es l\u00e4sst dich Signale mit externen Programme austauschen (mit Programmen sowohl auf deinem wie auch auf externen Computern) und erweitert damit die M\u00f6glichkeiten zur Steuerung weit \u00fcber MIDI hinaus, welches durch sein Design aus den 80ern bestimmten Einschr\u00e4nkungen unterliegt. Zum Beispiel k\u00f6nntest du ein Programm in einer anderen Programmiersprache schreiben, welches OSC-Signale sendet und empf\u00e4ngt (es gibt OSC-Bibliotheken f\u00fcr so ziemlich alle gebr\u00e4uchlichen Programmiersprachen) - und direkt mit Sonic Pi zusammenarbeitet. Wof\u00fcr du das einsetzen kannst, wird nur durch deine Vorstellungskraft begrenzt.","title":"12 OSC"},{"location":"#section-12-1","text":"Standardm\u00e4\u00dfig lauscht Sonic Pi wenn es gestartet wird an Port 4560 auf eingehende OSC-Signale von Programmen auf demselben Computer. Das bedeutet, dass du ohne weitere Konfiguration Sonic Pi ein OSC-Signal senden kannst und dieses im Cue-Protokoll, genauso wie eingehende MIDI-Signale, angezeigt wird. Das hei\u00dft auch, jedes eingehende OSC-Signal wird automatisch zum Time-State hinzugef\u00fcgt, was bedeutet, dass du get und sync verwenden kannst, um mit den eingehenden Daten zu arbeiten - genauso wie bei MIDI und der Synchronisierung von live_loops - sieh in den Abschnitten 5.7 und 10.2 nach, um zu rekapitulieren, wie das funktioniert.","title":"12.1 OSC empfangen"},{"location":"#ein-einfacher-osc-empfanger","text":"Lass uns einen einfachen OSC-Empf\u00e4nger bauen: live_loop :foo do use_real_time a, b, c = sync \"/osc*/trigger/prophet\" synth :prophet, note: a, cutoff: b, sustain: c end In diesem Beispiel geben wir einen OSC-Pfad an, mit dem wir uns synchronisieren, \"/osc*/trigger/prophet\" . Dies kann ein beliebiger g\u00fcltiger OSC-Pfad sein (alle Buchstaben und Zahlen sind erlaubt, das / wird wie in einer URL verwendet um W\u00f6rter zu trennen). Das Pr\u00e4fix /osc wird von Sonic Pi allen eingehenden OSC-Signalen vorangestellt, also m\u00fcssen wir eine OSC-Signal mit dem Pfad /trigger/prophet senden, damit der sync -Befehl beendet und der prophet-Synth getriggert wird.","title":"Ein einfacher OSC-Empf\u00e4nger"},{"location":"#osc-an-sonic-pi-senden","text":"Wir k\u00f6nnen OSC von jeder beliebigen Programmsprache, die eine Bibliothek f\u00fcr OSC bietet, aus an Sonic Pi senden. Wenn wir zum Beispiel OSC von Python aus senden, machen wir vielleicht so etwas: from pythonosc import osc_message_builder from pythonosc import udp_client sender = udp_client.SimpleUDPClient('127.0.0.1', 4560) sender.send_message('/trigger/prophet', [70, 100, 8]) Oder wenn wir OSC aus Clojure senden, machen wir vielleicht etwas wie dies aus dem REPL: (use 'overtone.core) (def c (osc-client \"127.0.0.1\" 4560)) (osc-send c \"/trigger/prophet\" 70 100 8)","title":"OSC an Sonic Pi senden"},{"location":"#von-externen-computern-empfangen","text":"Aus Sicherheitsgr\u00fcnden empf\u00e4ngt Sonic Pi standardm\u00e4\u00dfig keine OSC Nachrichten von externen Computern. Du kannst jedoch Unterst\u00fctzung f\u00fcr externe Ger\u00e4te unter Einstellungen->I/O->Netzwerk->Empfange OSC von externen Computern einschalten. Du kannst anschlie\u00dfend OSC-Signale beliebigen Computern in deinem Netzwerk empfangen. Das sendende Ger\u00e4t muss daf\u00fcr deine IP-Adresse kennen (eine eindeutige Bezeichnung deines Computers in deinem Netzwerk - ganz so wie eine Telefonnummer oder Email-Adresse). Du kannst die IP-Adresse deines Computers herausfinden, indem du in Einstellungen im Abschnitt I/O nachsiehst. (Falls dein Computer mehrere IP-Adressen haben sollte, kannst du die alle bekannten Adressen anzeigen lassen, indem du den Mauszeiger \u00fcber der angezeigten Adresse schweben l\u00e4sst). Beachte, dass manche Programme, wie z. B. TouchOSC f\u00fcr iPhone und Android, das Senden von OSC-Signalen von Haus aus unterst\u00fctzen. Also kannst du, sobald du auf OSC-Signale von externen Ger\u00e4ten lauscht und du deine IP-Adresse kennst, anfangen OSC-Signale von Apps wie TouchOSC zu senden und deine eigenen Steuerungen mit Slidern, Schaltfl\u00e4chen, Drehkn\u00f6pfen usw. zu bauen. Das kann dir eine enorme Bandbreite an Eingabem\u00f6glichkeiten erschlie\u00dfen.","title":"Von externen Computern empfangen"},{"location":"#section-12-2","text":"So wie wir OSC empfangen und mittels Time-State verarbeiten, k\u00f6nnen wir auch OSC senden (ganz so wie wir MIDI-Signale im Takt unserer Musik senden k\u00f6nnen). Wir m\u00fcssen nur wissen an welche IP-Adresse und welchen Port wir senden. Lass uns das ausprobieren: use_osc \"localhost\", 4560 osc \"/hello/world\" Wenn du den Code von oben ausf\u00fchrst, wird dir auffallen, dass Sonic Pi ein OSC-Signal an sich selbst sendet! Das kommt daher, dass wir als IP-Adresse und Port auf den Standard-OSC-Port von Sonic Pi gesetzt haben. Das ist im Grunde so, als w\u00fcrdest du einen Brief an dich selbst schreiben - das OSC-Paket wird erzeugt, verl\u00e4sst Sonic Pi, landet auf dem Netzwerkstapel deines Betriebssystems, das es dann zur\u00fcck an Sonic Pi schickt, mit dem im Protokoll sichtbaren Standard-OSC-Signal /osc:127.0.0.1:4560/hello/world . (Beachte wie Sonic Pi automatisch das Prefix /osc f\u00fcr alle eingehenden Nachrichten setzt.)","title":"12.2 OSC senden"},{"location":"#osc-an-andere-programme-senden","text":"Nat\u00fcrlich kann es lustig sein OSC-Signale an uns selbst zu senden, hilfreich ist es aber nicht. Den echten Nutzen erkennen wir dann, wenn wir Nachrichten an andere Programme senden: use_osc \"localhost\", 123456 osc \"/hello/world\" In diesem Beispiel gehen wir davon aus, dass ein Programm auf dem selben Computer an Port 123456 lauscht. Falls dies der Fall ist, wird es ein OSC-Signal mit dem Inhalt \"/hello/world\" erhalten, welches es dann verarbeiten kann. Wenn dein Programm auf einer anderen Maschine l\u00e4uft, m\u00fcssen wir deren IP-Adresse kennen, welche wir anstelle von \"localhost\" verwenden: use_osc \"192.168.10.23\", 123456 osc \"/hello/world\" Nun k\u00f6nnen wir OSC-Signale zu jedem erreichbaren Ger\u00e4t senden, \u00fcber das lokale Netzwerk und sogar auch \u00fcber das Internet!","title":"OSC an andere Programme senden"},{"location":"#section-13","text":"In Sachen Klangproduktion haben wir bis jetzt das Triggern von Synths und aufgenommenen Kl\u00e4ngen \u00fcber die Funktionen play , synth und sample erkundet. Diese haben dann h\u00f6rbare T\u00f6ne erzeugt, die \u00fcber unser Stereo-Lautsprecher-System abgespielt wurden. Viele Computer verf\u00fcgen jedoch auch \u00fcber die F\u00e4higkeit Kl\u00e4nge einzuspielen, \u00fcber ein Mikrofon zum Beispiel, und zus\u00e4tzlich auch \u00fcber mehr als zwei Ausg\u00e4nge auszuspielen. Oft wird diese F\u00e4higkeit durch die Verwendung eines externen Audio-Interface m\u00f6glich gemacht - es gibt sie f\u00fcr alle Plattformen. In diesem Abschnitt der Tutorials sehen wir uns an, wie wir ein solches externes Audio-Interface nutzen und damit m\u00fchelos mit mehreren Kan\u00e4len Audio auf Ein- und -Ausg\u00e4ngen in Sonic Pi arbeiten k\u00f6nnen.","title":"13 Multikanal-Audio"},{"location":"#section-13-1","text":"Ein einfacher (und vielleicht schon bekannter) Weg um in Sonic Pi Audio-Eing\u00e4nge zu verwenden ist mit Hilfe unseres Freundes synth bzw. der :sound_in -Funktion: synth :sound_in Dieser Synth wird genauso funktionieren wie jeder andere Synth, beispielsweise synth:dsaw , mit der Ausnahme dass das eingehende Audio-Signal direkt vom ersten Eingang deiner System-Sound-Karte gelesen wird. Auf Laptops ist dies normalerweise das eingebaute Mikrofon, falls du aber ein externes Audio-Interface verwendest, kannst du auch jedes andere Audio-Signal an den ersten Eingang anschlie\u00dfen.","title":"13.1 Sound-In"},{"location":"#erhohung-der-dauer","text":"Eine Sache die dir sicher auffallen wird, ist, dass genauso wie synth:dsaw der :sound_in -Synth nur f\u00fcr einen Beat lang h\u00f6rbar ist, da er die Standard-H\u00fcllkurve verwendet. Falls du ihn f\u00fcr etwas l\u00e4nger offen halten m\u00f6chtest, kannst du die Einstellungen der ADSR-H\u00fcllkurve \u00e4ndern. Im folgenden Beispiel wird der Synth f\u00fcr 8 Schl\u00e4ge h\u00f6rbar sein, bevor die Verbindung geschlossen wird: synth :sound_in, sustain: 8","title":"Erh\u00f6hung der Dauer"},{"location":"#effekte-hinzufugen","text":"Nat\u00fcrlich kannst du, genau wie bei jedem normalen Synth auch, mit dem FX block einfach Effekte anwenden: with_fx :reverb do with_fx :distortion do synth :sound_in, sustain: 8 end end Falls du nun eine Gitarre an den ersten Eingang angeschlossen hast, solltest du sie jetzt mit einer Verzerrung und Hall h\u00f6ren k\u00f6nnen, bis der Synth erwartungsgem\u00e4\u00df endet. Du kannst den :sound_in -Synth so viele Male gleichzeitig einsetzen, wie du m\u00f6chtest (genauso wie du es mit jedem anderen Synth machen w\u00fcrdest). Zum Beispiel werden im Folgenden zwei :sound_in -Synths gleichzeitig gespielt - einer mit Verzerrung der andere mit Hall: with_fx :distortion do synth :sound_in, sustain: 8 end with_fx :reverb do synth :sound_in, sustain: 8 end","title":"Effekte hinzuf\u00fcgen"},{"location":"#mehrere-eingange","text":"Du kannst \u00fcber die input: -Option jeweils ausw\u00e4hlen \u00fcber welchem Audio-Eingang du spielen willst. Du kannst au\u00dferdem mit :sound_in_stereo -Synth auch einen Stereo-Eingang (zwei aufeinander folgende Eing\u00e4nge) bestimmen. Mit dem folgenden Beispiel k\u00f6nntest du, wenn du \u00fcber eine Sound-Karte mit mindestens drei Eing\u00e4ngen verf\u00fcgst, die ersten beiden als Stereo-Signal behandeln und Verzerrung hinzuf\u00fcgen, und den dritten als Mono-Signal behandeln und Hall hinzuf\u00fcgen: with_fx :distortion do synth :sound_in_stereo, sustain: 8, input: 1 end with_fx :reverb do synth :sound_in, sustain: 8, input: 3 end","title":"Mehrere Eing\u00e4nge"},{"location":"#mogliche-probleme","text":"Obwohl dies eine n\u00fctzliche Technik darstellt, gibt es doch einige Beschr\u00e4nkungen bei diesem Ansatz. Zun\u00e4chst funktioniert sie nur \u00fcber eine festgelegte Dauer (da sie an eine ADSR-H\u00fcllkurve gebunden ist), und des weiteren gibt es keine M\u00f6glichkeit, die Effekte umzuschalten, sobald der Synth getriggert wurde. Beides sind typische Anforderungen, wenn wir mit externen Audio-Signalen wie Mikrophonen, Gitarren und externen Synthesizern arbeiten. Wir werden uns daher mit Sonic Pis L\u00f6sung zu dem Problem besch\u00e4ftigen, mit einem (potentiell) unendlichen Audio-Signal an einem Audio-Eingang zu arbeiten: live_audio .","title":"M\u00f6gliche Probleme"},{"location":"#section-13-2","text":"Der :sound_in -Synth wie er im vorherigen Abschnitt beschrieben wurde, stellt eine sehr flexible und g\u00e4ngige Methode dar, um mit Audio-Eingangssignalen zu arbeiten. Allerdings gibt es, wie beschrieben, Beschr\u00e4nkungen bei der Behandlung einzelner Audio-Signalen als ein einzelnes Instrument (wie z. B. Stimme oder Gitarre). Mit Abstand der beste Ansatz f\u00fcr die Arbeit mit einem einzelnen anhaltenden Audio-Signal ist live_audio zu nutzen.","title":"13.2 Live-Audio"},{"location":"#ein-benannter-audio-eingang","text":"live_audio teilt einige der zentralen Design-Beschr\u00e4nkungen mit live_loop (daher der \u00e4hnliche Name). Erstens muss es einen eindeutigen Namen haben, und zweitens darf es zu jedem Zeitpunkt immer nur einen live_audio -Stream mit diesem Namen geben. Lass uns das mal ansehen: live_audio :foo Dieser Code wird sich \u00e4hnlich verhalten wie synth :sound_in , mit einigen wesentlichen Unterschieden: er l\u00e4uft ununterbrochen (bis du ihn ausdr\u00fccklich stoppst), und du kannst ihn dynamisch in neue Effekt-Bl\u00f6cke schieben .","title":"Ein benannter Audio-Eingang"},{"location":"#mit-effekten-arbeiten","text":"Beim ersten Trigger verh\u00e4lt sich live_audio exakt so, wie du es bei der Arbeit mit Effekten erwarten w\u00fcrdest. Zum Beispiel, um einen Live-Audio-Stream mit hinzugef\u00fcgtem Hall zu starten, verwende einfach einen :reverb -Effekt-Block: with_fx :reverb do live_audio :foo end Wie auch immer, angenommen dass live_audio f\u00fcr immer l\u00e4uft (zumindest bis du es stoppst), w\u00e4re es doch sehr beschr\u00e4nkend wenn, wie mit den anderen Synths, Live-Audio f\u00fcr seine gesamte Dauer an den Effekt-Block gebunden bliebe. Gl\u00fccklicherweise ist das nicht der Fall, und Live-Audio wurde so entworfen, dass es einfach zwischen verschiedenen Effekten bewegt werden kann. Lass uns das versuchen. Lass den obigen Code laufen, um \u00fcber Live-Audio direkt das Signal zu h\u00f6ren, das am ersten Eingang deiner Sound-Karte anliegt. Beachte: Wenn du ein Laptop benutzt, wird dies standardm\u00e4\u00dfig das eingebaute Mikrophon sein - es ist also empfehlenswert Kopfh\u00f6rer zu verwenden, um Feedback zu vermeiden. Nun, w\u00e4hrend du noch den Ton live von deiner Sound-Karte mit Hall h\u00f6rst, \u00e4ndere den Code in Folgendes: with_fx :echo do live_audio :foo end Nun klicke Ausf\u00fchren, und sofort wirst du den Sound mit dem Echo-Effekt h\u00f6ren und nicht mehr mit Hall. Wenn du beide h\u00f6ren willst, \u00e4ndere einfach wieder den Code und klicke Ausf\u00fchren: with_fx :reverb do with_fx :echo do live_audio :foo end end Es ist wichtig darauf hinzuweisen, dass du live_audio :foo aus jedem Thread oder Live-Loop heraus aufrufen kannst, und es wird den Live-Audio-Synth in den Effekt-Kontext dieses Threads verschieben. Du k\u00f6nntest also leicht mehrere Live-Loops haben, die live_audio :foo automatisch zu unterschiedlichen Zeiten in unterschiedlichen Effekt-Kontexten aufrufen, was zu interessanten Ergebnissen f\u00fchren kann.","title":"Mit Effekten arbeiten"},{"location":"#live-audio-stoppen","text":"Da Live-Audio anders als andere Synths keine H\u00fcllkurve hat, wird es f\u00fcr immer weiterlaufen (sogar wenn du den Code l\u00f6scht, genau wie bei einer Funktion, ist es immer noch im Speicher definiert, wenn du den Code im Editor l\u00f6scht). Um es anzuhalten, musst du das :stop -Argument anwenden: live_audio :foo, :stop Es kann einfach neu gestartet werden, indem du es erneut ohne :stop -Argument ausf\u00fchrst: live_audio :foo Au\u00dferdem werden alle laufenden Live-Audio-Synths gestoppt, wenn du auf Stopp klickst (genau wie bei allen anderen Synths und Effekten).","title":"Live-Audio stoppen"},{"location":"#stereo-eingang","text":"In Bezug auf die Audio-Kan\u00e4le verh\u00e4lt sich Live-Audio standardm\u00e4\u00dfig wie der :sound_in -Synth, indem er einen einzelnes Mono-Eingangssignal nimmt und in einen Stereo-Stream wandelt, unter Verwendung der eingegebenen Panorama-Einstellung. Allerdings, wie bei :sound_in_stereo besteht auch hier die M\u00f6glichkeit, Live-Audio zwei aufeinander folgende Audio-Eing\u00e4nge lesen zu lassen und sie direkt als linken und rechten Kanal zu behandeln. Dies l\u00e4sst sich durch die :stereo -Option erreichen. Um zum Beispiel Eingang 2 als linkes Signal und Eingang 3 als rechtes Signal zu behandeln, musst du die input: -Option wie folgt auf 2 konfigurieren: live_audio :foo, stereo: true, input: 2 Beachte, dass sobald du einen Audio-Stream in Stereo gestartet hast, du nicht zu Mono wechseln kannst, ohne erneut zu stoppen und zu starten. Ebenso, wenn du ihn im standardm\u00e4\u00dfigen Mono-Modus startest, kannst du nicht zu Stereo wechseln, ohne zu stoppen und zu starten.","title":"Stereo-Eingang"},{"location":"#section-13-3","text":"Bisher haben wir in diesem Abschnitt behandelt, wie wir mehrere Audio-Streams in Sonic Pi einbinden k\u00f6nnen - entweder durch den :sound_in -Synth oder \u00fcber das m\u00e4chtige live_audio -System. \u00dcber die Arbeit mit mehreren Audio-Streams aus Eingangssignalen hinaus, kann Sonic Pi ebenso mehrere Audio-Streams als Ausgangssignal ausgeben. Dies wird \u00fcber den :sound_out -Effekt erreicht.","title":"13.3 Sound-Out"},{"location":"#ausgabe-kontexte","text":"Lass uns kurz rekapitulieren, wie Sonic Pis Synths und Effekte ihr Audio-Signal an ihren gegenw\u00e4rtigen Effekt-Kontext \u00fcbergeben. Stell dir zum Beispiel Folgendes vor: with_fx :reverb do # C with_fx :echo do # B sample :bd_haus # A end end Der einfachste Weg, um zu verstehen, was mit dem Audio-Stream passiert, ist beim innersten Audio-Kontext zu starten und uns langsam den Weg nach drau\u00dfen entlang zu arbeiten. In diesem Fall ist der innerste Kontext mit A bezeichnet und ist das :bd_haus -Sample, das getriggert wird. Der Audio-Stream hiervon geht direkt in den Kontext B , welches der :echo -Effekt ist. Dieser f\u00fcgt Echo dem eingehenden Audio-Stream hinzu und gibt es an seinen Kontext weiter - das ist C - der :reverb -Effekt. Dieser f\u00fcgt dann Hall dem eingehenden Audio-Stream hinzu und gibt ihn an seinen Kontext weiter, welcher die oberste Ebene ist - der linke und rechte Lautsprecher (was in deinem Audio-Interface Ausgang 1 und Ausgang 2 entspricht). Der Klang flie\u00dft nach drau\u00dfen den ganzen Weg hindurch als Stereo-Signal.","title":"Ausgabe-Kontexte"},{"location":"#sound-out-effekte","text":"Das oben genannte Verhalten trifft auf alle Synths zu (einschlie\u00dflich live_audio ) und auf den Gro\u00dfteil der Effekte, mit Ausnahme von :sound_out . Der :sound_out -Effekt tut zwei Dinge. Erstens gibt er seinen Audio-Stream wie oben beschrieben an seinen \u00e4u\u00dferen Kontext weiter. Zum Zweiten gibt er ihn auch an einen Ausgang deines Audio-Interface oder deiner Sound-Karte aus. Sehen wir uns das an: with_fx :reverb do # C with_fx :sound_out, output: 3 do # B sample :bd_haus # A end end In diesem Besipiel gibt unser bd_haus -Sample sein Audio an seinen \u00e4u\u00dferen Kontext, welches der :sound_out -Effekt ist. Dieser seinerseits gibt sein Audio an seinen externen Kontext, den :reverb -Effekt weiter (wie erwartet). Allerdings gibt er auch einen Mono-Mix an den Ausgang 3 des Audio-Interface oder der Sound-Karte des Systems. Der Audio-Stream, wie er innerhalb von :sound_out generiert wird hat also zwei Ziele, den :reverb -Effekt und den Audio-Ausgang 3.","title":"Sound-Out-Effekte"},{"location":"#mono-und-stereoausgabe","text":"Wie wir gesehen haben, gibt der :sound_out -Effekt standardm\u00e4\u00dfig einen Mono-Mix des Stereo-Streams an einen bestimmten Kanal aus, zus\u00e4tzlich dazu, dass er ihn (wie erwartet) an seinen \u00e4u\u00dferen Kontext weiter gibt. Wenn ein Mono-Mix nicht gerade das ist, was du nach drau\u00dfen geben willst, hast du eine Reihe von Optionen. Zum Ersten, bei Verwendung der mode: -Option kannst du w\u00e4hlen nur den linken oder den rechten Kanal des Stereo-Streams an das Audio-Interface auszugeben. Oder du kannst den :sound_out_stereo -Effekt verwenden, um zwei aufeinanderfolgende Ausg\u00e4nge des Audio-Interface zu verwenden. Wirf einen Blick in die Dokumentation der Funktion f\u00fcr weitere Informationen und Beispiele.","title":"Mono- und Stereoausgabe"},{"location":"#direct-out","text":"Wie wir auch gesehen haben, ist es das standardm\u00e4\u00dfige Verhalten von :sound_out und :sound_out_stereo Audio sowohl an ihren \u00e4u\u00dferen Kontext (wie f\u00fcr alle Effekte typisch) als auch an den von dir bestimmten Audio-Ausgang deiner Sound-Karte zu schicken. Trotzdem wirst du gelegentlich vielleicht w\u00fcnschen einen Audio-Stream ausschlie\u00dflich an den Ausgang deiner Sound-Karte zu schicken und nicht an den \u00e4u\u00dferen Kontext (und daher deinen Audio-Stream auch nicht gemischt durch die Standard-Ausg\u00e4nge 1 und 2 geschickt zu bekommen). Das ist m\u00f6glich, indem du die Standard-Effekt-Option amp: benutzt, die den Audio-Stream bearbeitet, nachdem der Effekt den Audio-Stream bearbeitet hat: with_fx :sound_out, output: 3, amp: 0 do # B sample :loop_amen # A end Im obigen Beispiel, wird das :loop_amen -Sample an seinen \u00e4u\u00dferen Kontext geschickt, den :sound_out -Effekt. Dieser sendet einen Mono-Mix and den Sound-Karten-Ausgang 3 und multipliziert danach den Audio-Stream mit 0, was diesen essentiell stumm schaltet. Dieses stummgeschaltete Signal wird anschlie\u00dfend an den \u00e4u\u00dferen Kontext des :sound_out -Effektes geschickt, welches der Standard-Ausgang ist. Daher werden bei diesem Code die Standard-Ausgangskan\u00e4le kein h\u00f6rbares Signal erhalten, und an Ausgang 3 wird ein Mono-Mix des Amen-Drum-Break geschickt.","title":"Direct-Out"},{"location":"#section-99","text":"Dieser Abschnitt beschlie\u00dft das einf\u00fchrende Tutorial zu Sonic Pi. Hoffentlich konntest du auf dem Weg ein paar Dinge lernen. Mach dir keine Sorgen, wenn du das Gef\u00fchl hast, nicht alles verstanden zu haben - spiele einfach weiter, hab Spa\u00df dabei, und du wirst alles weitere auf deinem Weg, in deinem eigenen Tempo entdecken. Tauche einfach wieder ein, wenn du das Gef\u00fchl hast , dass eine Frage in einem der Abschnitte des Tutorials beantwortet werden k\u00f6nnte. Wenn du Fragen hast, die nicht in diesem Tutorial behandelt wurden, dann komme damit bitte im Sonic Pi Forum vorbei und stelle deine Frage dort. Du wirst dort Leute treffen, die freundlich sind und dir gerne weiterhelfen. Und abschlie\u00dfend lade ich dich auch dazu ein, dir die \u00fcbrige Dokumentation im Hilfe-System einmal genauer anzuschauen. Es gibt noch eine ganze Reihe von Merkmalen von Sonic Pi, die in diesem Tutorial nicht behandelt wurden und darauf warten, von dir entdeckt zu werden. Also, spiele, hab Spa\u00df, teile deinen Programm-Code, tritt vor deinen Freunden auf, zeige was du auf dem Monitor hast - und vergiss nicht: Es gibt keine Fehler, nur M\u00f6glichkeiten. Sam Aaron","title":"Abschlie\u00dfendes"},{"location":"#section-A","text":"Anhang A b\u00fcndelt Artikel \u00fcber Sonic Pi, die f\u00fcr das MagPi-Magazin geschrieben wurden.","title":"A Anhang A - Artikel aus MagPi"},{"location":"#einstieg-in-den-stoff","text":"Diese Artikel m\u00fcssen nicht in einer bestimmten Reihenfolge gelesen werden, und sie \u00fcberschneiden sich in vielen Punkten mit dem Tutorial. Es geht weniger darum, dir alles \u00fcber Sonic Pi beizubringen - eher fokussieren sie sich jeweils auf einen bestimmten Aspekt von Sonic Pi und behandeln ihn auf unterhaltsame und leicht zug\u00e4ngliche Weise.","title":"Einstieg in den Stoff"},{"location":"#lese-das-magpi","text":"Du kannst die Ausgaben von The MagPi in einem gro\u00dfartigen professionellem Layout als PDFs hier herunterladen: https://www.raspberrypi.org/magpi/","title":"Lese das MagPi"},{"location":"#schlage-ein-thema-vor","text":"Wenn du kein Thema, das dich interessiert, in diesen Artikeln behandelt findest - warum nicht eines vorschlagen? Der einfachste Weg ist ein Tweet mit deinem Vorschlag an @Sonic_Pi . Du kannst nie wissen - dein Vorschlag k\u00f6nnte das Thema des n\u00e4chsten Artikels sein!","title":"Schlage ein Thema vor"},{"location":"#section-A-01","text":"","title":"A.1 Tipps zu Sonic Pi"},{"location":"#1-es-gibt-keine-fehler","text":"Die wichtigste Lektion mit Sonic Pi ist, dass es wirklich keine Fehler gibt. Der beste Weg zu lernen, ist einfach es zu versuchen und zu versuchen und zu versuchen. Probiere viele verschiedene Dinge aus, k\u00fcmmere dich nicht darum, ob dein Programm-Code gut oder schlecht klingt und fange an mit so vielen unterschiedlichen Synths, FXs und Optionen wie m\u00f6glich zu experimentieren. Du wirst viele Dinge entdecken, die dich zum Lachen bringen, weil sie furchtbar klingen und auch richtige Edelsteine, die einfach toll klingen. Lass die Dinge, die dir nicht gefallen einfach beiseite und behalte, was dir gef\u00e4llt. Je mehr 'Fehler' du dir zu machen erlaubst, desto schneller wirst du lernen und deinen eigenen Coding-Sound entdecken.","title":"1. Es gibt keine Fehler"},{"location":"#2-verwende-die-effekte","text":"Sagen wir mal, Du beherrschst die Grundlagen, wie man in Sonic Pi Sounds mit sample und play macht. Was jetzt? Hast Du gewusst, dass Sonic Pi \u00fcber 27 Studio-FX unterst\u00fctzt, mit denen Du den Sound deines Codes ver\u00e4ndern kannst? FX sind sowas wie raffinierte Bildeffekte in Bildbearbeitungsprogrammen; nur das sie nicht unscharf oder schwarz/wei\u00df machen, sondern dem Sound Hall, Verzerrung oder Echo hinzuf\u00fcgen. Stell' Dir vor, wie Du das Kabel von Deiner Gitarre ins Effekt-Pedal steckst und dann in den Verst\u00e4rker. Gl\u00fccklicherweise braucht man keine Kabel, und Sonic Pi macht es sehr einfach, FX einzusetzen. Du musst nur ausw\u00e4hlen, auf welchen Teil Deines Codes Du einen FX anwenden willst und diesen Teil mit dem FX-Code umschlie\u00dfen. Sehen wir uns ein Beispiel an: sample :loop_garzul 16.times do sample :bd_haus sleep 0.5 end Wenn Du einen FX auf das :loop_gazul -Sample anwenden m\u00f6chtest, steckst du es einfach in einen with_fx -Block, und zwar so: with_fx :flanger do sample :loop_garzul end 16.times do sample :bd_haus sleep 0.5 end Wenn Du jetzt einen FX zur Bassdrum hinzuf\u00fcgen m\u00f6chtest, dann packe diese auch in ein with_fx ein: with_fx :flanger do sample :loop_garzul end with_fx :echo do 16.times do sample :bd_haus sleep 0.5 end end Denk' dran, Du kannst jeden Code mit einem with_fx umgeben und jeder Sound, der ausgegeben wird, geht durch diesen FX.","title":"2. Verwende die Effekte"},{"location":"#3-parametrisiere-deine-synths","text":"Um Deine codierten Kl\u00e4nge so richtig entdecken zu k\u00f6nnen, wirst Du sicher bald wissen wollen, wie Du Synths und FX steuern kannst. Vielleicht m\u00f6chtest Du die Dauer eines Tons ver\u00e4ndern, mehr Hall hinzuf\u00fcgen oder die Zeit zwischen zwei Echos ver\u00e4ndern. Mit optionalen Parametern oder kurz Opts bietet Dir Sonic Pi viele M\u00f6glichkeiten, genau das zu tun. Schauen wir uns das mal kurz an. Kopiere diesen Code in einen Puffer und klicke auf Ausf\u00fchren: sample :guit_em9 Oh, was f\u00fcr ein wunderbarer Gitarren-Sound! Spielen wir ein bisschen damit. Wie w\u00e4re es damit, die Abspielgeschwindigkeit (rate) zu \u00e4ndern? sample :guit_em9, rate: 0.5 Was bedeutet der Schnipsel rate: 0.5 , den ich hier am Ende hinzugef\u00fcgt habe? Das ist ein Parameter. Alle Synths und FX in Sonic Pi unterst\u00fctzen diesen und man kann viel damit anstellen. Versuche mal das hier: with_fx :flanger, feedback: 0.6 do sample :guit_em9 end Jetzt setze das feedback auf 1 und h\u00f6r' Dir die verr\u00fcckten Sounds an! Einzelheiten zu den vielen Opts, die Dir zur Verf\u00fcgung stehen, findest Du in der Dokumentation.","title":"3. Parametrisiere Deine Synths"},{"location":"#4-live-code","text":"Die beste Art Sonic Pi schnell kennenzulernen, ist, live zu coden. Du f\u00e4ngst mit irgendeinem Codeschnipsel an und ver\u00e4nderst und verbesserst, w\u00e4hrend der Code abgespielt wird. Wenn Du zum Beispiel nicht wei\u00dft, was der Cutoff-Parameter mit einem Sample macht, probiere es einfach aus. Fangen wir mal an! Kopiere diesen Code in einen Puffer von Sonic Pi: live_loop :experiment do sample :loop_amen, cutoff: 70 sleep 1.75 end Jetzt klicke auf ausf\u00fchren und Du wirst einen leicht muffigen Drum-Break h\u00f6ren. \u00c4ndere den cutoff: -Wert auf 80 und klicke wieder ausf\u00fchren. H\u00f6rst Du den Unterschied? Versuche es mit 90 , 100 , 110 ... Wenn Du die live_loop s einmal im Griff hast, willst du nichts mehr anders verwenden. Wann immer ich einen Live-Coding-Gig habe, brauche ich die live_loop wie ein Schlagzeuger seine Sticks. Um mehr \u00fcber Live-Coding zu erfahren, sieh Dir den Abschnitt 9 im Tutorial an.","title":"4. Live Code"},{"location":"#5-mit-dem-zufall-spielen","text":"Manchmal mogele ich, indem ich Sonic Pi f\u00fcr mich komponieren lasse. Mit Randomisierung l\u00e4sst sich das gro\u00dfartig hinbekommen; das klingt vielleicht ein wenig kompliziert, ist es aber gar nicht. Sehen wir uns das an. Kopiere diesen Code in einen Puffer: live_loop :rand_surfer do use_synth :dsaw notes = (scale :e2, :minor_pentatonic, num_octaves: 2) 16.times do play notes.choose, release: 0.1, cutoff: rrand(70, 120) sleep 0.125 end end Wenn Du das laufen l\u00e4sst, wirst Du eine regelm\u00e4\u00dfige Reihenfolge von zuf\u00e4lligen T\u00f6nen der Skala :e2 :minor_pentatonic gespielt vom :dsaw -Synth h\u00f6ren. \"Halt mal, das ist doch keine Melodie\", h\u00f6re ich Dich schon sagen. Okay, dies ist der erste Teil des Zaubertricks. Jedes Mal, wenn die live_loop durchgelaufen ist, k\u00f6nnen wir Sonic Pi sagen, es soll die Zufallsfolge an einen bestimmten Punkt zur\u00fccksetzen. Das ist ein bisschen so, als w\u00fcrden wir wie Dr. Who in seiner Zeitmaschine TARDIS an einen bestimmten Ort und zu einer bestimmten Zeit zur\u00fcckkehren. Versuche es mal und schreibe die Zeile use_random_seed 1 in die live_loop : live_loop :rand_surfer do use_random_seed 1 use_synth :dsaw notes = (scale :e2, :minor_pentatonic, num_octaves: 2) 16.times do play notes.choose, release: 0.1, cutoff: rrand(70, 120) sleep 0.125 end end Jedes Mal, wenn die live_loop sich wiederholt, wird der Zufalls-Generator zur\u00fcckgesetzt. Das bedeutet, es werden jedes mal die selben 16 Noten ausgew\u00e4hlt. Hey presto, eine Melodie! Doch jetzt kommt der richtig spannende Teil: \u00c4ndere den Wert von seed von 1 in irgendeine andere Zahl. Sagen wir z.B. 4923 . Wow! Eine andere Melodie! Also nur durch das \u00c4ndern einer Zahl (dem so genannten random seed ), kannst Du jegliche nur vorstellbare melodische Kombinationen erforschen! Na, wenn das nicht die Magie des Codes ist.","title":"5. Mit dem Zufall spielen"},{"location":"#section-A-02","text":"Die Laserstrahlen schnitten durch die Rauschwaden als der Subwoofer den Bass tief in die K\u00f6rper der Menge pumpte. Die Atmosph\u00e4re war erf\u00fcllt von einem berauschenden Mix aus Synthesizern und Tanzen. Aber irgendetwas stimmte nicht in diesem Nachtklub. \u00dcber der DJ-Kabine leuchtete in bunten Farben futuristischer Text; bewegte sich, tanzte, blinkte. Dies war keine abgefahrene Lichtshow, sondern einfach eine Projektion von Sonic Pi, das auf einem Raspberry Pi lief. Der Insasse der DJ-Kabine drehte keine Platten, nein, er schrieb und bearbeitete Programmcode. Live. Das ist Live-Coding. Es mag sich wie eine weit hergeholte Geschichte aus einem futuristischen Nachtklub anh\u00f6rt, aber Musik auf diese Weise zu programmieren, ist ein wachsender Trend, bekannt als Live-Coding (http://toplap.org). Eine aktuelle Richtung, die diese Art des Musikmachens eingeschlagen hat, ist der Algorave (http://algorave.com) - Veranstaltungen, auf denen K\u00fcnstler wie ich Musik zum Tanzen programmieren. Du musst aber zum Live-Coden nicht in einem Nachtklub sein. Mit Sonic Pi v2.6+ kannst du \u00fcberall loslegen, wohin du deinen Raspberry Pi und ein Paar Kopfh\u00f6rer oder Lautsprecher mitnimmst. Wenn du das Ende dieses Artikels erreicht hast, wirst du bereits deine eigenen Beats programmieren und live bearbeitest. Wohin do von dort weiter gehst, wird einzig von deiner Vorstellungskraft beschr\u00e4nkt.","title":"A.2 Live Coding"},{"location":"#live-loop","text":"Der Schl\u00fcssel zum 'live-coding' mit Sonic Pi ist das Beherrschen des 'live_loops'. Schauen wir uns einen an: live_loop :beats do sample :bd_haus sleep 0.5 end Ein Live-Loop hat 4 Hauptbestandteile. Der erste ist sein Name. Unser live_loop oben hei\u00dft live_loop . Du kannst frei entscheiden, wie Du Deinen live_loop nennen m\u00f6chtest. Sei kreativ. Ich benutze oft Namen, die dem Publikum etwas \u00fcber die Musik mitteilen, die ich mache. Der zweite Bestandteil ist das Wort do , welches anzeigt, wo der live_loop beginnt. Der dritte ist das Wort end , das markiert, wo der live_loop endet. Schlie\u00dflich gibt es noch den Block innerhalb des live_loop , der beschreibt, was die Schleife wiederholen soll \u2013 das ist der Teil zwischen do und end . In unsrem Fall spielen wir ein Bass-Drum-Sample und warten einen halben Takt. Dies f\u00fchrt zu einem sch\u00f6nen regelm\u00e4\u00dfigen Bass Beat. Auf gehts, kopiere den live_loop in einem leeren Sonic Pi-Puffer und dr\u00fccke auf Ausf\u00fchren. Boom, Boom, Boom!.","title":"Live-Loop"},{"location":"#zur-laufzeit-neu-definieren","text":"OK, aber was ist nun das besondere an einem live_loop ? Bisher scheint er nur eine \u00fcberbewertete \"Schleife\" zu sein! Nun, das Sch\u00f6ne am live_loop ist, dass du ihn im laufenden Programm neu definieren kannst. Das bedeutet, du kannst \u00e4ndern was er machen soll, w\u00e4hrend er l\u00e4uft. Das ist das Geheimnis hinter Live-Coding mit Sonic Pi. Lass uns das ausprobieren: live_loop :choral_drone do sample :ambi_choir, rate: 0.4 sleep 1 end Klicke auf die Ausf\u00fchren -Schaltfl\u00e4che oder dr\u00fccke Alt-R . Du h\u00f6rst jetzt einen wundersch\u00f6nen Chor-Klang. Nun, w\u00e4hrend dieser noch l\u00e4uft, \u00e4ndere deie Rate von 0.4 auf 0.38 . Klicke erneut Ausf\u00fchren . Wow! Hast du geh\u00f6rt, wie der Chor die Note gewechselt hat? Setze sie wieder auf 0.4 , zur\u00fcck auf den alten Wert. Nun setze ihn runter auf 0.2 , runter bis 0.19 und dann wieder hoch auf 0.4 . Sieh wie du durch das \u00c4ndern nur eines Parameters, im laufenden Programm, die volle Kontrolle \u00fcber die Musik erlangen kannst? Spiele ein bisschen mit den Werten f\u00fcr rate - w\u00e4hle deine eigenen Werte. Probiere negative Zahlen, wirklich kleine Zahlen und gro\u00dfe Zahlen. Viel Spa\u00df!","title":"Zur Laufzeit neu definieren"},{"location":"#schlafen-ist-wichtig","text":"Eine der wichtigsten Lektionen \u00fcber 'live_loop's ist, dass sie Pausen brauchen. Betrachte einmal folgenden 'live_loop': live_loop :infinite_impossibilities do sample :ambi_choir end Wenn du versuchst, diese Code auszuf\u00fchren, wirst du bemerken, dass Sonic Pi sich beschwert, dass der live_loop nicht geschlafen hat. Das ist ein Sicherheitssystem! Nimm dir etwas Zeit und denk dar\u00fcber nach, was dieser Code vom Computer verlangt. Genau, der Computer wird gefragt eine unendliche Anzahl an Samples zum Nullzeitpunkt zu spielen. Ohne das Sicherheitssystem wird der arme Computer das probieren und w\u00e4hrenddessen abst\u00fcrzen. Also immer daran denken: Deine live_loop s m\u00fcssen ein sleep beinhalten.","title":"Schlafen ist wichtig"},{"location":"#tone-kombinieren","text":"Musik ist voll von Dingen, die zur selben Zeit geschehen. Das Schlagzeug spielt zur selben Zeit wie der Bass, Gesang und die Gitarre\u2026 In der Informatik nennen wir das Nebenl\u00e4ufigkeit (concurrency). Sonic Pi bietet uns eine einfache M\u00f6glichkeit verschiedenste Dinge zur selben Zeit abspielen zu lassen. Benutze einfach mehr als einen live_loop ! live_loop :beats do sample :bd_tek with_fx :echo, phase: 0.125, mix: 0.4 do sample :drum_cymbal_soft, sustain: 0, release: 0.1 sleep 0.5 end end live_loop :bass do use_synth :tb303 synth :tb303, note: :e1, release: 4, cutoff: 120, cutoff_attack: 1 sleep 4 end Hier haben wir zwei live_loop s. Der eine wiederholt schnell Beats, w\u00e4hrend der andere durch langsames Wiederholen einen verr\u00fcckten Bass Sound kreiert. Eines der interessanten Dinge bei der Verwendung von live_loop in mehreren Instanzen ist, dass sie alle jeweils ihre eigene Zeit verwalten. Das bedeutet, dass es wirklich einfach ist, interessante polyrhythmische Strukturen zu erzeugen und sogar mit Phasenverschiebungen \u00e1 la Steve Reich zu spielen. Schau dir das an: # Steve Reich's Piano Phase notes = (ring :E4, :Fs4, :B4, :Cs5, :D5, :Fs4, :E4, :Cs5, :B4, :Fs4, :D5, :Cs5) live_loop :slow do play notes.tick, release: 0.1 sleep 0.3 end live_loop :faster do play notes.tick, release: 0.1 sleep 0.295 end","title":"T\u00f6ne kombinieren"},{"location":"#alles-zusammenfuhren","text":"Jedes dieser Tutorials werden wir mit einem abschlie\u00dfenden Code-Beispiel beenden, das sich aller zuvor behandelter Ideen bedient. Schau Dir diesen Code genau an und \u00fcberlege Dir, was er tut. Kopiere ihn anschlie\u00dfend in einen neuen Sonic Pi-Puffer, dr\u00fccke auf Start und h\u00f6r Dir an, wie er klingt. \u00c4ndere zum Schluss etwas am Code, indem Du Parameter ver\u00e4nderst oder Dinge auskommentierst. Vielleicht kannst Du das als Ausgangspunkt f\u00fcr eine eigene Performance nutzen. Das Wichtigste ist auf jeden Fall der Spa\u00df dabei. Bis zum n\u00e4chsten Mal \u2026 with_fx :reverb, room: 1 do live_loop :time do synth :prophet, release: 8, note: :e1, cutoff: 90, amp: 3 sleep 8 end end live_loop :machine do sample :loop_garzul, rate: 0.5, finish: 0.25 sample :loop_industrial, beat_stretch: 4, amp: 1 sleep 4 end live_loop :kik do sample :bd_haus, amp: 2 sleep 0.5 end with_fx :echo do live_loop :vortex do # use_random_seed 800 notes = (scale :e3, :minor_pentatonic, num_octaves: 3) 16.times do play notes.choose, release: 0.1, amp: 1.5 sleep 0.125 end end end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-03","text":"Eine der spannendsten und einflussreichsten technischen Entwicklungen der modernen Musik ist die Erfindung von Samplern. Sampler sind Musikinstrumente, die es einem erlauben T\u00f6ne aufzunehmen, sie zu ver\u00e4ndern und auf verschiedene Arten und Weisen wiederzugeben. Zum Beispiel ist es mit einem Sampler m\u00f6glich ein Schlagzeug Solo (oder Break) von einer alten Schalplatte einzuspielen und es anschlie\u00dfend als Grundlage f\u00fcr einen neuen Beat zu verwenden, indem man es mit halber Geschwindigkeit wiedergibt. So ist fr\u00fcher Hip-Hop entstanden und heute gibt es kaum noch Elektronische Musik, die ohne irgendeine Art von Samples auskommt. Samples bieten dir eine gro\u00dfartige M\u00f6glichkeit auf einfache Art und Weise neue und interessante Elemente in Deine live gecodete Performance einflie\u00dfen zu lassen. Aber wo kriegen wir einen Sampler her? Wir haben bereits einen - es ist unser Raspberry Pi! Die mitgelieferte Live-Coding App Sonic Pi stellt uns einen m\u00e4chtigen Sampler bereit. Lasst ihn uns ausprobieren!","title":"A.3 Kodierte Beats"},{"location":"#der-amen-break","text":"Eines der klassischen Schlagzeug-Break-Samples mit dem gr\u00f6\u00dften Wiedererkennungswert ist der Amen-Break. Er wurde erstmals 1969 von den Winstons in ihrem Song \"Amen Brother\" als Teil eines Drum-Break aufgenommen. Doch erst seine Wiederentdeckung durch fr\u00fche Hip-Hop-Musiker in den 80ern und sein Einsatz in Samplern f\u00fchrte zu einer Verwendung des Samples in einer gro\u00dfen Bandbreite von Musikstilen, wie Drum and Bass, Breakbeat, Hardcore Techno und Breakcore. Ich bin mir sicher, Du freust Dich zu h\u00f6ren, dass das Sample direkt in Sonic Pi eingebaut ist. Bereite einfach einen Puffer vor und kopiere den folgenden Code hinein: sample :loop_amen Dr\u00fccke auf Start und boom! Du h\u00f6rst dir gerade eines der einflussreichsten Drum Breaks in der Geschichte der Tanzmusik an. Dieses Sample ist allerdings nicht damit ber\u00fchmt geworden, einmal abgespielt zu werden. Vielmehr ist es wie gemacht daf\u00fcr wiederholt zu werden.","title":"Der Amen Break"},{"location":"#beat-stretching","text":"Lass uns den Amen Break in Schleife schalten, indem wir unseren alten Bekannten, den live_loop aus dem Tutorial vom letzten Monat, einsetzen: live_loop :amen_break do sample :loop_amen sleep 2 end OK, es wiederholt sich. Allerdings kommt es am Ende eines Durchlaufs zu einer l\u00e4stige Pause. Diese entsteht durch unserer Anweisung 2 Takte zu pausieren. Das :loop_amen Sample dauert bei einem voreingestellten BPM Wert von 60 nur 1.753 Takte. Das bedeutet kommt es am Sample Ende zu einer Pause von 2 - 1.753 = 0.247 Takten, was kurz, aber durchaus wahrnehmbar ist. Um dieses Problem zu beheben, k\u00f6nnen wir die beat_stretch: Option verwenden. Sie sagt Sonic Pi, dass das Sample auf die angegebene Anzahl von Takten ausgedehnt (bzw. gestaucht) werden soll. Sonic Pis Funktionen sample und synth geben uns \u00fcber optionale Parameter wie amp: , cutoff: und release: viele zus\u00e4tzliche Steuerungsm\u00f6glichkeiten. Da die Bezeichnung optionale Parameter allerdings recht lang ist, werden wir sie ab jetzt einfach opts nennen. live_loop :amen_break do sample :loop_amen, beat_stretch: 2 sleep 2 end Jetzt schwingen wir das Tanzbein! Vielleicht wollen wir es noch etwas schneller, oder doch einen Ton gem\u00e4chlicher - je nach Stimmung.","title":"Beat Stretching"},{"location":"#mit-der-zeit-spielen","text":"OK, wie sieht es aus, wenn wir den Stiel unserer Musik zu Hip Hop oder Breakcore \u00e4ndern wollen? Eine einfache M\u00f6glichkeit das zu tun ist mit der Zeit zu spielen - oder in anderen Worten am Tempo herumbasteln. In Sonic Pi ist das super leicht - f\u00fcge einfach use_bpm in deinen Live-Loop ein: live_loop :amen_break do use_bpm 30 sample :loop_amen, beat_stretch: 2 sleep 2 end W\u00e4hrend du gerade zu diesen langsamen Beats rappst, beobachte, dass obwohl wir immer noch eine Pause von 2 machen und unsere BPM bei 30 liegen nichts verz\u00f6gert klingt. Die beat_stretch Option ber\u00fccksichtigt den aktuellen BPM Wert und bringt alles in Einklang. Jetzt kommen wir zum spannenden Teil. W\u00e4hrend der Loop l\u00e4uft, ver\u00e4ndere den Wert 30 in der use_bpm 30 Zeile zu 50 . Wuhuu, auf einmal ist alles ohne aus dem Einklang zu geraten schneller geworden! Versuch das Tempo noch etwas mehr zu erh\u00f6hen - 80, 120 und um es wirklich verr\u00fcckt klingen zu lassen, trage 200 ein!","title":"Mit der Zeit spielen"},{"location":"#filtern","text":"Nun k\u00f6nnen wir Samples in unseren Live-Loop integrieren. Schauen wir uns einige der interessanten Optionen des sample Synths an. Zun\u00e4chst cutoff: , das den Cut-Off-Filter des Samplers steuert. Standardm\u00e4\u00dfig ist dieser ausgeschaltet. Aber du kannst ihn ganz einfach einschalten: live_loop :amen_break do use_bpm 50 sample :loop_amen, beat_stretch: 2, cutoff: 70 sleep 2 end Nun, \u00e4ndere den Wert der cutoff: Option. Erh\u00f6he ihn zum Beispiel auf 100, dr\u00fccke auf Start und warte bis der Loop einmal durchgelaufen ist, um die \u00c4nderung zu h\u00f6ren. Du kannst beobachten, dass niedrige Werte wie 50 den Klang voll und basslastig machen, hohe Werte wie 100 und 200 aber voll und kratzend klingen. Das liegt daran, dass die cutoff: Option die H\u00f6hen wegschneidet - genau so wie ein Rasenm\u00e4her die Enden von Grashalmen abschneidet. Die cutoff: fungiert als eine L\u00e4ngeneinstellung. Sie legt fest, wie viel Grass nach dem M\u00e4hen \u00fcbrig bleibt.","title":"Filtern"},{"location":"#slicing","text":"Ein anderes tolles Tool, das wir ausprobieren k\u00f6nnen, ist der FX Slicer. Er st\u00fcckelt unseren Sound in Einzelsequenzen. Verpacke die sample Zeile daf\u00fcr einfach mit dem folgenden FX Code: live_loop :amen_break do use_bpm 50 with_fx :slicer, phase: 0.25, wave: 0, mix: 1 do sample :loop_amen, beat_stretch: 2, cutoff: 100 end sleep 2 end Beobachte, wie der Klang dadurch etwas mehr auf und ab federt. (Du kannst dir den urspr\u00fcnglichen Klang ohne FX anh\u00f6ren, indem du die Option mix: auf 0 setzt.) Als n\u00e4chstes, versuche dich an der phase: Option. Das ist die Rate (in Beats) in der gest\u00fcckelt wird. Ein kleiner Wert wie 0.125 st\u00fcckelt h\u00e4ufig, hohe Werte wie 0.5 st\u00fcckeln hingegen langsamer. Beobachte, dass eine stufenweises Halbieren oder Vierteln der phase: tendenziell immer gut klingt. Setzte zuletzt die wave: Option auf 0, 1, oder 2 und h\u00f6re dir an, wie die \u00c4nderung klingt. Die Werte stehen f\u00fcr unterschiedliche Schwingungsformen. 0 repr\u00e4sentiert eine S\u00e4gezahnschwindung (hard in, fade out), 1 eine Rechteckschwingung (hard in, hard out) und 2 eine Dreieckschwingung (hard in, hard out).","title":"Slicing"},{"location":"#alles-zusammenfuhren_1","text":"Lass uns f\u00fcr unser letztes Beispiel einem Blick auf die fr\u00fche Drum and Bass Szene in Bristol werfen. Mach dir keinen Sorgen, wenn du nicht genau verstehst, wie das Beispiel funktioniert. F\u00fcge den Code einfach in Sonic Pi ein, klicke auf Ausf\u00fchren und versuche dich am Live-Coden, indem du die Werte der verschiedenen Optionen ver\u00e4nderst. Vergesse nicht deine Kreationen mit anderen zu teilen! Bis zum n\u00e4chsten Mal\u2026 use_bpm 100 live_loop :amen_break do p = [0.125, 0.25, 0.5].choose with_fx :slicer, phase: p, wave: 0, mix: rrand(0.7, 1) do r = [1, 1, 1, -1].choose sample :loop_amen, beat_stretch: 2, rate: r, amp: 2 end sleep 2 end live_loop :bass_drum do sample :bd_haus, cutoff: 70, amp: 1.5 sleep 0.5 end live_loop :landing do bass_line = (knit :e1, 3, [:c1, :c2].choose, 1) with_fx :slicer, phase: [0.25, 0.5].choose, invert_wave: 1, wave: 0 do s = synth :square, note: bass_line.tick, sustain: 4, cutoff: 60 control s, cutoff_slide: 4, cutoff: 120 end sleep 4 end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-04","text":"Ob polterndere Oszillatoren oder die verstimmten Kl\u00e4nge von S\u00e4gezahnschwingungen, die sich durch ein St\u00fcck ziehen, der Lead Synth - der melodische Hauptpart eines St\u00fccks - spielt in jeder elektronischen Komposition eine wichtige Rolle. Im der letzten Einheit dieses Tutorials haben wir gelernt, wie man Kl\u00e4nge erzeugt. Jetzt werden wir uns damit besch\u00e4ftigen, wie wir die drei Hauptkomponenten eines Synth Riffs - Klangfarbe, Melodie und Rhythmus - coden k\u00f6nnen. OK, fahre deinen Raspberry Pi hoch, \u00f6ffne Sonic Pi v2.6+ und auf gehts, lass und Musik machen!","title":"A.4 Synth Riffs"},{"location":"#die-welt-der-klangfarben","text":"Ein essentieller Teil jeder Synth-Figur ist das Ver\u00e4ndern und Spielen mit der F\u00e4rbung der Kl\u00e4nge. Wir k\u00f6nnen die Klangfarbe in Sonic Pi Sonic Pi auf zwei Arten steuern - indem wir f\u00fcr dramatische \u00c4nderungen verschiedene Synths verwenden, und f\u00fcr dezente Modifizierungen die verschiedenen Synth-Optionen einsetzen. Wir k\u00f6nnen daf\u00fcr auch Effekte einsetzen, aber das ist ein Tutorial f\u00fcr sich \u2026 Lass uns einen einfachen Live-Loop schreiben, in dem wir laufend den Synth \u00e4ndern: live_loop :timbre do use_synth (ring :tb303, :blade, :prophet, :saw, :beep, :tri).tick play :e2, attack: 0, release: 0.5, cutoff: 100 sleep 0.5 end Schau dir den Code genauer an. Mit dem tick Befehl gehen wir Eintrag f\u00fcr Eintrag durch einen Ring von Synth Namen (wobei wir die Liste immer wieder wiederholen). Anschlie\u00dfend \u00fcbergeben wir diesen Synth an die use_synth Funktion, die den aktuellen Synth unseres Live-Loops \u00e4ndert. Au\u00dferdem spielen wir die Note :e2 (e der zweiten Oktave) mit einer Abklingzeit von 0.5 Takten (0.5 Sekunden bei unser Standard-BPM von 60) und einem cutoff: Wert von 100. H\u00f6rst du, wie die unterschiedlichen Synths vollkommen verschiedene Kl\u00e4nge erzeugen, obwohl sie alle die selbe Note spielen? Lass uns damit experimentieren. Erh\u00f6he oder verkleinere den Wert der Abklingzeit. \u00c4ndere zum Beispiel die Werte der Optionen attack: und release: , um zu sehen, wie sich unterschiedliche Fade-In und Fade-Out Zeiten auf den Klang auswirken. Zuletzt kannst du den Wert der cutoff: Option \u00e4ndern, um zu beobachten, wie unterschiedliche Cut-Off-Wert die Klangfarbe beeinflussen (Werte zwischen 60 und 130 sind gut). Probiert mal aus, wie viele verschiedene Kl\u00e4nge du erzeugen kannst, indem du an diesen wenigen Parametern rumschraubst. Wenn dir das gelingt, kannst du im dir im Help System den Eintrag zu Synth anschauen. Hier findest du eine Auflistung aller Synths und der Optionen, die sie bereitstellen. Ein Reich an M\u00f6glichkeiten liegt dir zu F\u00fc\u00dfen.","title":"Die Welt der Klangfarben"},{"location":"#klangfarbe","text":"Klangfarbe (engl. timbre) ist nur ein ausgefallenes Wort f\u00fcr den Klang eines Ger\u00e4usches. Wenn man die selbe Note auf verschiedenen Instrumenten, wie zum Beispiel einer Geige, einer Gitarre oder einem Klavier spielt, so bleibt die Tonh\u00f6he (wie hoch oder niedrig ein Ton ist) immer die selbe. Die Tonqualit\u00e4t hingegen unterscheidet sich. Dieser Unterschied, der einem erlaubt festzustellen, ob es sich um ein Klavier oder eine Gitarre handelt, ist die Klangfarbe.","title":"Klangfarbe"},{"location":"#melodische-komposition","text":"Ein anderer wichtiger Aspekt in der Zusammenstellung unseres Leas Synths ist die Wahl der Noten, die gespielt werden sollen. Wenn du bereits eine Idee daf\u00fcr hast, kannst du einfach einen Ring erstellen, der \u00fcber die gew\u00fcnschte Notenfolge iteriert: live_loop :riff do use_synth :prophet riff = (ring :e3, :e3, :r, :g3, :r, :r, :r, :a3) play riff.tick, release: 0.5, cutoff: 80 sleep 0.25 end Hier haben wir unsere Melodie mit Hilfe eines Rings definiert, der sich aus Noten wie :e3 und Pausen - dargestellt durch :r - zusammensetzt. Wir nutzen .tick um \u00fcber die Notenfolge zu iterieren und so einen sich wiederholenden Riff zu erzeugen.","title":"Melodische Komposition"},{"location":"#automatische-melodie","text":"Es ist nicht leicht einen gut klingenden Riff aus dem Nichts zu zaubern. Statt dessen ist es oft hilfreich sich von Sonic Pi eine Auswahl von zuf\u00e4lligen Riffs ausgeben zu lassen und einen von diesen auszuw\u00e4hlen. Um das zu tun, verbinden wir drei bekannte Konzepte miteinander: Ringe, Randomisierung und Zufallszahlen. Schauen wir uns ein Beispiel an: live_loop :random_riff do use_synth :dsaw use_random_seed 3 notes = (scale :e3, :minor_pentatonic).shuffle play notes.tick, release: 0.25, cutoff: 80 sleep 0.25 end Es gibt ein paar Dinge, die wir uns der Reihe nach ansehen wollen. Zun\u00e4chst legen wir fest, dass wir den Zufallswert 3 verwenden. Was bedeutet das? Nun, das N\u00fctzliche daran ist, dass wir, wenn wir den Seed setzen, vorhersagen k\u00f6nnen, was der n\u00e4chste Zufallswert sein wird - es ist derselbe wie beim letzten Mal, als wir den Seed auf 3 gesetzt haben! Eine weitere n\u00fctzliche Information ist, dass das Mischen eines Notenrings auf dieselbe Weise funktioniert. Im obigen Beispiel fragen wir im Wesentlichen nach dem \"dritten Shuffle\" in der Standardliste der Shuffles - was auch jedes Mal dasselbe ist, da wir den Zufallswert immer auf denselben Wert setzen, kurz bevor wir den Shuffle starten. Schlie\u00dflich gehen wir einfach durch unsere gemischten Noten, um das Riff zu spielen. Jetzt f\u00e4ngt der Spa\u00df erst so richtig an. Wenn wir den Startwert(Seed) f\u00fcr den Zufallsgenerator auf eine andere Zahl, z. B. 3000, \u00e4ndern, erhalten wir eine v\u00f6llig andere Mischung der Noten. So ist es jetzt extrem einfach, neue Melodien zu erforschen. W\u00e4hle einfach die Liste der Noten aus, die du mischen m\u00f6chten (Tonleitern sind ein guter Ausgangspunkt), und w\u00e4hlen Sie dann den Startwert(Seed), mit dem du mischen m\u00f6chten. Wenn uns die Melodie nicht gef\u00e4llt, \u00e4ndern wir einfach einen dieser beiden Punkte und versuchen es erneut. Wiederhole den Vorgang, bis dir gef\u00e4llt was du h\u00f6rst!","title":"Automatische Melodie"},{"location":"#pseudo-randomisierung","text":"Die Zufallsgenerierung von Sonic Pi ist nicht wirklich zuf\u00e4llig, sondern wird als Pseudozufall bezeichnet. Stell Dir vor, Du w\u00fcrdest 100 Mal w\u00fcrfeln und das Ergebnis jedes Wurfs auf ein Blatt Papier schreiben. Sonic Pi verf\u00fcgt \u00fcber das \u00c4quivalent dieser Ergebnisliste, die verwendet wird, wenn man nach einem Zufallswert fragt. Anstatt zu w\u00fcrfeln, wird einfach der n\u00e4chste Wert auf der Liste ausgew\u00e4hlt. Wenn Du einen Startwert(Seed) setzt, dann springst Du einfach zu einem bestimmten Punkt in dieser Liste.","title":"Pseudo-Randomisierung"},{"location":"#finde-deinen-rythmus","text":"Ein weiteres wichtiges Merkmal unseres Riffs ist der Rhythmus, d.h. wann wir eine Note spielen und wann nicht. Wir haben bereits gesehen, dass wir :r nutzen k\u00f6nnen, um Pausen in einen Ring einzuf\u00fcgen. Eine weiter M\u00f6glichkeit auf den Rhythmus Einfluss zu nehmen sind sog. Spreads, \u00fcber die wir in einem kommenden Tutorial mehr lernen werden. Heute nutzen wir Randomisierung, um unseren Rhythmus zu finden. Anstatt immer jede Note in einem Ring zu spielen, k\u00f6nnen wir \u00fcber eine Bedingung festlegen, mit welcher Wahrscheinlichkeit sie abgespielt werden. Lass uns einen Blick darauf werfen: live_loop :random_riff do use_synth :dsaw use_random_seed 30 notes = (scale :e3, :minor_pentatonic).shuffle 16.times do play notes.tick, release: 0.2, cutoff: 90 if one_in(2) sleep 0.125 end end Eine n\u00fctzliche Funktion in diesem Zusammenhang ist die Funktion one_in , die true bzw. false mit einer bestimmten Wahrscheinlichkeit zur\u00fcckgibt. Hier verwenden wir den Wert 2, d.h. one_in gibt durchschnittlich ein Mal alle zwei Aufrufe true zur\u00fcck. Mit anderen Worten, true wird in 50% der F\u00e4lle zur\u00fcckgegeben. H\u00f6here Werte bewirken, dass statt true h\u00e4ufiger false zur\u00fcckgegeben wird. Das f\u00fchrt zu mehr L\u00fccken in unserem Riff. Beobachte, dass wir mit dem Befehl 16.times Wiederholung eingebaut haben. Das haben wir gemacht, damit sich unser Zufallsgenerator (der R\u00fcckgabewert der one_in Funktion) nur alle 16 Noten zur\u00fccksetzt und unser Rhythmus sich so alle 16 Schl\u00e4gen wiederholt. Wir nehmen damit keinen Einfluss auf das durcheinander Mischen, weil letzteres direkt nach dem Initiieren des Zufallsgenerators passiert. Wir k\u00f6nnen \u00fcber die Gr\u00f6\u00dfe der Wiederholungen die L\u00e4nge unseres Riffs ver\u00e4ndern. Versuche mal die Zahl 16 auf 8 oder sogar 4 oder 3 zu \u00e4ndern und schaue dir an, wie sich das auf den Rhythmus des Riffs auswirkt.","title":"Finde deinen Rythmus"},{"location":"#alles-zusammenfuhren_2","text":"OK, lass uns zum Schluss alles, das wir gelernt haben, in einem abschlie\u00dfenden Beispiel nutzen. Bis zum n\u00e4chsten Mal! live_loop :random_riff do # uncomment to bring in: # synth :blade, note: :e4, release: 4, cutoff: 100, amp: 1.5 use_synth :dsaw use_random_seed 43 notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle.take(8) 8.times do play notes.tick, release: rand(0.5), cutoff: rrand(60, 130) if one_in(2) sleep 0.125 end end live_loop :drums do use_random_seed 500 16.times do sample :bd_haus, rate: 2, cutoff: 110 if rand < 0.35 sleep 0.125 end end live_loop :bd do sample :bd_haus, cutoff: 100, amp: 3 sleep 0.5 end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-05","text":"Wenn man sich die Geschichte der Elektronischen Tanzmusik anschaut, ist es schier unm\u00f6glich den enormen Einfluss, den der winzige Synthesizer Roland TB-303 hatte, zu \u00fcbersehen. Er ist das Geheimnis hinter dem Klang des originalen Acid Bass. Diese klassisch quietschenden und quieksenden Bass Riffe des TB-303 kann man sowohl in der fr\u00fchen Chicago House Szene als auch bei Interpreten moderner Elektronischen Musik wie Plastikman, Squarepusher und Aphex Twin h\u00f6ren. Interessanterweise hatte Roland nie vorgesehen, dass der TB-303 f\u00fcr Tanzmusik zum Einsatz kommt. Er wurde urspr\u00fcnglich als eine \u00dcbungshilfe f\u00fcr Gitarristen entwickelt. Die Firma hatte sich \u00fcberlegt, dass Leute mit Hilfe des Synthesizers Basslinien programmieren w\u00fcrden zu denen sie jammen k\u00f6nnten. Leider gab es damit mehrere Probleme: die Programmierung war etwas zu kompliziert, der Klang glich nicht wirklich einer Bassgitarre, und sie waren teuer in der Anschaffung. Um ihre Verluste zu minimieren, beendete Roland die Produktion nach dem Verkauf von 10.000 Exemplaren. Nach ein paar Jahren des Daseins als Staubf\u00e4nger in den Regalen der Gitarristen wanderten die meisten TB-303s in die Schaufenster von Second-Hand-L\u00e4den. Dort warteten sie auf ihre Wiederentdeckung durch eine neue Generation von Experimentierfreudigen, die anfingen sie auf eine Art und Weise zu nutzten, die Roland nie vorgesehen hatte, um abgefahrene Kl\u00e4nge zu erzeugen. Das war die Geburtsstunde des Acid House. Obwohl es nicht leicht ist sich einen originalen TB-303 zu beschaffen, wirst Du Dich sicher freuen zu h\u00f6ren, dass Du Deinen Raspberry Pi mit Hilfe von Sonic Pi in einen TB-303 verwandeln kannst. Los gehts, wirf Sonic Pi an, kopiere den folgenden Code in einen leeren Puffer und klicke auf Ausf\u00fchren: use_synth :tb303 play :e1 Siehe da! Wir haben einen Acid Bass! Lass uns weiter experimentieren\u2026","title":"A.5 Acid Bass"},{"location":"#bringe-den-bass-zum-glucksen","text":"Lass uns zun\u00e4chst einen live Arpeggiator bauen. In unserer letzten Tutorialeinheit haben wir gelernt, dass Riffs durch Ringe von Noten, die wir nach einander in einer sich wiederholenden Schleife wiedergeben, repr\u00e4sentiert werden k\u00f6nnen. Lass uns einen Live-Loop schreiben, der das gleiche macht: use_synth :tb303 live_loop :squelch do n = (ring :e1, :e2, :e3).tick play n, release: 0.125, cutoff: 100, res: 0.8, wave: 0 sleep 0.125 end Schaue dir jede Codeziele genau an. In der ersten Zeile setzen wir den Defaultwert der use_synth Funktion auf tb303 . In der zweiten Zeile erstellen wir einen Live-Loop vom Typen :squelch , der sich die ganze Zeit wiederholt. In der dritten Zeile erstellen wir unseren Riff - einen Ring aus Noten (E in den Oktaven 1, 2, und 3), der diese mit Hilfe eines .tick s in Schleife durchl\u00e4uft. Wir definieren n als die aktuelle Note in unserem Riff. Das Gleichheitszeichen hier bedeutet, dass wir den Wert auf der rechten Seite der Bezeichnung auf der linken Seite zuzuweisen. In jedem Durchlauf unseres Loops hat n also ein anderer Wert. Im ersten Durchlauf wird n auf :e1 gesetzt. Im zweiten Durchlauf wird es auf :e2 , gefolgt von :e3 und dann wieder auf :e1 usw. gesetzt. Mit Zeile viert wird der eigentliche :tb303 Synth eingeleitet. Dabei werden einige interessante Optionen mitgegeben: release: , cutoff: , res: and wave: \u00fcber die wir etwas sp\u00e4ter genauer sprechen werden. In Zeile f\u00fcnf machen wir eine Pause - wir geben unserem Live-Loop vor sich alle 0.125 s (oder 8 mal pro Sekunde bei einem BPM von 60) zu wiederholen. Zeile sechs markiert das Ende ( end ) des Live-Loops. Sie teilt Sonic Pi nur mit, wo die zu wiederholende Sequenz zu Ende ist. W\u00e4hrend du dir noch \u00fcberlegst, wie das alles genau funktioniert, tippe den oben stehenden Code ab und klicke auf Ausf\u00fchren. Du solltest den :tb303 lostreten h\u00f6ren. Jetzt legen wir richtig los: lass uns mit dem Live-Coding beginnen. W\u00e4hrend der Loop noch aktiv ist, \u00e4ndere den cutoff: -Wert auf 110 . Dr\u00fccke nun erneut den \u201eAusf\u00fchren\u201c-Knopf. Der Ton sollte sich nun etwas h\u00e4rter und qu\u00e4kiger anh\u00f6ren. \u00c4ndere ihn jetzt auf 120 und dr\u00fccke \u201eAusf\u00fchren\u201c. Jetzt 130 . H\u00f6rst du, wie h\u00f6here Cutoff-Werte den Klang durchdringender und intensiver machen? \u00c4ndere den Wert schlie\u00dflich auf 80 , wenn du dich nach einer Pause sehnst. Wiederhole das Ganze dann so oft wie du willst. Keine Sorge, ich werde immer noch hier sein... Eine weitere Option, mit der es sich zu spielen lohnt, ist res: . Damit wird der Resonanzgrad des Filters eingestellt. Eine hohe Resonanz ist charakteristisch f\u00fcr Acid-Bass-Sounds. Im Moment haben wir res: auf 0.8 eingestellt. Versuche, ihn auf 0.85 , dann 0.9 und schlie\u00dflich 0.95 zu erh\u00f6hen. M\u00f6glicherweise wirst du feststellen, dass ein Cutoff-Wert wie 110 oder h\u00f6her die Unterschiede besser h\u00f6rbar macht. Jetzt mach mal etwas wildes und gib 0.999 ein: h\u00f6rst du den verr\u00fcckten Sound? Bei einer so hohen Aufl\u00f6sung h\u00f6rt man den Cutoff-Filter so stark mitschwingen, dass er anf\u00e4ngt, eigene T\u00f6ne zu erzeugen! \u00c4ndere zum Schluss die wave: Option auf 1 , um einen gro\u00dfen Einfluss auf die Klangfarbe zu nehmen. Dies legt die Art der Schwingungserzeugung fest. Der Standard ist mit 0 eine S\u00e4gezahnschwingung. 1 steht f\u00fcr eine Pulswelle und 2 f\u00fcr eine Dreiecksschwingung. Versuche nat\u00fcrlich auch verschiedene Riffs zu erzeugen, indem du die Noten im Ring \u00e4nderst oder sogar Noten aus Skalen oder Akkorden ausw\u00e4hlst. Viel Spa\u00df mit deinem ersten Acid Bass Synth.","title":"Bringe den Bass zum Glucksen"},{"location":"#den-tb-303-zerlegen","text":"Der Aufbau des originalen TB-303 ist eigentlich ganz einfach. Wie man dem folgenden Diagramm entnehmen kann, gibt es nur vier Hauptbestandteile. First is the oscillator wave - the raw ingredients of the sound. In this case we have a square wave. Next there's the oscillator's amplitude envelope which controls the amp of the square wave through time. These are accessed in Sonic Pi by the attack: , decay: , sustain: and release: opts along with their level counterparts. For more information read Section 2.4 'Duration with Envelopes' in the built-in tutorial. We then pass our enveloped square wave through a resonant low pass filter. This chops off the higher frequencies as well as having that nice resonance effect. Now this is where the fun starts. The cutoff value of this filter is also controlled by its own envelope! This means we have amazing control over the timbre of the sound by playing with both of these envelopes. Let's take a look: use_synth :tb303 with_fx :reverb, room: 1 do live_loop :space_scanner do play :e1, cutoff: 100, release: 7, attack: 1, cutoff_attack: 4, cutoff_release: 4 sleep 8 end end F\u00fcr jede Standard-H\u00fcllkurvenoption gibt es eine entsprechende cutoff_ -Option im :tb303 -Synthesizer. Um die cutoff-Anschlagszeit zu \u00e4ndern, k\u00f6nnen wir die Option cutoff_attack: verwenden. Kopiere den Code unten in einen leeren Puffer und dr\u00fccke Run . Du wirst einen verrr\u00fcckten Sound h\u00f6ren, der ein- und auswobbelt. Nun spiel ein bisschen herum. Versuche, die cutoff_attack: -Zeit auf 1 zu \u00e4ndern, dann auf 0.5 . Und jetzt probiere 8 . Beobachte, dass wir, um etwas mehr Stimmung zu erzeugen, alles durch einen :reverb FX schicken - probiere ein paar andere Effekte aus und schaue welche hier gut passen!","title":"Den TB-303 zerlegen"},{"location":"#alles-zusammenfuhren_3","text":"Zum Schluss gibt es ein Beispiel, das ich mit Hilfe der Konzepte aus diesem Tutorial komponiert habe. Kopiere den Code in einen leeren Puffer, h\u00f6re es Dir ein Weile lang an und dann versuche Deine eigenen \u00c4nderungen live zu coden. \u00dcberzeuge Dich davon, was f\u00fcr verr\u00fcckte Kl\u00e4nge Du erzeugen kannst! Bis zum n\u00e4chste Mal \u2026 use_synth :tb303 use_debug false with_fx :reverb, room: 0.8 do live_loop :space_scanner do with_fx :slicer, phase: 0.25, amp: 1.5 do co = (line 70, 130, steps: 8).tick play :e1, cutoff: co, release: 7, attack: 1, cutoff_attack: 4, cutoff_release: 4 sleep 8 end end live_loop :squelch do use_random_seed 3000 16.times do n = (ring :e1, :e2, :e3).tick play n, release: 0.125, cutoff: rrand(70, 130), res: 0.9, wave: 1, amp: 0.8 sleep 0.125 end end end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-06","text":"Minecraft Pi Hallo und willkommen zur\u00fcck! In den zur\u00fcckliegenden Tutorialeinheiten haben wir uns ausschlie\u00dflich auf die musikalischen M\u00f6glichkeiten von Sonic Pi konzentriert (um unseren Raspberry Pi in ein konzertf\u00e4higes Musikinstrument zu verwandeln). Bisher haben wir gelernt wie man: Live-Coded - Kl\u00e4nge live improvisieren, gigantische Beats komponiert, m\u00e4chtige Lead Synths generiert, und den bekannten TB-303 Acid Bass nachbaut. Es gibt noch so viel Dinge zu entdecken (was wir in zuk\u00fcnftigen Ausgaben des Tutorials auch machen werden). Diesen Monat lass uns einen Blick auf etwas werfen, was Sonic Pi kann, das du wahrscheinlich nicht erwartet hast: Minecraft steuern.","title":"A.6 Musisches Minecraft"},{"location":"#hello-minecraft-world","text":"OK, lass uns loslegen. Fahre deinen Raspberry Pi hoch, werfe Minecraft Pi an und erstelle eine neue Welt. Starte nun Sonic Pi und ver\u00e4ndere die Gr\u00f6\u00dfe deiner Fenster so, dass du sowohl Sonic Pi als auch Minecraft Pi auf deinem Bildschirm sehen kannst. Gib Folgendes in einen leeren Puffer ein: mc_message \"Hello Minecraft from Sonic Pi!\" Dr\u00fccke jetzt auf Ausf\u00fchren. Boom! Deine Nachricht erscheint in Minecraft! Wie einfach war das denn? Lege nun dieses Tutorial kurz beiseite und spiele mit deinen eigenen Nachrichten herum. Viel Spa\u00df!","title":"Hello Minecraft World"},{"location":"#schall-teleporter","text":"Lass uns ein wenig erkunden. Die \u00fcblichste Option ist Maus und Tastatur zu ergreifen und einfach loszulaufen. Das funktioniert, ist aber langsam und langweilig. Es w\u00e4re doch viel besser, wenn wir eine Art Teleporter h\u00e4tten. Dank Sonic Pi haben wir diesen. Probier dieses: mc_teleport 80, 40, 100 Meine G\u00fcte! Das war ein langer Weg nach oben. Wenn du dich nicht im Flugmodus befunden h\u00e4ttest, w\u00e4rst du den ganzen Weg zur\u00fcck auf den Boden gefallen. Wenn du doppelt auf die Leertaste dr\u00fcckst, um in den Flugmodus zu wechseln und dich wieder zu teleportieren, schwebst du weiterhin an der Stelle, an die du dich teleportiert hast. Aber was bedeuten diese Zahlen? Wir haben drei Zahlen, welche die Koordinaten beschreiben, zu denen wir in der Welt gehen wollen. Jede der Zahlen bekommt einen Namen - x, y und z: x - wie weit links und rechts (80 in unserem Beispiel) y - wie hoch wir sein wollen (40 in unserem Beispiel) z - wie weit vorw\u00e4rts und r\u00fcckw\u00e4rts (100 in unserem Beispiel) Indem wir unterschiedliche Werte f\u00fcr x, y und z w\u00e4hlen, k\u00f6nnen wir uns an jeden Ort der Welt teleportieren. Probiere es aus! W\u00e4hle verschiedene Zahlen aus und schaue, wo du landest. Falls der Bildschirm schwarz wird, hast du dich in den Boden oder in einen Berg teleportiert. W\u00e4hle in diesem Fall einen h\u00f6heren y-Wert um wieder \u00fcber den Boden zu kommen. Erkunde weiter, bis du einen Platz findest, der dir gef\u00e4llt... Using the ideas so far, let's build a Sonic Teleporter which makes a fun teleport sound whilst it whizzes us across the Minecraft world: mc_message \"Preparing to teleport....\" sample :ambi_lunar_land, rate: -1 sleep 1 mc_message \"3\" sleep 1 mc_message \"2\" sleep 1 mc_message \"1\" sleep 1 mc_teleport 90, 20, 10 mc_message \"Whoooosh!\"","title":"Schall-Teleporter"},{"location":"#magische-blocke","text":"Now you've found a nice spot, let's start building. You could do what you're used to and start clicking the mouse furiously to place blocks under the cursor. Or you could use the magic of Sonic Pi. Try this: x, y, z = mc_location mc_set_block :melon, x, y + 5, z Now look up! There's a melon in the sky! Take a moment to look at the code. What did we do? On line one we grabbed the current location of Steve as the variables x, y and z. These correspond to our coordinates described above. We use these coordinates in the fn mc_set_block which will place the block of your choosing at the specified coordinates. In order to make something higher up in the sky we just need to increase the y value which is why we add 5 to it. Let's make a long trail of them: live_loop :melon_trail do x, y, z = mc_location mc_set_block :melon, x, y-1, z sleep 0.125 end Now, jump over to Minecraft, make sure you're in flying-mode (double tap space if not) and fly all around the world. Look behind you to see a pretty trail of melon blocks! See what kind of twisty patterns you can make in the sky.","title":"Magische Bl\u00f6cke"},{"location":"#live-coding-minecraft","text":"Those of you that have been following this tutorial over the last few months will probably have your minds blown at this point. The trail of melons is pretty cool, but the most exciting part of the previous example is that you can use live_loop with Minecraft! For those that don't know, live_loop is Sonic Pi's special magic ability that no other programming language has. It lets you run multiple loops at the same time and allows you to change them whilst they run. They are incredibly powerful and amazing fun. I use live_loop s to perform music in nightclubs with Sonic Pi - DJs use discs and I use live_loop s :-) However, today we're going to live code both music and Minecraft. Let's get started. Run the code above and start making your melon trail again. Now, without stopping the code, just simply change :melon to :brick and hit run. Hey presto, you're now making a brick trail. How simple was that! Fancy some music to go with it? Easy. Try this: live_loop :bass_trail do tick x, y, z = mc_location b = (ring :melon, :brick, :glass).look mc_set_block b, x, y -1, z note = (ring :e1, :e2, :e3).look use_synth :tb303 play note, release: 0.1, cutoff: 70 sleep 0.125 end Now, whilst that's playing start changing the code. Change the block types - try :water , :grass or your favourite block type. Also, try changing the cutoff value from 70 to 80 and then up to 100 . Isn't this fun?","title":"Live Coding Minecraft"},{"location":"#alles-zusammenfuhren_4","text":"Let's combine everything we've seen so far with a little extra magic. Let's combine our teleportation ability with block placing and music to make a Minecraft Music Video. Don't worry if you don't understand it all, just type it in and have a play by changing some of the values whilst it's running live. Have fun and see you next time... live_loop :note_blocks do mc_message \"This is Sonic Minecraft\" with_fx :reverb do with_fx :echo, phase: 0.125, reps: 32 do tick x = (range 30, 90, step: 0.1).look y = 20 z = -10 mc_teleport x, y, z ns = (scale :e3, :minor_pentatonic) n = ns.shuffle.choose bs = (knit :glass, 3, :sand, 1) b = bs.look synth :beep, note: n, release: 0.1 mc_set_block b, x+20, n-60+y, z+10 mc_set_block b, x+20, n-60+y, z-10 sleep 0.25 end end end live_loop :beats do sample :bd_haus, cutoff: 100 sleep 0.5 end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-07","text":"After our brief excursion to the fantastic world of coding Minecraft with Sonic Pi last month, let's get musical again. Today we're going to bring a classical operatic dance piece straight into the 21st century using the awesome power of code.","title":"A.7 Bizet Beats"},{"location":"#skandalos-und-disruptiv","text":"Let's jump into a time machine back to the year 1875. A composer called Bizet had just finished his latest opera Carmen. Unfortunately like many exciting and disruptive new pieces of music people initially didn't like it at all because it was too outrageous and different. Sadly Bizet died ten years before the opera gained huge international success and became one of the most famous and frequently performed operas of all time. In sympathy with this tragedy let's take one of the main themes from Carmen and convert it to a modern format of music that is also too outrageous and different for most people in our time - live coded music!","title":"Skandal\u00f6s und disruptiv"},{"location":"#die-habanera-dekodieren","text":"Der Versuch die gesamte Oper in diesem Tutorial zu kodieren, w\u00e4re wohl zu viel des Guten, daher werden wir uns auf einen der ber\u00fchmtesten Teile fokussieren - die Basslinie der Habanera: This may look extremely unreadable to you if you haven't yet studied music notation. However, as programmers we see music notation as just another form of code - only it represents instructions to a musician instead of a computer. We therefore need to figure out a way of decoding it.","title":"Die Habanera dekodieren"},{"location":"#anmerkungen","text":"The notes are arranged from left to right like the words in this magazine but also have different heights. The height on the score represents the pitch of the note. The higher the note on the score, the higher the pitch of the note. In Sonic Pi we already know how to change the pitch of a note - we either use high or low numbers such as play 75 and play 80 or we use the note names: play :E and play :F . Luckily each of the vertical positions of the musical score represents a specific note name. Take a look at this handy look up table:","title":"Anmerkungen"},{"location":"#pausen","text":"Music scores are an extremely rich and expressive kind of code capable of communicating many things. It therefore shouldn't come as much of a surprise that musical scores can not only tell you what notes to play but also when not to play notes. In programming this is pretty much equivalent to the idea of nil or null - the absence of a value. In other words not playing a note is like the absence of a note. If you look closely at the score you'll see that it's actually a combination of black dots with lines which represent notes to play and squiggly things which represent the rests. Luckily Sonic Pi has a very handy representation for a rest: :r , so if we run: play :r it actually plays silence! We could also write play :rest , play nil or play false which are all equivalent ways of representing rests.","title":"Pausen"},{"location":"#rhythmus","text":"Finally, there's one last thing to learn how to decode in the notation - the timings of the notes. In the original notation you'll see that the notes are connected with thick lines called beams. The second note has two of these beams which means it lasts for a 16th of a beat. The other notes have a single beam which means they last for an 8th of a beat. The rest has two squiggly beams which means it also represents a 16th of the beat. When we attempt to decode and explore new things a very handy trick is to make everything as similar as possible to try and see any relationships or patterns. For example, when we re-write our notation purely in 16ths you can see that our notation just turns into a nice sequence of notes and rests.","title":"Rhythmus"},{"location":"#re-coding-the-habanera","text":"Wir sind jetzt in der Lage, um diese Basslinie f\u00fcr Sonic Pie zu \u00fcbersetzen. Lass uns diese Noten kodieren und gut sein lassen: (ring :d, :r, :r, :a, :f5, :r, :a, :r) Lass uns schauen, wie es sich anh\u00f6rt. Stelle es in einen Live-Loop und ticke durch: live_loop :habanera do play (ring :d, :r, :r, :a, :f5, :r, :a, :r).tick sleep 0.25 end Fabulous, that instantly recognisable riff springs to life through your speakers. It took a lot of effort to get here, but it was worth it - high five!","title":"Re-coding the Habanera"},{"location":"#stimmungssynthesizer","text":"Now we have the bass line, let's re-create some of the ambience of the operatic scene. One synth to try out is :blade which is a moody 80s style synth lead. Let's try it with the starting note :d passed through a slicer and reverb: live_loop :habanera do use_synth :fm use_transpose -12 play (ring :d, :r, :r, :a, :f5, :r, :a, :r).tick sleep 0.25 end with_fx :reverb do live_loop :space_light do with_fx :slicer, phase: 0.25 do synth :blade, note: :d, release: 8, cutoff: 100, amp: 2 end sleep 8 end end Now, try the other notes in the bass line: :a and :f5 . Remember, you don't need to hit stop, just modify the code whilst the music is playing and hit run again. Also, try different values for the slicer's phase: opt such as 0.5 , 0.75 and 1 .","title":"Stimmungssynthesizer"},{"location":"#alles-zusammenfuhren_5","text":"Zum Schluss lass uns alle bisherigen Ideen in einen neuen Remix von Habanera kombinieren. Du wirst feststellen, dass ich einen weiteren Teil der Basslinie als Kommentar hinzugef\u00fcgt habe. Wenn Du alles in einen neuen Puffer eingegeben hast, dr\u00fccke Run , um Dir die Komposition anzuh\u00f6ren. Und jetzt, ohne auf Stopp zu dr\u00fccken, entkommentiere die zweite Zeile, indem Du das # -Zeichen entfernst, und dr\u00fccke dann noch einmal Run \u2013 wie fantastisch das ist! Jetzt misch alles wie es Dir gef\u00e4llt \u2013 viel Spa\u00df. use_debug false bizet_bass = (ring :d, :r, :r, :a, :f5, :r, :a, :r) #bizet_bass = (ring :d, :r, :r, :Bb, :g5, :r, :Bb, :r) with_fx :reverb, room: 1, mix: 0.3 do live_loop :bizet do with_fx :slicer, phase: 0.125 do synth :blade, note: :d4, release: 8, cutoff: 100, amp: 1.5 end 16.times do tick play bizet_bass.look, release: 0.1 play bizet_bass.look - 12, release: 0.3 sleep 0.125 end end end live_loop :ind do sample :loop_industrial, beat_stretch: 1, cutoff: 100, rate: 1 sleep 1 end live_loop :drums do sample :bd_haus, cutoff: 110 synth :beep, note: 49, attack: 0, release: 0.1 sleep 0.5 end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-08","text":"Minecraft Pi Everyone has played Minecraft. You will all have built amazing structures, designed cunning traps and even created elaborate cart lines controlled by redstone switches. How many of you have performed with Minecraft? We bet you didn't know that you could use Minecraft to create amazing visuals just like a professional VJ. If your only way of modifying Minecraft was with the mouse, you'd have a tough time changing things fast enough. Luckily for you your Raspberry Pi comes with a version of Minecraft that can be controlled with code. It also comes with an app called Sonic Pi which makes coding Minecraft not only easy but also incredibly fun. In today's article we'll be showing you some of the tips and tricks that we've used to create performances in night clubs and music venues around the world. Lass uns anfangen \u2026","title":"A.8 Werde ein Minecraft VJ"},{"location":"#erste-schritte","text":"Um unsere Grundlagen aufzufrischen, lass uns mit einer einfachen \u00dcbung zum Aufw\u00e4rmen anfangen. \u00d6ffne zun\u00e4chst Deinen Raspberry Pi, dann starte Minecraft und Sonic Pi. Erstelle eine neue Welt in Minecraft, und in Sonic Pi w\u00e4hlst Du einen neuen Puffer, dann schreibe diesen Code: mc_message \"Let's get started...\" Klicke den Run-Button und Du wirst die Meldung im Minecraft-Fenster sehen. Ok, wir k\u00f6nnen nun loslegen, lass uns Spa\u00df haben \u2026","title":"Erste Schritte"},{"location":"#sandsturme","text":"When we're using Minecraft to create visuals we try and think about what will both look interesting and also be easy to generate from code. One nice trick is to create a sand storm by dropping sand blocks from the sky. For that all we need are a few basic fns: sleep - um eine Verz\u00f6gerung zwischen Aktionen einzuf\u00fcgen mc_location - um unsere aktuelle Position zu finden mc_set_block - to place sand blocks at a specific location rrand - damit wir Zufallswerte innerhalb eines Bereichs erzeugen k\u00f6nnen live_loop - to allow us to continually make it rain sand If you're unfamiliar with any of the built-in fns such as rrand , just type the word into your buffer, click on it and then hit the keyboard combo Control-i to bring up the built-in documentation. Alternatively you can navigate to the lang tab in the Help system and then look up the fns directly along with all the other exciting things you can do. Lass es uns etwas regnen lassen bevor wir die ganze Kraft des Sturms enth\u00fcllen. Versuche mit dem Wissen das du hast ein paar Sandbl\u00f6ke im Himmel zu erschaffen: x, y, z = mc_location mc_set_block :sand, x, y + 20, z + 5 sleep 2 mc_set_block :sand, x, y + 20, z + 6 sleep 2 mc_set_block :sand, x, y + 20, z + 7 sleep 2 mc_set_block :sand, x, y + 20, z + 8 When you hit Run, you might have to look around a little as the blocks may start falling down behind you depending on which direction you're currently facing. Don't worry, if you missed them just hit Run again for another batch of sand rain - just make sure you're looking the right way! Let's quickly review what's going on here. On the first line we grabbed Steve's location as coordinates with the fn mc_location and placed them into the vars x , y , and z . Then on the next lines we used the mc_set_block fn to place some sand at the same coordinates as Steve but with some modifications. We chose the same x coordinate, a y coordinate 20 blocks higher and then successively larger z coordinates so the sand dropped in a line away from Steve. Why don't you take that code and start playing around with it yourself? Try adding more lines, changing the sleep times, try mixing :sand with :gravel and choose different coordinates. Just experiment and have fun!","title":"Sandst\u00fcrme"},{"location":"#live-loops-unleashed","text":"OK, it's time to get the storm raging by unleashing the full power of the live_loop - Sonic Pi's magical ability which unleashes the full power of live coding - changing code on-the-fly whilst it's running! live_loop :sand_storm do x, y, z = mc_location xd = rrand(-10, 10) zd = rrand(-10, 10) co = rrand(70, 130) synth :cnoise, attack: 0, release: 0.125, cutoff: co mc_set_block :sand, x + xd, y+20, z+zd sleep 0.125 end What fun! We're looping round pretty quickly (8 times a second) and during each loop we're finding Steve's location like before but then generating 3 random values: xd - Die Abweichung f\u00fcr x. Sie muss zwischen -10 und 10 liegen zd - Die Abweichung f\u00fcr z, auch zwischen -10 und 10 co - ein Cut-Off-Wert f\u00fcr den Tiefpassfilter zwischen 70 und 130 We then use those random values in the fns synth and mc_set_block giving us sand falling in random locations around Steve along with a percussive rain-like sound from the :cnoise synth. For those of you new to live loops - this is where the fun really starts with Sonic Pi. Whilst the code is running and the sand is pouring down, try changing one of the values, perhaps the sleep time to 0.25 or the :sand block type to :gravel . Now hit run again . Hey Presto! Things changed without the code stopping. This is your gateway to performing like a real VJ. Keep practising and changing things around. How different can you make the visuals without stopping the code?","title":"Live Loops Unleashed"},{"location":"#epische-blockmuster","text":"Finally, another great way of generating interesting visuals is to generate huge patterned walls to fly towards and close by. For this effect we'll need to move from placing the blocks randomly to placing them in an ordered manner. We can do this by nesting two sets of iteration (hit the Help button and navigate to section 5.2 of the tutorial \"Iteration and Loops\" for more background on iteration). The funny |xd| after the do means that xd will be set for each value of the iteration. So the first time it will be 0, then 1, then 2... etc. By nesting two lots of iteration together like this we can generate all the coordinates for a square. We can then randomly choose block types from a ring of blocks for an interesting effect: x, y, z = mc_location bs = (ring :gold, :diamond, :glass) 10.times do |xd| 10.times do |yd| mc_set_block bs.choose, x + xd, y + yd, z end end Pretty neat. Whilst we're having fun here, try changing bs.choose to bs.tick to move from a random pattern to a more regular one. Try changing the block types and the more adventurous of you might want to try sticking this within a live_loop so that the patterns keep changing automatically. Now, for the VJ finale - change the two 10.times to 100.times and hit Run. Kaboom! A Huge gigantic wall of randomly placed bricks. Imagine how long it would take you to build that manually with your mouse! Double-tap space to enter fly-mode and start swooping by for some great visual effects. Don't stop here though - use your imagination to conjure up some cool ideas and then use the coding power of Sonic Pi to make it real. When you've practised enough dim the lights and put on a VJ show for your friends!","title":"Epische Blockmuster"},{"location":"#section-A-09","text":"Back in episode 4 of this tutorial series we took a brief look at randomisation whilst coding up some sizzling synth riffs. Given that randomisation is such an important part of my live coding DJ sets I thought it would be useful to cover the fundamentals in much greater detail. So, get your lucky hat on and let's surf some random streams!","title":"A.9 Zuf\u00e4lligkeit"},{"location":"#es-gibt-keinen-zufall","text":"The first thing to learn which might really surprise you when playing with Sonic Pi's randomisation functions is that they're not actually really random. What does this actually mean? Well, let's try a couple of tests. First, imagine a number in your head between 0 and 1. Keep it there and don't tell me. Now let me guess... was it 0.321567 ? No? Bah, I'm clearly no good at this. Let me have another go, but let's ask Sonic Pi to choose a number this time. Fire up Sonic Pi v2.7+ and ask it for a random number but again don't tell me: print rand Now for the reveal... was it 0.75006103515625 ? Yes! Ha, I can see you're a little sceptical. Perhaps it was just a lucky guess. Let's try again. Press the Run button again and see what we get... What? 0.75006103515625 again? This clearly can't be random! You're right, it's not. What's going on here? The fancy computer science word here is determinism. This just means that nothing is by chance and everything is destined to be. Your version of Sonic Pi is destined to always return 0.75006103515625 in the program above. This might sound pretty useless, but let me assure you that it's one of the most powerful parts of Sonic Pi. If you stick at it you'll learn how to rely on the deterministic nature of Sonic Pi's randomisation as a fundamental building block for your compositions and live coded DJ sets.","title":"Es gibt keinen Zufall"},{"location":"#eine-zufallige-melodie","text":"When Sonic Pi boots it actually loads into memory a sequence of 441,000 pre-generated random values. When you call a random function such as rand or rrand , this random stream is used to generate your result. Each call to a random function consumes a value from this stream. Therefore the 10th call to a random function will use the 10th value from the stream. Also, every time you press the Run button, the stream is reset for that run. This is why I could predict the result to rand and why the 'random' melody was the same every time. Everybody's version of Sonic Pi uses the exact same random stream which is very important when we start sharing our pieces with each other. Let's use this knowledge to generate a repeatable random melody: 8.times do play rrand_i(50, 95) sleep 0.125 end Tippe dies in einen freien Puffer und dr\u00fccke Run . Du wirst eine Melodie h\u00f6ren, die aus zuf\u00e4lligen Noten zwischen 50 und 95 besteht. Wenn sie beendet ist, dr\u00fccke Run noch einmal, um Dir exakt die gleiche Melodie erneut anzuh\u00f6ren.","title":"Eine zuf\u00e4llige Melodie"},{"location":"#praktische-zufalligkeitsfunktionen","text":"Sonic Pi comes with a number of useful functions for working with the random stream. Here's a list of some of the most useful: rand - Gibt einfach den n\u00e4chsten Wert des Zufallsparameter zur\u00fcck rrand - Gibt einen Zufallswert innerhalb eines Bereichs zur\u00fcck rrand_i - Gibt eine zuf\u00e4llige ganze Zahl innerhalb eines Bereichs zur\u00fcck one_in - Gibt wahr oder falsch mit der angegebenen Wahrscheinlichkeit zur\u00fcck dice - Imitiert den Wurf eines W\u00fcrfels und gibt einen Wert zwischen 1 und 6 zur\u00fcck choose - W\u00e4hlt einen zuf\u00e4lligen Wert aus einer Liste aus Check out their documentation in the Help system for detailed information and examples.","title":"Praktische Zuf\u00e4lligkeitsfunktionen"},{"location":"#resetting-the-stream","text":"Whilst the ability to repeat a sequence of chosen notes is essential to allow you to replay a riff on the dance floor, it might not be exactly the riff you want. Wouldn't it be great if we could try a number of different riffs and choose the one we liked best? This is where the real magic starts. We can manually set the stream with the fn use_random_seed . In Computer Science, a random seed is the starting point from which a new stream of random values can sprout out and blossom. Let's try it: use_random_seed 0 3.times do play rrand_i(50, 95) sleep 0.125 end Great, we get the first three notes of our random melody above: 84 , 83 and 71 . However, we can now change the seed to something else. How about this: use_random_seed 1 3.times do play rrand_i(50, 95) sleep 0.125 end Interesting, we get 83 , 71 and 61 . You might notice that the first two numbers here are the same as the last two numbers before - this isn't a coincidence. Remember that the random stream is just a giant list of 'pre-rolled' values. Using a random seed simply jumps us to a point in that list. Another way of thinking about it is to imagine a huge deck of pre-shuffled cards. Using a random seed is cutting the deck at a particular point. The fabulous part of this is that it's precisely this ability to jump around the random stream which gives us huge power when making music. Let's revisit our random melody of 8 notes with this new stream resetting power, but let's also throw in a live loop so we can experiment live whilst it's playing: live_loop :random_riff do use_random_seed 0 8.times do play rrand_i(50, 95), release: 0.1 sleep 0.125 end end Now, whilst it's still playing, change the seed value from 0 to something else. Try 100 , what about 999 . Try your own values, experiment and play around - see which seed generates the riff you like best.","title":"Resetting the Stream"},{"location":"#alles-zusammenfuhren_6","text":"This month's tutorial has been quite a technical dive into the workings of Sonic Pi's randomisation functionality. Hopefully it has given you some insight into how it works and how you can start using randomisation in a reliable way to create repeatable patterns within your music. It's important to stress that you can use repeatable randomisation anywhere you want. For example, you can randomise the amplitude of notes, the timing of the rhythm, the amount of reverb, the current synth, the mix of an FX, etc. etc. In the future we'll take a close look at some of these applications, but for now let me leave you with a short example. Type the following into a spare buffer, hit Run, and then start changing the seeds around, hit Run again (whilst it's still playing) and explore the different sounds, rhythms and melodies you can make. When you find a nice one, remember the seed number so you can get back to it. Finally, when you've found a few seeds you like, put on a live coded performance for your friends by simply switching between your favourite seeds to create a full piece. live_loop :random_riff do use_random_seed 10300 use_synth :prophet s = [0.125, 0.25, 0.5].choose 8.times do r = [0.125, 0.25, 1, 2].choose n = (scale :e3, :minor).choose co = rrand(30, 100) play n, release: r, cutoff: co sleep s end end live_loop :drums do use_random_seed 2001 16.times do r = rrand(0.5, 10) sample :drum_bass_hard, rate: r, amp: rand sleep 0.125 end end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-10","text":"So far during this series we've focussed on triggering sounds. We've discovered that we can trigger the many synths built into Sonic Pi with play or synth and how to trigger pre-recorded samples with sample . We've also looked at how we can wrap these triggered sounds within studio FX such as reverb and distortion using the with_fx command. Combine this with Sonic Pi's incredibly accurate timing system and you can produce a vast array of sounds, beats and riffs. However, once you've carefully selected a particular sound's options and triggered it, there's no ability to mess with it whilst it's playing right? Wrong! Today you're going to learn something very powerful - how to control running synths.","title":"A.10 Steuerung"},{"location":"#ein-grundton","text":"Lass uns einen sch\u00f6nen einfachen Sound erzeugen. Starte Sonic Pi und gib in einen neuen Puffer Folgendes ein: synth :prophet, note: :e1, release: 8, cutoff: 100 Now press the Run button at the top left to hear a lovely rumbling synth sound. Go ahead, press it again a few times to get a feel for it. OK, done? Let's start controlling it!","title":"Ein Grundton"},{"location":"#synth-nodes","text":"A little known feature in Sonic Pi is that the fns play , synth and sample , return something called a SynthNode which represents a running sound. You can capture one of these SynthNode s using a standard variable and then control it at a later point in time. For example, let's change the value of the cutoff: opt after 1 beat: sn = synth :prophet, note: :e1, release: 8, cutoff: 100 sleep 1 control sn, cutoff: 130 Let's look at each line in turn: Firstly we trigger the :prophet synth using the synth fn as normal. However we also capture the result in a variable called sn . We could have called this variable something completely different such as synth_node or jane - the name doesn't matter. However, it's important to choose a name that's meaningful to you for your performances and for people reading your code. I chose sn as it's a nice short mnemonic for synth node. On line 2 we have a standard sleep command. This does nothing special - it just asks the computer to wait for 1 beat before moving onto the next line. Line 3 is where the control fun starts. Here, we use the control fn to tell our running SynthNode to change the cutoff value to 130 . If you hit the Run button, you'll hear the :prophet synth start playing as before, but after 1 beat it will shift to sound a lot brighter. Modulierbare Optionen Most of Sonic Pi's synths and FX opts may be changed after being triggered. However, this isn't the case for all of them. For example, the envelope opts attack: , decay: , sustain: and release: can only be set when triggering the synth. Figuring out which opts can and can't be changed is simple - just head to the documentation for a given synth or FX and then scroll down to the individual option documentation and look for the phrases \"May be changed whilst playing\" or \"Can not be changed once set\". For example, the documentation for the :beep synth's attack: opt makes it clear that it's not possible to change it: Standard: 0 Muss null oder gr\u00f6\u00dfer sein Kann nicht mehr ge\u00e4ndert werden, wenn einmal festgelegt Mit dem aktuellen BPM-Wert skaliert","title":"Synth Nodes"},{"location":"#mehrere-anderungen","text":"Whilst a synth is running you're not limited to changing it only once - you're free to change it as many times as you like. For example, we can turn our :prophet into a mini arpeggiator with the following: notes = (scale :e3, :minor_pentatonic) sn = synth :prophet, note: :e1, release: 8, cutoff: 100 sleep 1 16.times do control sn, note: notes.tick sleep 0.125 end In this snippet of code we just added a couple of extra things. First we defined a new variable called notes which contains the notes we'd like to cycle through (an arpeggiator is just a fancy name for something that cycles through a list of notes in order). Secondly we replaced our single call to control with an iteration calling it 16 times. In each call to control we .tick through our ring of notes which will automatically repeat once we get to the end (thanks to the fabulous power of Sonic Pi's rings). For a bit of variety try replacing .tick with .choose and see if you can hear the difference. Note that we can change multiple opts simultaneously. Try changing the control line to the following and listen for the difference: control sn, note: notes.tick, cutoff: rrand(70, 130)","title":"Mehrere \u00c4nderungen"},{"location":"#sliding","text":"When we control a SynthNode , it responds exactly on time and instantly changes the value of the opt to the new one as if you'd pressed a button or flicked a switch requesting the change. This can sound rhythmical and percussive - especially if the opt controls an aspect of the timbre such as cutoff: . However, sometimes you don't want the change to happen instantaneously. Instead, you might want to smoothly move from the current value to the new one as if you'd moved a slider or dial. Of course, Sonic Pi can also do this too using the _slide: opts. Each opt that can be modified also has a special corresponding _slide: opt that allows you to specify a slide time. For example, amp: has amp_slide: and cutoff: has cutoff_slide: . These slide opts work slightly differently than all the other opts in that they tell the synth note how to behave next time they are controlled . Let's take a look: sn = synth :prophet, note: :e1, release: 8, cutoff: 70, cutoff_slide: 2 sleep 1 control sn, cutoff: 130 Notice how this example is exactly the same as before except with the addition of cutoff_slide: . This is saying that next time this synth has its cutoff: opt controlled, it will take 2 beats to slide from the current value to the new one. Therefore, when we use control you can hear the cutoff slide from 70 to 130. It creates an interesting dynamic feel to the sound. Now, try changing the cutoff_slide: time to a shorter value such as 0.5 or a longer value such as 4 to see how it changes the sound. Remember, you can slide any of the modifiable opts in exactly this way and each _slide: value can be totally different so you can have the cutoff sliding slowly, the amp sliding fast and the pan sliding somewhere in between if that's what you're looking to create...","title":"Sliding"},{"location":"#alles-zusammenfuhren_7","text":"Let's look at a short example which demonstrates the power of controlling synths after they've been triggered. Notice that you can also slide FX just like synths although with a slightly different syntax. Check out section 7.2 of the built-in tutorial for more information on controlling FX. Kopiere den Code in einen freien Puffer und h\u00f6re zu. H\u00f6r an dieser Stelle nicht auf \u2013 spiel mit dem Code herum. \u00c4ndere die Wechselzeiten, \u00e4ndere die Noten, den Synth, die FX und die Pausenzeiten, und probier, etwas ganz Anderes daraus zu machen! live_loop :moon_rise do with_fx :echo, mix: 0, mix_slide: 8 do |fx| control fx, mix: 1 notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle sn = synth :prophet , sustain: 8, note: :e1, cutoff: 70, cutoff_slide: 8 control sn, cutoff: 130 sleep 2 32.times do control sn, note: notes.tick, pan: rrand(-1, 1) sleep 0.125 end end end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-11","text":"Last month in this series we took a deep technical dive into the randomisation system underpinning Sonic Pi. We explored how we can use it to deterministically add new levels of dynamic control over our code. This month we're going to continue our technical dive and turn our attention to Sonic Pi's unique tick system. By the end of this article you'll be ticking your way through rhythms and riffs on your way to being a live coding DJ.","title":"A.11 Tick Tock"},{"location":"#beat-counting","text":"When making music we often want to do a different thing depending on which beat it is. Sonic Pi has a special beat counting system called tick to give you precise control over when a beat actually occurs and even supports multiple beats with their own tempos. Lass uns spielen \u2013 um den Beat zu erweitern, m\u00fcssen wir nur tick aufrufen. \u00d6ffne einen neuen Puffer, gib Folgendes ein und dr\u00fccke Run: puts tick #=> 0 This will return the current beat: 0 . Notice that even if you press the Run button a few times it will always return 0 . This is because each run starts a fresh beat counting from 0. However, whilst the run is still active, we can advance the beat as many times as we want: puts tick #=> 0 puts tick #=> 1 puts tick #=> 2 Whenever you see the symbol #=> at the end of a line of code it means that that line will log the text on the right-hand-side. For example, puts foo #=> 0 means the code puts foo prints 0 to the log at that point in the program.","title":"Beat Counting"},{"location":"#checking-the-beat","text":"We've seen that tick does two things. It increments (adds one) and returns the current beat. Sometimes we just want to look at the current beat without having to increment it which we can do via look : puts tick #=> 0 puts tick #=> 1 puts look #=> 1 puts look #=> 1 In this code we tick the beat up twice and then call look twice. We'll see the following values in the log: 0 , 1 , 1 , 1 . The first two tick s returned 0 , then 1 as expected, then the two look s just returned the last beat value twice which was 1 .","title":"Checking the Beat"},{"location":"#ringe","text":"So now we can advance the beat with tick and check the beat with look . What next? We need something to tick over. Sonic Pi uses rings for representing riffs, melodies and rhythms and the tick system has been specifically designed to work very closely with them. In fact, rings have their own dot version of tick which does two things. Firstly, it acts like a regular tick and increments the beat. Secondly it looks up the ring value using the beat as the index. Let's take a look: puts (ring :a, :b, :c).tick #=> :a .tick is a special dot version of tick which will return the first value of the ring :a . We can grab each of the values in the ring by calling .tick multiple times: puts (ring :a, :b, :c).tick #=> :a puts (ring :a, :b, :c).tick #=> :b puts (ring :a, :b, :c).tick #=> :c puts (ring :a, :b, :c).tick #=> :a puts look #=> 3 Take a look at the log and you'll see :a , :b , :c and then :a again. Notice that look returns 3 . Calls to .tick act just like they are regular calls to tick - they increment the local beat.","title":"Ringe"},{"location":"#a-live-loop-arpeggiator","text":"The real power comes when you mix tick with rings and live_loop s. When combined we have all the tools we need to both build and understand a simple arpegiator. We need just four things: A ring containing the notes we want to loop over. A means of incrementing and obtaining the beat. The ability to play a note based on the current beat. A loop structure to keep the arpegiator repeating. Diese Konzepte findest du alle in dem folgenden Code: notes = (ring 57, 62, 55, 59, 64) live_loop :arp do use_synth :dpulse play notes.tick, release: 0.2 sleep 0.125 end Let's look at each of these lines. First we define our ring of notes which we'll continually play. We then create a live_loop called :arp which loops round for us. Each time round the live_loop we set our synth to :dpulse and then play the next note in our ring using .tick . Remember that this will increment our beat counter and use the latest beat value as an index into our notes ring. Finally, we wait for an eighth of a beat before looping round again.","title":"A Live Loop Arpeggiator"},{"location":"#mehrere-gleichzeitige-beats","text":"A really important thing to know is that tick s are local to the live_loop . This means that each live_loop has its own independent beat counter. This is much more powerful than having a global metronome and beat. Let's take a look at this in action: notes = (ring 57, 62, 55, 59, 64) with_fx :reverb do live_loop :arp do use_synth :dpulse play notes.tick + 12, release: 0.1 sleep 0.125 end end live_loop :arp2 do use_synth :dsaw play notes.tick - 12, release: 0.2 sleep 0.75 end","title":"Mehrere gleichzeitige Beats"},{"location":"#clashing-beats","text":"A big cause of confusion with Sonic Pi's tick system is when people want to tick over multiple rings in the same live_loop : use_bpm 300 use_synth :blade live_loop :foo do play (ring :e1, :e2, :e3).tick play (scale :e3, :minor_pentatonic).tick sleep 1 end Even though each live_loop has its own independent beat counter, we're calling .tick twice within the same live_loop . This means that the beat will be incremented twice every time round. This can produce some interesting polyrhythms but is often not what you want. There are two solutions to this problem. One option is to manually call tick at the start of the live_loop and then use .look to look up the current beat in each live_loop . The second solution is to pass a unique name to each call to .tick such as .tick(:foo) . Sonic Pi will then create and track a separate beat counter for each named tick you use. That way you can work with as many beats as you need! See the section on named ticks in 9.4 of the built-in tutorial for more information.","title":"Clashing Beats"},{"location":"#alles-zusammenfuhren_8","text":"Let's bring all this knowledge of tick s, ring s and live_loop s together for a final fun example. As usual, don't treat this as a finished piece. Start changing things and play around with it and see what you can turn it into. See you next time... use_bpm 240 notes = (scale :e3, :minor_pentatonic).shuffle live_loop :foo do use_synth :blade with_fx :reverb, reps: 8, room: 1 do tick co = (line 70, 130, steps: 32).tick(:cutoff) play (octs :e3, 3).look, cutoff: co, amp: 2 play notes.look, amp: 4 sleep 1 end end live_loop :bar do tick sample :bd_ada if (spread 1, 4).look use_synth :tb303 co = (line 70, 130, steps: 16).look r = (line 0.1, 0.5, steps: 64).mirror.look play notes.look, release: r, cutoff: co sleep 0.5 end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-12","text":"Way back in episode 3 of this Sonic Pi series we looked at how to loop, stretch and filter one of the most famous drum breaks of all time - the Amen Break. In this tutorial we're going to take this one step further and learn how to slice it up, shuffle the slices and glue it back together in a completely new order. If that sounds a bit wild to you, don't worry, it will all become clear and you'll soon master a powerful new tool for your live coded sets.","title":"A.12 Sample Slicing"},{"location":"#ton-als-daten","text":"Before we get started let's just take a brief moment to understand how to work with samples. By now, you've all hopefully played with Sonic Pi's powerful sampler. If not, there's no time like the present! Boot up your Raspberry Pi, launch Sonic Pi from the Programming menu, type the following into a fresh buffer and then hit the Run button to hear a pre-recorded drum beat: sample :loop_amen A recording of a sound is simply represented as data - lots of numbers between -1 and 1 which represent the peaks and troughs of the sound wave. If we play those numbers back in order, we get the original sound. However, what's to stop us from playing them back in a different order and creating a new sound? How are samples actually recorded? It's actually pretty simple once you understand the basic physics of sound. When you make a sound - for example by hitting a drum, the noise travels through the air in a similar fashion to how the surface of a lake ripples when you throw a pebble into it. When those ripples reach your ears, your eardrum moves sympathetically and converts those movements into the sound you hear. If we wish to record and play back the sound, we therefore need a way of capturing, storing and reproducing those ripples. One way is to use a microphone which acts like an eardrum and moves back and forth as the sound ripples hit it. The microphone then converts its position into a tiny electric signal which is then measured many times a second. These measurements are then represented as a series of numbers between -1 and 1. If we were to plot a visualisation of the sound it would be a simple graph of data with time on the x axis and microphone/speaker position as a value between -1 and 1 on the y axis. You can see an example of such a graph at the top of the diagram.","title":"Ton als Daten"},{"location":"#playing-part-of-a-sample","text":"So, how do we code Sonic Pi to play a sample back in a different order? To answer this question we need to take a look at the start: and finish: opts for sample . These let us control the start and finish positions of our playback of the numbers which represent the sound. The values for both of these opts are represented as a number between 0 and 1 where 0 represents the start of the sample and 1 is the end. So, to play the first half of the Amen Break, we just need to specify a finish: of 0.5 : sample :loop_amen, finish: 0.5 We can add in a start: value to play an even smaller section of the sample: sample :loop_amen, start: 0.25, finish: 0.5 For fun, you can even have the finish: opt's value be before start: and it will play the section backwards: sample :loop_amen, start: 0.5, finish: 0.25","title":"Playing Part of a Sample"},{"location":"#re-ordering-sample-playback","text":"Now that we know that a sample is simply a list of numbers that can be played back in any order and also how to play a specific part of a sample we can now start having fun playing a sample back in the 'wrong' order. Let's take our Amen Break and chop it up into 8 equally-sized slices and then shuffle the pieces around. Take a look at the diagram: at the top A) represents the graph of our original sample data. Chopping it into 8 slices gives us B) - notice that we've given each slice a different colour to help distinguish them. You can see each slice's start and finish values at the top. Finally C) is one possible re-ordering of the slices. We can then play this back to create a new beat. Take a look at the code to do this: live_loop :beat_slicer do slice_idx = rand_i(8) slice_size = 0.125 s = slice_idx * slice_size f = s + slice_size sample :loop_amen, start: s, finish: f sleep sample_duration :loop_amen, start: s, finish: f end we choose a random slice to play which should be a random number between 0 and 7 (remember that we start counting at 0). Sonic Pi has a handy function for exactly this: rand_i(8) . We then store this random slice index in the variable slice_idx . We define our slice_size which is 1/8 or 0.125. The slice_size is necessary for us to convert our slice_idx into a value between 0 and 1 so we can use it as our start: opt. We calculate the start position s by multiplying the slice_idx by the slice_size . We calculate the finish position f by adding the slice_size to the start position s . We can now play the sample slice by plugging in the s and f values into the start: and finish: opts for sample . Before we play the next slice we need to know how long to sleep which should be the duration of the sample slice. Luckily, Sonic Pi has us covered with sample_duration which accepts all the same opts as sample and simply returns the duration. Therefore, by passing sample_duration our start: and finish: opts, we can find out the duration of a single slice. We wrap all of this code in a live_loop so that we continue to pick new random slices to play.","title":"Re-ordering Sample Playback"},{"location":"#alles-zusammenfuhren_9","text":"Let's combine everything we've seen so far into a final example which demonstrates how we can take a similar approach to combine randomly sliced beats with some bass to create the start of an interesting track. Now it's your turn - take the code below as a starting point and see if you can take it in your own direction and create something new... live_loop :sliced_amen do n = 8 s = line(0, 1, steps: n).choose f = s + (1.0 / n) sample :loop_amen, beat_stretch: 2, start: s, finish: f sleep 2.0 / n end live_loop :acid_bass do with_fx :reverb, room: 1, reps: 32, amp: 0.6 do tick n = (octs :e0, 3).look - (knit 0, 3 * 8, -4, 3 * 8).look co = rrand(70, 110) synth :beep, note: n + 36, release: 0.1, wave: 0, cutoff: co synth :tb303, note: n, release: 0.2, wave: 0, cutoff: co sleep (ring 0.125, 0.25).look end end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-13","text":"In a previous episode of this Sonic Pi series we explored the power of randomisation to introduce variety, surprise and change into our live coded tracks and performances. For example, we randomly picked notes from a scale to create never-ending melodies. Today we're going to learn a new technique which uses randomisation for rhythm - probabilistic beats!","title":"A.13 Code a Probabilistic Sequencer"},{"location":"#wahrscheinlichkeit","text":"Before we can start making new beats and synth rhythms we need to take a quick dive into the basics of probability. This might sound daunting and complicated, but really it's just as simple as rolling a dice - honestly! When you take a regular 6 sided board game dice and roll it what's actually happening? Well, firstly you'll roll either a 1, 2, 3, 4, 5 or 6 with exactly the same chance of getting any of the numbers. In fact, given that it's a 6 sided dice, on average (if you roll lots and lots of times) you'll throw a 1 every 6 throws. This means you have a 1 in 6 chance of throwing a 1. We can emulate dice rolls in Sonic Pi with the fn dice . Let's roll one 8 times: 8.times do puts dice sleep 1 end Notice how the log prints values between 1 and 6 just as if we'd rolled a real dice ourselves.","title":"Wahrscheinlichkeit"},{"location":"#zufallige-beats","text":"Now imagine you had a drum and every time you were about to hit it you rolled a dice. If you rolled a 1, you hit the drum and if you rolled any other number you didn't. You now have a probabilistic drum machine working with a probability of 1/6! Let's hear what that sounds like: live_loop :random_beat do sample :drum_snare_hard if dice == 1 sleep 0.125 end Let's quickly go over each line to make sure everything is very clear. First we create a new live_loop called :random_beat which will continually repeat the two lines between do and end . The first of these lines is a call to sample which will play a pre-recorded sound (the :drum_snare_hard sound in this case). However, this line has a special conditional if ending. This means that the line will only be executed if the statement on the right hand side of the if is true . The statement in this case is dice == 1 . This calls our dice function which, as we have seen, returns a value between 1 and 6. We then use the equality operator == to check to see if this value is 1 . If it is 1 , then the statement resolves to true and our snare drum sounds, if it isn't 1 then the statement resolves to false and the snare is skipped. The second line simply waits for 0.125 seconds before rolling the dice again.","title":"Zuf\u00e4llige Beats"},{"location":"#wahrscheinlichkeiten-andern","text":"Diejenigen unter euch die schon einmal Rollenspiele gespielt haben, werden mit einer Menge seltsam geformter W\u00fcrfel verschiedener Zahlenbereiche vertraut sein. Es gibt zum Beispiel den tetraederf\u00f6rmigen W\u00fcrfel, der 4 Seiten hat und sogar einen 20-seitigen W\u00fcrfel in der Form eines Ikosaeder. Die Anzahl der Seiten eines W\u00fcrfels \u00e4ndert die Chancen, oder die Wahrscheinlichkeit eine 1 zu w\u00fcrfeln. Je weniger Seiten, desto gr\u00f6\u00dfer sind deine Chancen eine 1 zu w\u00fcrfeln, und je mehr Seiten, desto geringer. Zum Beispiel betr\u00e4gt die Wahrscheinlichkeit eine 1 zu w\u00fcrfeln bei einem 4-seitigen W\u00fcrfel 1 zu 4, und bei einem 20-seitigen W\u00fcrfel betr\u00e4gt sie 1 zu 20. Gl\u00fccklicherweise verf\u00fcgt Sonic Pi \u00fcber die praktische one_in -Funktion, um genau dies zu beschreiben. Lass uns spielen: live_loop :different_probabilities do sample :drum_snare_hard if one_in(6) sleep 0.125 end Start the live loop above and you'll hear the familiar random rhythm. However, don't stop the code running. Instead, change the 6 to a different value such as 2 or 20 and hit the Run button again. Notice that lower numbers mean the snare drum sounds more frequently and higher numbers mean the snare triggers fewer times. You're making music with probabilities!","title":"Wahrscheinlichkeiten \u00e4ndern"},{"location":"#wahrscheinlichkeiten-kombinieren","text":"Things get really exciting when you combine multiple samples being triggered with different probabilities. For example: live_loop :multi_beat do sample :elec_hi_snare if one_in(6) sample :drum_cymbal_closed if one_in(2) sample :drum_cymbal_pedal if one_in(3) sample :bd_haus if one_in(4) sleep 0.125 end Again, run the code above and then start changing the probabilities to modify the rhythm. Also, try changing the samples to create an entirely new feel. For example try changing :drum_cymbal_closed to :bass_hit_c for extra bass!","title":"Wahrscheinlichkeiten kombinieren"},{"location":"#wiederholbare-rhythmen","text":"Next, we can use our old friend use_random_seed to reset the random stream after 8 iterations to create a regular beat. Type the following code to hear a much more regular and repeating rhythm. Once you hear the beat, try changing the seed value from 1000 to another number. Notice how different numbers generate different beats. live_loop :multi_beat do use_random_seed 1000 8.times do sample :elec_hi_snare if one_in(6) sample :drum_cymbal_closed if one_in(2) sample :drum_cymbal_pedal if one_in(3) sample :bd_haus if one_in(4) sleep 0.125 end end One thing I tend to do with this kind of structure is to remember which seeds sound good and make a note of them. That way I can easily re-create my rhythms in future practice sessions or performances.","title":"Wiederholbare Rhythmen"},{"location":"#alles-zusammenfuhren_10","text":"Finally, we can throw in some random bass to give it some nice melodic content. Notice that we can also use our newly discovered probabilistic sequencing method on synths just as well as samples. Don't leave it at that though - tweak the numbers and make your own track with the power of probabilities! live_loop :multi_beat do use_random_seed 2000 8.times do c = rrand(70, 130) n = (scale :e1, :minor_pentatonic).take(3).choose synth :tb303, note: n, release: 0.1, cutoff: c if rand < 0.9 sample :elec_hi_snare if one_in(6) sample :drum_cymbal_closed if one_in(2) sample :drum_cymbal_pedal if one_in(3) sample :bd_haus, amp: 1.5 if one_in(4) sleep 0.125 end end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-14","text":"This month we're going to take a deep dive into one of Sonic Pi's most powerful and flexible audio FX - the :slicer . By the end of this article you will have learned how to manipulate the overall volume of parts of our live coded sound in powerful new ways. This will allow you to create new rhythmic and timbral structures and broaden your sonic possibilities.","title":"A.14 Amplitudenmodulation"},{"location":"#slice-that-amp","text":"So, what does the :slicer FX actually do? One way to think about it is that it's just like having someone play around with the volume control on your TV or home hi-fi. Let's take a look but first, listen to the deep growl of the following code which triggers the :prophet synth: synth :prophet, note: :e1, release: 8, cutoff: 70 synth :prophet, note: :e1 + 4, release: 8, cutoff: 80 Now, let's pipe it through the :slicer FX: with_fx :slicer do synth :prophet, note: :e1, release: 8, cutoff: 70 synth :prophet, note: :e1 + 4, release: 8, cutoff: 80 end Hear how the slicer acts like it's muting and unmuting the audio with a regular beat. Also, notice how the :slicer affects all the audio generated between the do / end blocks. You can control the speed at which it turns the audio on and off with the phase: opt which is short for phase duration. Its default value is 0.25 which means 4 times a second at the default BPM of 60. Let's make it faster: with_fx :slicer, phase: 0.125 do synth :prophet, note: :e1, release: 8, cutoff: 70 synth :prophet, note: :e1 + 4, release: 8, cutoff: 80 end Now, play with different phase: durations yourself. Try longer and shorter values. See what happens when you choose a really short value. Also, try different synths such as :beep or :dsaw and different notes. Take a look at the following diagram to see how different phase: values change the number of amplitude changes per beat. Phase duration is the length of time for one on/off cycle. Therefore smaller values will make the FX switch on and off much faster than larger values. Good values to start playing with are 0.125 , 0.25 , 0.5 and 1 .","title":"Slice that Amp"},{"location":"#control-waves","text":"By default, the :slicer FX uses a square wave to manipulate the amplitude through time. This is why we hear the amplitude on for a period, then immediately off for a period, then back on again. It turns out that the square wave is just one of 4 different control waves that are supported by :slicer . The others are saw, triangle and (co)sine. Take a look at the diagram below to see what these look like. We can also hear what they sound like. For example, the following code uses (co)sine as the control wave. Hear how the sound doesn't turn on and off abruptly but instead smoothly fades in and out: with_fx :slicer, phase: 0.5, wave: 3 do synth :dsaw, note: :e3, release: 8, cutoff: 120 synth :dsaw, note: :e2, release: 8, cutoff: 100 end Have a play with the different wave forms by changing the wave: opt to 0 for saw, 1 for square, 2 for triangle and 3 for sine. See how different waves sound with different phase: opts too. Each of these waves can be inverted with the invert_wave: opt which flips it on the y axis. For example, in a single phase the saw wave typically starts high, and slowly goes down before jumping back to the top. With invert_wave: 1 it will start low and slowly go up before jumping back down again. Additionally, the control wave can be started at different points with the phase_offset: opt which should be a value between 0 and 1 . By playing around with phase: , wave: , invert_wave: and phase_offset opts you can dramatically change how the amplitude is modified through time. Dauer","title":"Control Waves"},{"location":"#setting-your-levels","text":"By default, :slicer switches between amplitude values 1 (fully loud) and 0 (silent). This can be changed with the amp_min: and amp_max: opts. You can use this alongside the sine wave setting to create a simple tremolo effect: with_fx :slicer, amp_min: 0.25, amp_max: 0.75, wave: 3, phase: 0.25 do synth :saw, release: 8 end This is just like grabbing the volume knob on your hi-fi and moving it up and down just a little so the sound 'wobbles' in and out.","title":"Setting your levels"},{"location":"#wahrscheinlichkeiten","text":"One of :slicer 's powerful features is its ability to use probability to choose whether or not to turn the slicer on or off. Before the :slicer FX starts a new phase it rolls a dice and based on the result either uses the selected control wave or keeps the amplitude off. Let's take a listen: with_fx :slicer, phase: 0.125, probability: 0.6 do synth :tb303, note: :e1, cutoff_attack: 8, release: 8 synth :tb303, note: :e2, cutoff_attack: 4, release: 8 synth :tb303, note: :e3, cutoff_attack: 2, release: 8 end Hear how we now have an interesting rhythm of pulses. Try changing the probability: opt to a different value between 0 and 1 . Values closer to 0 will have more space between each sound due to the likelihood of the sound being triggered being much lower. Another thing to notice is that the probability system in the FX is just like the randomisation system accessible via fns such as rand and shuffle . They are both completely deterministic. This means that each time you hit Run you'll hear exactly the same rhythm of pulses for a given probability. If you would like to change things around you can use the seed: opt to select a different starting seed. This works exactly the same as use_random_seed but only affects that particular FX. Finally, you can change the 'resting' position of the control wave when the probability test fails from 0 to any other position with the prob_pos: opt: with_fx :slicer, phase: 0.125, probability: 0.6, prob_pos: 1 do synth :tb303, note: :e1, cutoff_attack: 8, release: 8 synth :tb303, note: :e2, cutoff_attack: 4, release: 8 synth :tb303, note: :e3, cutoff_attack: 2, release: 8 end","title":"Wahrscheinlichkeiten"},{"location":"#slicing-beats","text":"One really fun thing to do is to use :slicer to chop a drum beat in and out: with_fx :slicer, phase: 0.125 do sample :loop_mika end This allows us to take any sample and create new rhythmical possibilities which is a lot of fun. However, one thing to be careful about is to make sure that the tempo of the sample matches the current BPM in Sonic Pi otherwise the slicing will sound totally off. For example, try swapping :loop_mika with the loop_amen sample to hear how bad this can sound when the tempos don't align.","title":"Slicing Beats"},{"location":"#tempo-andern","text":"As we have already seen, changing the default BPM with use_bpm will make all the sleep times and synth envelope durations grow or shrink to match the beat. The :slicer FX honours this too, as the phase: opt is actually measured in beats not seconds. We can therefore fix the issue with loop_amen above by changing the BPM to match the sample: use_sample_bpm :loop_amen with_fx :slicer, phase: 0.125 do sample :loop_amen end","title":"Tempo \u00e4ndern"},{"location":"#alles-zusammenfuhren_11","text":"Let's apply all these ideas into a final example that only uses the :slicer FX to create an interesting combination. Go ahead, start changing it and make it into your own piece! live_loop :dark_mist do co = (line 70, 130, steps: 8).tick with_fx :slicer, probability: 0.7, prob_pos: 1 do synth :prophet, note: :e1, release: 8, cutoff: co end with_fx :slicer, phase: [0.125, 0.25].choose do sample :guit_em9, rate: 0.5 end sleep 8 end live_loop :crashing_waves do with_fx :slicer, wave: 0, phase: 0.25 do sample :loop_mika, rate: 0.5 end sleep 16 end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-15","text":"In this month's Sonic Pi tutorial we're going to take a look at how you can start treating Sonic Pi like a real instrument. We therefore need to start thinking of code in a completely different way. Live coders think of code in a similar way to how violinists think of their bow. In fact, just like a violinist can apply various bowing techniques to create different sounds (long slow motions vs short fast hits) we will explore five of the basic live coding techniques that Sonic Pi enables. By the end of this article you'll be able to start practicing for your own live coded performances.","title":"A.15 Five Live Coding Techniques"},{"location":"#1-memorise-the-shortcuts","text":"The first tip to live coding with Sonic Pi is to start using the shortcuts. For example, instead of wasting valuable time reaching for the mouse, moving it over to the Run button and clicking, you can simply press alt and r at the same time which is much faster and keeps your fingers at the keyboard ready for the next edit. You can find out the shortcuts for the main buttons at the top by hovering the mouse over them. See section 10.2 of the built-in tutorial for the full list of shortcuts. When performing, one fun thing to do is to add a bit of flair with your arm motion when hitting shortcuts. For example, it's often good to communicate to the audience when you're about to make a change - so embellish your movement when hitting alt-r just like a guitarist would do when hitting a big power chord.","title":"1. Memorise the Shortcuts"},{"location":"#2-manually-layer-your-sounds","text":"Now you can trigger code instantly with the keyboard, you can instantly apply this skill for our second technique which is to layer your sounds manually. Instead of 'composing' using lots of calls to play , and sample separated by calls to sleep we will have one call to play which we will manually trigger using alt-r . Let's try it. Type the following code into a fresh buffer: synth :tb303, note: :e2 - 0, release: 12, cutoff: 90 Now, hit Run and whilst the sound is playing, modify the code in order to drop down four notes by changing it to the following: synth :tb303, note: :e2 - 4, release: 12, cutoff: 90 Now, hit Run again, to hear both sounds playing at the same time. This is because Sonic Pi's Run button doesn't wait for any previous code to finish, but instead starts the code running at the same time. This means you can easily layer lots of sounds manually with minor or major modifications between each trigger. For example, try changing both the note: and the cutoff: opts and then re-trigger. You can also try this technique with long abstract samples. For example: sample :ambi_lunar_land, rate: 1 Try starting the sample off, and then progressively halving the rate: opt between hitting Run from 1 to 0.5 to 0.25 to 0.125 and then even try some negative values such as -0.5 . Layer the sounds together and see where you can take it. Finally, try adding some FX. When performing, working with simple lines of code in this way means that an audience new to Sonic Pi has a good chance to follow what you're doing and relate the code that they can read to the sounds they are hearing.","title":"2. Manually Layer your Sounds"},{"location":"#3-master-live-loops","text":"When working with more rhythmic music, it can often be hard to manually trigger everything and keep good time. Instead, it is often better to use a live_loop . This provides repetition for your code whilst also giving the ability to edit the code for the next time round the loop. They also will run at the same time as other live_loop s which means you can layer them together both with each other and manual code triggers. Take a look at section 9.2 of the built-in tutorial for more information about working with live loops. When performing, remember to make use of live_loop 's sync: opt to allow you to recover from accidental runtime mistakes which stop the live loop running due to an error. If you already have the sync: opt pointing to another valid live_loop , then you can quickly fix the error and re-run the code to re-start things without missing a beat.","title":"3. Master Live Loops"},{"location":"#4-verwende-den-hauptmischer","text":"One of Sonic Pi's best kept secrets is that it has a main mixer through which all sound flows. This mixer has both a low pass filter and a high pass filter built-in, so you can easily perform global modifications to the sound. The main mixer's functionality can be accessed via the fn set_mixer_control! . For example, whilst some code is running and making sound, enter this into a spare buffer and hit Run : set_mixer_control! lpf: 50 After you run this code, all existing and new sounds will have a low pass filter applied to them and will therefore sound more muffled. Note that this means that the new mixer values stick until they are changed again. However, if you want, you can always reset the mixer back to its default state with reset_mixer! . Some of the currently supported opts are: pre_amp: , lpf: hpf: , and amp: . For the full list, see the built-in docs for set_mixer_control! . Use the mixer's *_slide opts to slide one or many opts values over time. For example, to slowly slide the mixer's low pass filter down from the current value to 30, use the following: set_mixer_control! lpf_slide: 16, lpf: 30 You can then slide quickly back to a high value with: set_mixer_control! lpf_slide: 1, lpf: 130 Bei der Ausf\u00fchrung ist es oft hilfreich, einen Puffer frei zu halten, um, wie jetzt, mit dem Mixer zu arbeiten.","title":"4. Verwende den Hauptmischer"},{"location":"#5-ubung","text":"The most important technique for live coding is practice. The most common attribute across professional musicians of all kinds is that they practice playing with their instruments - often for many hours a day. Practice is just as important for a live coder as a guitarist. Practice allows your fingers to memorise certain patterns and common edits so you can type and work with them more fluently. Practice also gives you opportunities to explore new sounds and code constructs. When performing, you'll find the more practice you do, the easier it will be for you to relax into the gig. Practice will also give you a wealth of experience to draw from. This can help you understand which kinds of modifications will be interesting and also work well with the current sounds.","title":"5. \u00dcbung"},{"location":"#alles-zusammenfuhren_12","text":"This month, instead of giving you a final example that combines all the things discussed, let's part by setting down a challenge. See if you can spend a week practicing one of these ideas every day. For example, one day practice manual triggers, the next do some basic live_loop work and the following day play around with the main mixer. Then repeat. Don't worry if things feel slow and clunky at first - just keep practicing and before you know it you'll be live coding for a real audience.","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-16","text":"Last month we took a look at five important techniques for mastering live coding - in other words, we explored how we could use Sonic Pi to approach code in the same way we would approach a musical instrument. One of the important concepts that we discussed was practice. This month we're going to take a deeper dive into understanding why live coding practice is important and how you might start.","title":"A.16 How to Practice Live Coding"},{"location":"#ube-regelmaig","text":"The most important piece of advice is to make sure you practice regularly. As a rule I typically practice for 1-2 hours a day, but 20 mins is just fine when you're starting out. Little but often is what you're aiming for - so if you can only manage 10 minutes, that's a great start. Practice tip #1 - start to develop a practice routine. Find a nice time in the day that works for you and try and practice at that time as many days of the week as you can. Before long you'll be looking forward to your regular session.","title":"\u00dcbe regelm\u00e4\u00dfig"},{"location":"#learn-to-touch-type","text":"If you watch a professional musician performing on stage you'll likely notice a few things. Firstly, when they play they don't stare at their instrument. Their fingers, arms and bodies know which keys to press, strings to pluck or drums to hit without them having to think about it too much. This is known as \"muscle memory\" and although it might sound like something only professionals can do - it's just the same as when you first learned to walk or ride a bike - practicing through repetition. Live coders use muscle memory to free their minds from having to think about where to move their fingers so they can focus on the music. This is called touch-typing - typing without having to look at the keyboard. Practice tip #2 - learn how to touch type. There are many apps, websites and even games which can help you achieve this. Find one you like the look of and stick at it until you can code without looking down.","title":"Learn to Touch Type"},{"location":"#code-whilst-standing","text":"The body of a musician is conditioned for playing their instrument. For example, a trumpet player needs to be able to blow hard, a guitar player needs to be able to grip the fretboard with strength and a drummer needs to be able to continually hit the drums for long periods of time. So, what's physical about live coding? Just like DJs, live coders typically perform whilst standing up and some even dance whilst they code! If you practice live coding whilst sitting at a desk and then have to get up and stand at a gig, you'll likely find the difference very difficult and frustrating. Practice tip #3 - stand whilst you practice. The easiest way to do this is to use a standing height desk. However, if like me you don't have one at home, there's a couple of low-fi options. The approach I take is to use an ironing board which happens to work rather well. Another is to stack some boxes or large books on a normal desk and place your keyboard on top of that. Also, make sure you stretch before you start practicing and try and dance a little during the session. Remember, nobody is watching you, so have fun and you'll feel much more natural on stage.","title":"Code whilst standing"},{"location":"#practice-setting-up","text":"Most instruments require some assembly and tuning before they can be played. Unless you're a rockstar with a bus full of roadies, you'll have to set up your own instrument before your gig. This is often a stressful time and it is easy for problems to occur. One way to help with this is to incorporate the setup process into your practice sessions. Practice tip #4 - treat setting up as an important part of your practice. For example, have a box or bag that you can keep your Raspberry Pi and keyboard in etc. Before each practice session, take out all the parts, connect everything, and work through the boot process until you have Sonic Pi running and can make sounds. Once you've finished practicing, take the time to carefully pack everything away afterwards. This may take some time at first, but before long you'll be able to setup and pack everything away incredibly quickly without having to think about it.","title":"Practice setting up"},{"location":"#experimentiere-musikalisch","text":"Once you've set up and are ready to start making music, you might find yourself struggling to know where to start. One problem many people face is that they might have a good idea of the kinds of sounds they want to make, but are frustrated that they can't produce them. Some people don't even know what kind of sounds they want to make! The first thing to do is not to worry - this is very common and happens to every musician - even if they've been practicing for a long time. It is much more important to be making sounds you don't like than not making any sounds at all. Practice tip #5 - spend time making sounds and music you don't like. Try to make time to explore new sounds and ideas. Don't worry that it might sound terrible if it's not the style you're looking for. When you're experimenting like this you increase the chance of stumbling over a sound or combination of sounds which you love! Even if 99% of the sounds you make are bad, that 1% might be the riff or intro to your new track. Forget the things you don't like and remember the parts you do. This is even easier when you're making music with code - just hit save!","title":"Experimentiere musikalisch"},{"location":"#hore-den-code","text":"Viele Musiker k\u00f6nnen auf ein Notenblatt schauen und die Musik in ihrem Kopf h\u00f6ren, ohne das sie gespielt wird. Das ist eine sehr n\u00fctzliche F\u00e4higkeit und es lohnt sich auch diese auf deine Live-Coding \u00dcbungen zu \u00fcbertragen: Der wichtige Punkt ist, dass Du eine gewisse Vorstellungen dar\u00fcber entwickelst, wie sich Dein Code anh\u00f6ren wird. Du musst es nat\u00fcrlich nicht genau in deinem Kopf h\u00f6ren k\u00f6nnen, aber es ist praktisch, ein Gef\u00fchl daf\u00fcr zu haben, ob sich der Code schnell oder langsam, laut, rhythmisch, melodisch, zuf\u00e4llig usw. anh\u00f6ren wird. Das endg\u00fcltige Ziel ist dann, diesen Prozess umkehren zu k\u00f6nnen und zu Musik, die Du dir in deinem Kopf vorstellst, den passenden Code schreiben zu k\u00f6nnen. Bis dahin wirst du wahrscheinlich sehr viel \u00fcben m\u00fcssen, aber wenn du es dann kannst, wirst du es schaffen auf der B\u00fchne improvisieren zu k\u00f6nnen und deine Ideen flie\u00dfend umzusetzen. Practice tip #6 - write some code into Sonic Pi but don't hit the Run button. Instead, try to imagine what sound it is going to produce. Then, hit Run, listen, and think about what you got right and what you didn't. Keep repeating this until it become a natural part of your coding process. When I practice I normally have a good idea of what the code will sound like. However, I still am occasionally surprised, and then I'll stop and spend some time thinking about why I was wrong. Each time this happens, I learn new tricks which allow me to express myself in new ways.","title":"H\u00f6re den Code"},{"location":"#remove-all-distractions","text":"A common problem when practicing is to become distracted with other things. Practicing is hard and requires real discipline regardless of the kind of music you're making - from jazz to classical to EDM. If you're struggling to get started or make progress, it's often too easy to hop on social media, or look something up on the internet etc. If you've set yourself a target of 20 minutes of practice, it's important to try and spend all that time being as productive as possible. Practice tip #7 - before you start practicing remove as many distractions as possible. For example, disconnect from the internet, put your phone in another room and try to practice in a quiet place where you're unlikely to be disturbed. Try to focus on coding music and you can return to your distractions when you've finished.","title":"Remove all distractions"},{"location":"#keep-a-practice-diary","text":"When you are practicing, you'll often find your mind is full of new exciting ideas - new musical directions, new sounds to try out, new functions to write, etc. These ideas are often so interesting that you might stop what you're doing and start working on the idea. This is another form of distraction! Practice tip #8 - keep a practice diary by your keyboard. When you get an exciting new idea, temporarily pause your practice session, quickly jot the idea down, then forget about it and carry on practicing. You can then spend some quality time thinking about and working on your ideas after you've finished practicing.","title":"Keep a practice diary"},{"location":"#alles-zusammenfuhren_13","text":"Try to establish a practice routine which incorporates as many of these ideas as possible. Try to keep the sessions as fun as possible but be aware that some practice sessions will be hard and feel a little like work. However, it will all be worth it once you've created your first piece or given your first performance. Remember, practice is the key to success!","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-17","text":"When people discover Sonic Pi, one of the first things they learn is how simple it is to play pre-recorded sounds using the sample function. For example, you can play an industrial drum loop, hear the sound of a choir or even listen to a vinyl scratch all via a single line of code. However, many people don't realise that you can actually vary the speed that the sample is played back at for some powerful effects and a whole new level of control over your recorded sounds. So, fire up a copy of Sonic Pi and let's get started stretching some samples!","title":"A.17 Sample Stretching"},{"location":"#sample-verlangsamen","text":"To modify the playback rate of a sample we need to use the rate: opt: Sample :guit_em9, rate: 1 If we specify a rate: of 1 then the sample is played back at the normal rate. If we want to play it back at half speed we simply use a rate: of 0.5 : sample :guit_em9, rate: 0.5 Dies hat zwei Auswirkungen auf den Ton. Das Sample h\u00f6rt sich tiefer an und es dauert doppelt so lange es abzuspielen (eine Erkl\u00e4rung hierf\u00fcr findest du in der Seitenleiste). Wir k\u00f6nnen den Wert von rate immer kleiner machen, indem wir uns 0 ann\u00e4hern. Eine Rate von 0.25 bedeutet ein Viertel der Geschwindigkeit, eine Rate von 0.1 ein Zehntel, usw. Spiele mit niedrige Raten herum und schaue, ob du es schaffst ein tiefes Murren zu erzeugen.","title":"Sample verlangsamen"},{"location":"#sample-beschleunigen","text":"In addition to making the sound longer and lower using a small rate, we can use higher rates to make the sound shorter and higher. Let's play with a drum loop this time. First, take a listen to how it sounds at the default rate of 1 : sample :loop_amen, rate: 1 Lassen wir es etwas schneller werden: sample :loop_amen, rate: 1.5 Ha! We just moved musical genres from old-skool techno to jungle. Notice how the pitch of each drum hit is higher as well as how the whole rhythm speeds up. Now, try even higher rates and see how high and short you can make the drum loop. For example, if you use a rate of 100 , the drum loop turns into a click!","title":"Sample beschleunigen"},{"location":"#ruckwartsgang","text":"Now, I'm sure many of you are thinking the same thing right now... \"what if you use a negative number for the rate?\". Great question! Let's think about this for a moment. If our rate: opt signifies the speed with which the sample is played back, 1 being normal speed, 2 being double speed, 0.5 being half speed, -1 must mean backwards! Let's try it on a snare. First, play it back at the normal rate: sample :elec_filt_snare, rate: 1 Jetzt lass es uns r\u00fcckw\u00e4rts abspielen: sample :elec_filt_snare, rate: -1 Of course, you can play it backwards twice as fast with a rate of -2 or backwards at half speed with a rate of -0.5 . Now, play around with different negative rates and have fun. It's particularly amusing with the :misc_burp sample!","title":"R\u00fcckw\u00e4rtsgang"},{"location":"#sample-rate-and-pitch","text":"One of the effects of rate modification on samples is that faster rates result in the sample sounding higher in pitch and slower rates result in the sample sounding lower in pitch. Another place you may have heard this effect in every day life is when you're cycling or driving past a beeping pedestrian crossing - as you're heading towards the sound source the pitch is higher than when you're moving away from the sound - the so-called Doppler effect. Why is this? Let's consider a simple beep which is represented by a sine wave. If we use an oscilloscope to plot a beep, we'll see something like Figure A. If we plot a beep an octave higher, we'll see Figure B and an octave lower will look like Figure C. Notice that the waves of higher notes are more compact and the waves of lower notes are more spread out. A sample of a beep is nothing more than a lot of numbers (x, y, coordinates) which when plotted onto a graph will re-draw the original curves. See figure D where each circle represents a coordinate. To turn the coordinates back into audio, the computer works through each x value and sends the corresponding y value to the speakers. The trick here is that the rate at which the computer works through the x numbers does not have to be the same as the rate with which they were recorded. In other words, the space (representing an amount of time) between each circle can be stretched or compressed. So, if the computer walks through the x values faster than the original rate, it will have the effect of squashing the circles closer together which will result in a higher sounding beep. It will also make the beep shorter as we will work through all the circles faster. This is shown in Figure E. Finally, one last thing to know is that a mathematician called Fourier proved that any sound is actually lots and lots of sine waves all combined together. Therefore, when we compress and stretch any recorded sound we're actually stretching and compressing many sine waves all at the same time in exactly this manner.","title":"Sample, Rate and Pitch"},{"location":"#pitch-bending","text":"As we've seen, using a faster rate will make the sound higher in pitch and a slower rate will make the sound lower in pitch. A very simple and useful trick is to know that doubling the rate actually results in the pitch being an octave higher and inversely halving the rate results in the pitch being an octave lower. This means that for melodic samples, playing it alongside itself at double/half rates actually sounds rather nice: sample :bass_trance_c, rate: 1 sample :bass_trance_c, rate: 2 sample :bass_trance_c, rate: 0.5 However, what if we just want to alter the rate such that the pitch goes up one semitone (one note up on a piano)? Sonic Pi makes this very easy via the rpitch: opt: sample :bass_trance_c sample :bass_trance_c, rpitch: 3 sample :bass_trance_c, rpitch: 7 If you take a look at the log on the right, you'll notice that an rpitch: of 3 actually corresponds to a rate of 1.1892 and a rpitch: of 7 corresponds to a rate of 1.4983 . Finally, we can even combine rate: and rpitch: opts: sample :ambi_choir, rate: 0.25, rpitch: 3 sleep 3 sample :ambi_choir, rate: 0.25, rpitch: 5 sleep 2 sample :ambi_choir, rate: 0.25, rpitch: 6 sleep 1 sample :ambi_choir, rate: 0.25, rpitch: 1","title":"Pitch Bending"},{"location":"#alles-zusammenfuhren_14","text":"Let's take a look at a simple piece which combines these ideas. Copy it into an empty Sonic Pi buffer, hit play, listen to it for a while and then use it as a starting point for your own piece. See how much fun it is to manipulate the playback rate of samples. As an added exercise try recording your own sounds and play around with the rate to see what wild sounds you can make. live_loop :beats do sample :guit_em9, rate: [0.25, 0.5, -1].choose, amp: 2 sample :loop_garzul, rate: [0.5, 1].choose sleep 8 end live_loop :melody do oct = [-1, 1, 2].choose * 12 with_fx :reverb, amp: 2 do 16.times do n = (scale 0, :minor_pentatonic).choose sample :bass_voxy_hit_c, rpitch: n + 4 + oct sleep 0.125 end end end","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-18","text":"This is the first of a short series of articles on how to use Sonic Pi for sound design. We'll be taking a quick tour of a number of different techniques available for you to craft your own unique sound. The first technique we'll look at is called additive synthesis . This may sound complicated - but if we expand each word slightly the meaning pops right out. Firstly, additive means a combination of things and secondly synthesis means to create sound. Additive synthesis therefore means nothing more complicated than combining existing sounds to create new ones . This synthesis technique dates back a very long time - for example, pipe organs in the middle ages had lots of slightly different sounding pipes which you could enable or disable with stops. Pulling out the stop for a given pipe 'added it to the mix' making the sound richer and more complex. Now, let's see how we can pull out all the stops with Sonic Pi.","title":"A.18 Sound Design - Additive Synthesis"},{"location":"#simple-combinations","text":"Let's start with the most basic sound there is - the humble pure-toned sine wave: synth :sine, note: :d3 Now, let's see how this sounds combined with a square wave: synth :sine, note: :d3 synth :square, note: :d3 Notice how the two sounds combine to form a new, richer sound. Of course, we don't have to stop there, we can add as many sounds as we need. However, we need to be careful with how many sounds we add together. Just like when we mix paints to create new colours, adding too many colours will result in a messy brown, similarly - adding too many sounds together will result in a muddy sound.","title":"Simple Combinations"},{"location":"#blending","text":"Let's add something to make it sound a little brighter. We could use a triangle wave at an octave higher (for that high bright sound) yet only play it at amp 0.4 so it adds something extra to the sound rather than taking it over: synth :sine, note: :d3 synth :square, note: :d3 synth :tri, note: :d4, amp: 0.4 Now, try creating your own sounds by combining 2 or more synths at different octaves and amplitudes. Also, note that you can play around with each synth's opts to modify each source sound before it is mixed in for even more combinations of sounds.","title":"Blending"},{"location":"#verstimmung","text":"So far, when combining our different synths we've used either the same pitch or switched octave. How might it sound if we didn't stick to octaves but instead chose a slightly higher or lower note? Let's try it: detune = 0.7 synth :square, note: :e3 synth :square, note: :e3 + detune If we detune our square waves by 0.7 notes we hear something that perhaps doesn't sound in tune or correct - a 'bad' note. However, as we move closer to 0 it will sound less and less out of tune as the pitches of the two waves get closer and more similar. Try it for yourself! Change the detune: opt value from 0.7 to 0.5 and listen to the new sound. Try 0.2 , 0.1 , 0.05 , 0 . Each time you change the value, take a listen and see if you can hear how the sound is changing. Notice that low detune values such as 0.1 produce a really nice 'thick' sound, with both slightly different pitches interacting with each other in interesting, often surprising, ways. Einige der integrierten Synths haben bereits eine Option zur Verstimmung, die das ganze f\u00fcr einem Synth machen. Probiere die Option detune: von :dsaw , :dpulse und :dtri aus.","title":"Verstimmung"},{"location":"#amplitudenmodellierung","text":"Another way we can finely craft our sound is to use a different envelope and options for each synth trigger. For example this will allow you to make some aspects of the sound percussive and other aspects ring out for a period of time. detune = 0.1 synth :square, note: :e1, release: 2 synth :square, note: :e1 + detune, amp: 2, release: 2 synth :gnoise, release: 2, amp: 1, cutoff: 60 synth :gnoise, release: 0.5, amp: 1, cutoff: 100 synth :noise, release: 0.2, amp: 1, cutoff: 90 In the example above I have mixed in a noisy percussive element to the sound along with some more persistent background rumbling. This was achieved firstly by using two noise synths with middling cutoff values ( 90 and 100 ) using short release times along with a noise with a longer release time but with a low cutoff value (which makes the noise less crisp and more rumbly.)","title":"Amplitudenmodellierung"},{"location":"#alles-zusammenfuhren_15","text":"Let's combine all these techniques to see if we can use additive synthesis to re-create a basic bell sound. I've broken this example into four sections. Firstly we have the 'hit' section which is the initial onset part of the bell sound - so uses a short envelope (e.g. a release: of around 0.1 ). Next we have the long ringing section in which I'm using the pure sound of the sine wave. Notice that I'm often increasing the note by roughly 12 and 24 which are the number of notes in one and two octaves. I have also thrown in a couple of low sine waves to give the sound some bass and depth. Finally, I used define to wrap my code in a function which I can then use to play a melody. Try playing your own melody and also messing around with the contents of the :bell function until you create your own fun sound to play with! define :bell do |n| # Triangle waves for the 'hit' synth :tri, note: n - 12, release: 0.1 synth :tri, note: n + 0.1, release: 0.1 synth :tri, note: n - 0.1, release: 0.1 synth :tri, note: n, release: 0.2 # Sine waves for the 'ringing' synth :sine, note: n + 24, release: 2 synth :sine, note: n + 24.1, release: 2 synth :sine, note: n + 24.2, release: 0.5 synth :sine, note: n + 11.8, release: 2 synth :sine, note: n, release: 2 # Low sine waves for the bass synth :sine, note: n - 11.8, release: 2 synth :sine, note: n - 12, release: 2 end # Play a melody with our new bell! bell :e3 sleep 1 bell :c2 sleep 1 bell :d3 sleep 1 bell :g2","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-19","text":"This is the second in a series of articles on how to use Sonic Pi for sound design. Last month we looked at additive synthesis which we discovered was the simple act of playing multiple sounds at the same time to make a new combined sound. For example we could combine different sounding synths or even the same synth at different pitches to build a new complex sound from simple ingredients. This month we'll look at a new technique commonly called subtractive synthesis which is simply the act of taking an existing complex sound and removing parts of it to create something new. This is a technique which is commonly associated with the sound of analog synthesisers of the 1960s and 1970s but also with the recent renaissance of modular analog synths through popular standards such as Eurorack. Despite this sounding like a particularly complicated and advanced technique, Sonic Pi makes it surprisingly simple and easy - so let's dive right in.","title":"A.19 Sound Design - Subtractive Synthesis"},{"location":"#complex-source-signal","text":"For a sound to work well with subtractive synthesis, it typically needs to be fairly rich and interesting. This doesn't mean we need something hugely complex - in fact, just a standard :square or :saw wave will do: synth :saw, note: :e2, release: 4 Notice that this sound is already pretty interesting and contains many different frequencies above :e2 (the second E on a piano) which add to create the timbre. If that didn't make much sense to you, try comparing it with the :beep : synth :beep, note: :e2, release: 4 As the :beep synth is just a sine wave, you'll hear a much purer tone and only at :e2 and none of the high crispy/buzzy sounds which you heard in the :saw . It's this buzziness and variation from a pure sine wave that we can play with when we use subtractive synthesis.","title":"Complex Source Signal"},{"location":"#filter_1","text":"Once we have our raw source signal, the next step is to pass it through a filter of some kind which will modify the sound by removing or reducing parts of it. One of the most common filters used for subtractive synthesis is something called a low pass filter. This will allow all the low parts of the sound through but will reduce or remove the higher parts. Sonic Pi has a powerful yet simple to use FX system that includes a low pass filter, called :lpf . Let's play with it: with_fx :lpf, cutoff: 100 do synth :saw, note: :e2, release: 4 end If you listen carefully you'll hear how some of that buzziness and crispiness has been removed. In fact, all the frequencies in the sound above note 100 have been reduced or removed and only the ones below are still present in the sound. Try changing that cutoff: point to lower notes, say 70 and then 50 and compare the sounds. Of course, the :lpf isn't the only filter you can use to manipulate the source signal. Another important FX is the high pass filter referred to as :hpf in Sonic Pi. This does the opposite to :lpf in that it lets the high parts of the sound through and cuts off the low parts. with_fx :hpf, cutoff: 90 do synth :saw, note: :e2, release: 4 end Notice how this sounds much more buzzy and raspy now that all the low frequency sounds have been removed. Play around with the cutoff value - notice how lower values let more of the original bass parts of the source signal through and higher values sound increasingly tinny and quiet.","title":"Filter"},{"location":"#low-pass-filter","text":"The low pass filter is such an important part of every subtractive synthesis toolkit that it's worth taking a deeper look at how it works. This diagram shows the same sound wave (the :prophet synth) with varying amounts of filtering. At the top, section A shows the audio wave with no filtering. Notice how the wave form is very pointy and contains lots of sharp edges. It is these hard, sharp angles that produce the high crispy/buzzy parts of the sound. Section B shows the low pass filter in action - notice how it is less pointy and more rounded than the wave form above. This means that the sound will have fewer high frequencies giving it a more mellow rounded feel. Section C shows the low pass filter with a fairly low cutoff value - this means that even more of the high frequencies have been removed from the signal resulting in an even softer, rounder wave form. Finally, notice how the size of the wave form, which represents the amplitude, decreases as we move from A to C. Subtractive synthesis works by removing parts of the signal which means that the overall amplitude is reduced as the amount of filtering that is taking place increases.","title":"Low Pass Filter"},{"location":"#filter-modulation","text":"So far we've just produced fairly static sounds. In other words, the sound doesn't change in any way for the entirety of its duration. Often you might want some movement in the sound to give the timbre some life. One way to achieve this is via filter modulation - changing the filter's options through time. Luckily Sonic Pi gives you powerful tools to manipulate an FX's opts through time. For example, you can set a slide time to each modulatable opt to specify how long it should take for the current value to linearly slide to the target value: with_fx :lpf, cutoff: 50 do |fx| control fx, cutoff_slide: 3, cutoff: 130 synth :prophet, note: :e2, sustain: 3.5 end Let's take a quick look at what's going on here. Firstly we start an :lpf FX block as normal with an initial cutoff: of a low 50 . However, the first line also finishes with the strange |fx| at the end. This is an optional part of the with_fx syntax which allows you to directly name and control the running FX synth. Line 2 does exactly this and controls the FX to set the cutoff_slide: opt to 3 and the new target cutoff: to be 130 . The FX will now start sliding the cutoff: opt's value from 50 to 130 over a period of 3 beats. Finally we also trigger a source signal synth so we can hear the effect of the modulated low pass filter.","title":"Filter Modulation"},{"location":"#alles-zusammenfuhren_16","text":"This is just a very basic taster of what's possible when you use filters to modify and change a source sound. Try playing with Sonic Pi's many built-in FX to see what fun sounds you can design. If your sound feels too static, remember you can start modulating the options to create some movement. Let's finish by designing a function which will play a new sound created with subtractive synthesis. See if you can figure out what's going on here - and for the advanced Sonic Pi readers out there - see if you can work out why I wrapped everything inside a call to at (please send answers to @samaaron on Twitter). define :subt_synth do |note, sus| at do with_fx :lpf, cutoff: 40, amp: 2 do |fx| control fx, cutoff_slide: 6, cutoff: 100 synth :prophet, note: note, sustain: sus end with_fx :hpf, cutoff_slide: 0.01 do |fx| synth :dsaw, note: note + 12, sustain: sus (sus * 8).times do control fx, cutoff: rrand(70, 110) sleep 0.125 end end end end subt_synth :e1, 8 sleep 8 subt_synth :e1 - 4, 8","title":"Alles zusammenf\u00fchren"},{"location":"#section-A-20","text":"(This article was published in issue 9 of the Hello World Magazine ) Code is one of the most creative media that humans have created. The initially obscure symbols of parentheses and lambdas are not just deeply rooted in science and mathematics, they are the closest we have managed to get to casting the same kind of magical spells as Gandalf and Harry Potter. I believe that this provides a powerful means of engagement in our learning spaces. Through the magic of code we are able to conjure up individually meaningful stories and learning experiences. We are surrounded by magical experiences. From the sleight of hand of a stage magician making the ball disappear into thin air, to the wonder of seeing your favourite band perform on a big stage. It is these \"wow\" moments that inspire us to pick up a magic book and learn the French Drop or to start jamming power chords on an old guitar. How might we create similarly deep and lasting senses of wonder that will motivate people to practice and learn the fundamentals of programming?","title":"A.20 Creative coding in the classroom with Sonic Pi"},{"location":"#musical-engines-and-notation","text":"The histories of music and computers have been intricately woven together since the inception of computing machines, or \"engines\" as Charles Babbage's powerful analytical engine was called. Back in 1842 the Mathematician Ada Lovelace, who worked very closely with Babbage, saw the creative potential of these engines. Whilst these first engines had originally been designed to accurately solve hard maths problems, Ada dreamt about making music with them: \"..the engine might compose elaborate and scientific pieces of music of any degree of complexity or extent.\" Ada Lovelace, 1842. Of course, today in 2019 much of our music, regardless of genre, has either been composed, produced or mastered with a digital computer. Ada's dream came true. It is even possible to trace the history back even further. If you see coding as the art of writing sequences of special symbols that instruct a computer to do specific things, then musical composition is a very similar practice. In Western music, the symbols are black dots positioned on a stave of lines that tell the musician which notes to play and when. Intriguingly, if we trace the roots of Western music notation back to the Italian Benedictine monk, Guido d'Arezzo, we find that the dots and lines system that modern orchestras use is just one of a number of notation systems he worked on. Some of the others were much closer to what we might now see as code. In der Wissenschaft werden seit den sp\u00e4ten 60er Jahren magische, bedeutungsvolle Erfahrungen mit Computern und Programmiersprachen erforscht. Die Pioniere des Computerunterrichts Seymour Papert, Marvin Minsky und Cynthia Solomon erforschten einfache Lisp-basierte Sprachen, die Stifte \u00fcber gro\u00dfe Papierst\u00fccke bewegten. Mit nur wenigen einfachen Befehlen war es m\u00f6glich, den Computer so zu programmieren, dass er jedes beliebige Bild zeichnete. Sie experimentierten sogar damit, ihre Logo-Sprache vom Zeichnen auf Musik auszuweiten. Papert schrieb \u00fcber das Lernen durch die Erfahrung der Rekonstruktion von Wissen und nicht durch dessen Vermittlung. Die Menschen dazu zu bringen, direkt mit den Dingen zu experimentieren, war ein wichtiger Teil der Arbeit seiner Gruppe.","title":"Musical Engines and Notation"},{"location":"#sonic-pi-performances","text":"Jylda und Sam Aaron treten auf der Thinking Digital Conference im Sage Gateshead auf. Foto: TyneSight Photos. Sonic Pi has been used to perform in a wide range of venues such as school halls, nightclubs, outdoor stages at musical festivals, college chapels and prestigious music venues. For example the amazing Convo project which brought 1000 children together in the Royal Albert Hall to perform an ambitious new composition by composer Charlotte Harding. The piece was written for traditional instruments, choirs, percussion and Sonic Pi code. The pop-artist Jylda also performed with Sonic Pi in the Sage Gateshead for the Thinking Digital Conference, where she created a unique live-coded improvised remix of her song Reeled. Sonic Pi used as one of the instruments as part of Convo at the Royal Albert Hall. Photo credit: Pete Jones.","title":"Sonic Pi Performances"},{"location":"#live-coding-in-the-classroom","text":"Sonic Pi is a code-based music creation and performance tool that builds on all of these ideas. Unlike the majority of computing education software, it is both simple enough to use for education and also powerful enough for professionals. It has been used to perform in international music festivals, used to compose in a range of styles from classical, EDM and heavy metal, and was even reviewed in the Rolling Stone magazine. It has a diverse community of over 1.5 million live coders with a variety of backgrounds all learning and sharing their ideas and thoughts through the medium of code. It is free to download for Mac, PC and Raspberry Pi and includes a friendly tutorial that assumes you know nothing about either code or music. Sonic Pi was initially conceived as a response to the UK's newly released Computing curriculum in 2014. The goal was to find a motivating and fun way to teach the fundamentals of programming. It turns out that there is a lot in common and it's huge fun to explain sequencing as melody, iteration as rhythm, conditionals as musical variety. I developed the initial designs and first iterations of the platform with Carrie Anne Philbin, who brought a teacher\u2019s perspective to the project. Since then, Sonic Pi has undergone iterative improvements thanks to the feedback gained from observing learners and collaborating directly with educators in the classroom. A core design philosophy was to never add a feature that couldn't be easily taught to a 10 year old child. This meant that most ideas had to be heavily refined and reworked until they were simple enough. Making things simple whilst keeping them powerful continues to be the hardest part of the project. In order to provide the magical motivation, Sonic Pi's design was never limited to a pure focus on education. Ideally there would be famous musicians and performers using Sonic Pi as a standard instrument alongside guitars, drums, vocals, synths, violins, etc. These performers would then act as motivational role models demonstrating the creative potential of code. For this to be possible sufficient focus and effort therefore had to be placed on making it a powerful instrument whilst still keeping it simple enough for 10 year olds to pick up. In addition to educators, I also worked directly with a variety of different artists in classrooms, art galleries, studios and venues in the early stages of Sonic Pi\u2019s development. This provided essential feedback which enabled Sonic Pi to grow and ultimately flourish as a tool for creative expression. There were a number of exciting and unexpected side effects of this dual focus on education and professional musicians. Many of the features are beneficial to both groups. For example, a lot of effort has been put into making error messages more friendly and useful (rather than being a huge complicated mess of jargon). This turns out to be very useful when you write a bug while performing in front of thousands of people. Additionally, functionality such as playing studio quality audio samples, adding audio effects, providing access to live audio from the microphone all turn out to make the learning experience more fun, rewarding and ultimately meaningful. The Sonic Pi community continues to grow and share amazing code compositions, lesson plans, musical algorithms, and much more. Much of this happens on our friendly forum in_thread (in-thread.sonic-pi.net) which is home to a very diverse group of people that includes educators, musicians, programmers, artists and makers. It is a real joy to see people learn to use code to express themselves in new ways and for that in turn to inspire others to do the same.","title":"Live coding in the classroom"},{"location":"#some-fun-capabilities","text":"From a Computer Science perspective, Sonic Pi provides you with the building blocks to teach you the basics as found in the UK's curriculum such as sequencing, iteration, conditionals, functions, data structures, algorithms, etc. However, it also builds on a number of important and relevant concepts which have become adopted in mainstream industry such as concurrency, events, pattern matching, distributed computing and determinism - all whilst keeping things simple enough to explain to a 10 year old child. Der Einstieg ist ganz einfach: play 70 A melody can be constructed with one more command, sleep: play 72 sleep 0.5 play 75 sleep 0.5 play 79 In this example, we play the note 70 (roughly the 70th note on a piano), wait for 1 second, play note 72, wait for half a second and then play note 75. What's interesting here is that with just two commands we have access to pretty much all of Western notation (which notes to play and when) and learners can code any melody they've ever heard. This leads to huge variety in expressive outcomes whilst focussing on the same computing concept: sequencing in this case. Taking ideas from the professional music world, we can also play back any recorded sound. Sonic Pi can play any audio file on your computer but also has a number of sounds built-in to make things easy to get started: sample :loop_amen This code will play back the drum break which was a pillarstone to early hip-hop, Drum and Bass and Jungle. For example, a number of early hip-hop artists played this drum break back at half speed to give it a more laid-back feeling: sample :loop_amen, rate: 0.5 In the 90s a number of music scenes burst out of new technology which enabled artists to take drum breaks like this apart and reassemble in a different order. For example: live_loop :jungle do sample :loop_amen, onset: pick sleep 0.125 end In diesem Beispiel f\u00fchren wir eine einfache Schleife mit dem Namen :jungle ein, die einen zuf\u00e4lligen Trommelschlag aus unserem Audio Sample ausw\u00e4hlt, eine achtel Sekunde wartet und dann einen weiteren Trommelschlag abspielt. Das Ergebnis ist eine endlose Folge von Trommelschl\u00e4gen zum dabei Tanzen, w\u00e4hrend Du erf\u00e4hrst, was eine Schleife ist.","title":"Some fun capabilities"},{"location":"#section-B","text":"In diesem Kapitel findest Du sehr n\u00fctzliches - nein, unentbehrliches - Wissen, um das Bestm\u00f6gliche aus Sonic Pi herauszuholen. Wir behandeln viele der verf\u00fcgbaren Tastaturk\u00fcrzel, zeigen, wie Du Deine Ergebnisse mit anderen teilen kannst, und geben Dir Tipps f\u00fcr Auftritte mit Sonic Pi.","title":"Unentbehrliche Kenntnisse"},{"location":"#section-B-01","text":"Sonic Pi ist zu gleichen Teilen Musikinstrument und Programmierumgebung. Mit Tastaturk\u00fcrzeln kannst Du Sonic Pi viel effizienter und nat\u00fcrlicher spielen - insbesondere, wenn Du live vor Publikum spielst. Sehr vieles in Sonic Pi kann mit der Tastatur gesteuert werden. Je vertrauter Du mit Sonic Pi wirst, umso mehr wirst Du diese Tastaturk\u00fcrzel verwenden. Ich selbst tippe, ohne die Tastatur anzusehen (und kann Dir nur empfehlen, das Zehnfingersystem auch zu lernen). Und ich bin jedes Mal frustriert, wenn ich zur Maus greifen muss, denn das macht mich langsam. Deshalb benutze ich st\u00e4ndig Tastaturk\u00fcrzel! Wer die Tastaturk\u00fcrzel beherrscht, kann auch seine Tastatur viel effektiver benutzen und in k\u00fcrzester Zeit wirst Du programmieren wie ein Profi. Versuche aber nicht, alle auf einmal zu lernen , merke dir erst einmal die, welche du am h\u00e4ufigsten brauchst und f\u00fcge sp\u00e4ter weitere deinem Repertoire hinzu.","title":"10.1 Tastaturk\u00fcrzel"},{"location":"#konsistenz-auf-verschiedenen-plattformen","text":"Stell Dir vor, Du lernst Klarinette. Du kannst davon ausgehen, dass alle Klarinetten aller Marken gleiche Mechaniken und Fingers\u00e4tze haben. H\u00e4tten sie das nicht, k\u00f6nntest Du nicht ohne weiteres zwischen verschiedenen Klarinetten hin- und her wechseln. Sondern m\u00fcsstest immer bei einer Marke bleiben. Ungl\u00fccklicherweise haben die drei wesentlichen Betriebssysteme (Linux, Mac OS X und Windows) alle ihre eigenen typischen Tastaturk\u00fcrzel f\u00fcr Aktionen wie z.B. Kopieren, Ausschneiden und Einf\u00fcgen. Sonic Pi nutzt diese Standards wo immer m\u00f6glich. Jedoch liegt die Priorit\u00e4t auf plattform\u00fcbergreifender Konsistenz innerhalb von Sonic Pi, nicht auf dem Versuch, die Standards der jeweiligen Plattform vollumf\u00e4nglich zu erf\u00fcllen. Das bedeutet, dass die in Sonic Pi auf dem Raspberry Pi gelernten Tastaturk\u00fcrzel ebenso auf einem Mac oder PC mit Sonic Pi funktionieren.","title":"Konsistenz auf verschiedenen Plattformen"},{"location":"#control-und-meta","text":"F\u00fcr diese Konsistenz m\u00fcssen wir auch die Namen der Tastaturk\u00fcrzel entsprechend ausw\u00e4hlen. In Sonic Pi verwenden wir die Namen Control und Meta f\u00fcr die beiden wichtigsten Kombinationstasten. Control ( Ctrl - oder Strg f\u00fcr \"Steuerung\" auf deutschen Tastaturen) ist auf allen Plattformen gleich. Auf Linux und Windows ist Meta die Alt -Taste, w\u00e4hrend Meta auf dem Mac die Command -Taste ist. Um konsistent zu bleiben, nutzen wir den Begriff Meta - diesem musst Du mental die passende Taste Deines Betriebssystems zuordnen.","title":"Control und Meta"},{"location":"#abkurzungen","text":"Um die Dinge einfach und lesbar zu halten, werden wir die Abk\u00fcrzungen C- f\u00fcr Control und eine weitere Taste sowie M- f\u00fcr Meta und eine weitere Taste verwenden. Wenn ein Tastaturk\u00fcrzel beispielsweise erfordert, dass Du Meta und r gleichzeitig dr\u00fcckst, werden wir die Abk\u00fcrzung M-r verwenden. Der Bindestrich in der Mitte ( - ) bedeutet nur \"zur gleichen Zeit.\" Hier sind ein paar der Tastaturk\u00fcrzel, die ich am n\u00fctzlichsten finde.","title":"Abk\u00fcrzungen"},{"location":"#starten-und-stoppen","text":"Du musst nicht immer zur Maus greifen, um Deinen Code auszuf\u00fchren. Dr\u00fccke stattdessen einfach M-r zum Abspielen. Mit M-s stoppst Du die Musik.","title":"Starten und Stoppen"},{"location":"#navigation","text":"Ohne die Tastenk\u00fcrzel zur Navigation bin ich verloren. Deshalb empfehle ich Dir dringend, diese K\u00fcrzel zu lernen. Sie funktionieren besonders gut, wenn Du das Zehnfingersystem schon halbwegs beherrschst, da sie normale Buchstaben verwenden - so musst Du Deine Hand nicht zur Maus oder zu den Pfeiltasten bewegen. Mit C-a springst Du an den Anfang, mit C-e ans Ende einer Zeile. Eine Zeile nach oben geht es mit C-p , eine nach unten mit C-n , ein Zeichen vorw\u00e4rts mit C-f und eines nach hinten mit C-b . Du kannst auch alle Zeichen von der aktuellen Cursorposition bis zum Ende der Zeile mit C-k l\u00f6schen.","title":"Navigation"},{"location":"#code-aufraumen","text":"Um Deinen Code sauber einzur\u00fccken, dr\u00fccke M-m .","title":"Code aufr\u00e4umen"},{"location":"#hilfesystem","text":"Zum Hilfesystem kommst Du mit M-i . Noch hilfreicher ist allerdings C-i , damit wird Dir f\u00fcr das Wort, auf dem der Cursor gerade steht, sofort die passende Stelle in der Dokumentation gezeigt. Sofortige Hilfe! Eine Liste aller Tastaturk\u00fcrzel ist in Kapitel 10.2 \"Cheatsheet f\u00fcr Tastenk\u00fcrzel\" enthalten.","title":"Hilfesystem"},{"location":"#section-B-02","text":"In diesem Abschnitt findest Du eine Zusammenfassung der wichtigsten Tastenk\u00fcrzel von Sonic Pi. In Abschnitt 10.1 erkl\u00e4rte ich Dir bereits, warum diese so n\u00fctzlich sind.","title":"10.2 Cheatsheet f\u00fcr Tastaturk\u00fcrzel"},{"location":"#konventionen","text":"Wir verwenden die folgenden Konventionen ( Meta ist Alt auf Windows und Linux und Cmd auf dem Mac wie in 10.1 beschrieben): C-a bedeutet, die Control ( Strg auf deutschen Tastaturen) zu dr\u00fccken und zu halten, dabei a zu dr\u00fccken und danach beide Tasten wieder los zu lassen. M-r bedeutet, Meta zu dr\u00fccken und zu halten, dabei die r -Taste zu dr\u00fccken und danach beide wieder los zu lassen. S-M-z bedeutet, die Meta -Taste zu dr\u00fccken und zu halten, dann Shift zu dr\u00fccken und zu halten und schlie\u00dflich die z -Taste und alle drei Tasten gleichzeitig wieder los zu lassen. C-M-f bedeutet, Control zu dr\u00fccken und zu halten, dann Meta zu dr\u00fccken und zu halten, dann f zu dr\u00fccken und alle drei Tasten gleichzeitig wieder los zu lassen.","title":"Konventionen"},{"location":"#steuerung-der-hauptanwendung","text":"M-r - Code ausf\u00fchren M-s - Code-Ausf\u00fchrung stoppen M-i - Hilfesystem ein-/ausschalten M-p - Einstellungen ein-/ausschalten M-< - Zum Puffer links wechseln M-> - Zum Puffer rechts wechseln S-M-0 - Switch to buffer 0 S-M-1 - Switch to buffer 1 ... S-M-9 - Switch to buffer 9 M-+ - Schrift des Puffers vergr\u00f6\u00dfern M-- - Schrift des Puffers verkleinern","title":"Steuerung der Hauptanwendung"},{"location":"#auswahlkopiereneinfugen","text":"M-a - Alles ausw\u00e4hlen M-c - Auswahl in den Zwischenspeicher kopieren M-] - Auswahl in den Zwischenspeicher kopieren M-x - Auswahl ausschneiden und im Zwischenspeicher ablegen C-] - Auswahl ausschneiden und im Zwischenspeicher ablegen C-k - Text ab Cursor bis zum Ende der Zeile ausschneiden M-v - Inhalt des Zwischenspeichers in den Editor kopieren C-y - Inhalt des Zwischenspeichers in den Editor kopieren C-SPACE - Markierung setzen. Textauswahl ab jetzt von hier bis zum Cursor. C-g l\u00f6scht die Markierung.","title":"Auswahl/Kopieren/Einf\u00fcgen"},{"location":"#text-manipulation","text":"M-m - Gesamten Code ausrichten Tab - Aktuelle Codezeile oder Auswahl ausrichten C-l - Editor zentrieren M-/ - Aktuelle Codezeile auskommentieren C-t - Zeichen vertauschen M-u - Das n\u00e4chste Wort oder Auswahl in Gro\u00dfbuchstaben wandeln. M-l - Das n\u00e4chste Wort oder Auswahl in Kleinbuchstaben wandeln.","title":"Text-Manipulation"},{"location":"#navigation_1","text":"C-a - An den Anfang der Zeile springen C-e - Ans Ende der Zeile springen C-p - Zur vorherigen Zeile springen C-n - Zur n\u00e4chsten Zeile springen C-f - Ein Zeichen vorw\u00e4rts C-b - Ein Zeichen zur\u00fcck M-f - Ein Wort nach vorne M-b - Ein Wort zur\u00fcck C-M-n - Zeile oder Auswahl nach unten schieben C-M-p - Zeile oder Auswahl nach unten schieben S-M-u - 10 Zeilen nach oben springen S-M-d - 10 Zeilen nach unten springen M-< - Zum Anfang des Puffers gehen M-> - Zum Ende des Puffers gehen","title":"Navigation"},{"location":"#loschen","text":"C-h - Vorangegangenes Zeichen l\u00f6schen C-d - N\u00e4chstes Zeichen l\u00f6schen","title":"L\u00f6schen"},{"location":"#fortgeschrittene-funktionen-des-editors","text":"C-i - Dokumentation f\u00fcr das Wort unter dem Cursor anzeigen M-z - R\u00fcckg\u00e4ngig (\"Undo\") S-M-z - Wiederholen (\"Redo\") C-g - Escape S-M-f - Vollbildmodus ein-/ausschalten S-M-b - Buttons ein-/ausschalten S-M-l - Anzeige Protokoll-Fenster ein-/aus S-M-m - Dunkle Benutzeroberfl\u00e4che ein-/ausschalten S-M-s - Inhalt des Puffers in Datei speichern S-M-o - Datei in einen Puffer laden","title":"Fortgeschrittene Funktionen des Editors"},{"location":"#section-B-03","text":"In Sonic Pi geht es vor allen Dingen um das Teilen und gemeinsame Lernen. Sobald Du gelernt hast, Musik zu programmieren, kannst Du Deine Kompositionen ganz leicht mit anderen teilen: Schicke Deinen Code einfach mit einer E-Mail an Deine Freunde. Ich m\u00f6chte Dich ermuntern, Deinen Code mit anderen zu teilen , so dass sie von Deiner Arbeit lernen und Teile davon in neuen Mash-Ups verwenden k\u00f6nnen. Du hast keine Ahnung, wo Du Deine Werke am besten mit anderen teilen kannst? Ich empfehle Dir f\u00fcr Deinen Code GitHub und f\u00fcr Deine Musik SoundCloud . So erreichst Du schnell ein gro\u00dfes Publikum.","title":"10.3 Teilen"},{"location":"#code-github","text":"GitHub wird von professionellen Entwicklern und auch K\u00fcnstlern verwendet, um Code zu teilen und zusammenzuarbeiten. Auf GitHub gibt es einen eigenen Bereich namens Gist , damit kann man besonders einfach ein neues St\u00fcck Code (egal ob fertig oder nicht) ver\u00f6ffentlichen. Mit einem Gist k\u00f6nnen dann auch andere Deinen Code \u00fcbernehmen, kommentieren und verbessern.","title":"Code -&gt; GitHub"},{"location":"#audio-soundcloud","text":"Statt Code kannst Du auch eine Musikaufnahme ver\u00f6ffentlichen und daf\u00fcr eine Audiodatei zu SoundCloud hochladen. Dort k\u00f6nnen andere Nutzer Kommentare dazu abgeben und die Musik diskutieren. Es ist empfehlenswert, bei einer Ver\u00f6ffentlichung auf Soundcloud zus\u00e4tzlich einen Link zu einem Gist mit Deinen Code in die Beschreibung aufzunehmen. Um Dein St\u00fcck aufzunehmen, dr\u00fccke den Aufnehmen -Knopf in der Werkzeugleiste, die Aufnahme startet dann sofort. Dr\u00fccke Ausf\u00fchren , um Deinen Code zu starten, wenn er nicht bereits l\u00e4uft. Wenn Du fertig bist, dr\u00fccke den blinkenden Aufnehmen -Knopf erneut. Du wirst dann nach einem Dateinamen gefragt, unter dem die Aufnahme als WAV-Datei gespeichert wird. Es gibt viele Werkzeuge, um eine WAV-Datei in ein MP3 zu wandeln, z.B. das Programm Audacity .","title":"Audio -&gt; SoundCloud"},{"location":"#hoffnung","text":"Ich m\u00f6chte Dich ermuntern, Deine Arbeiten zu teilen, und hoffe sehr, dass wir uns gegenseitig neue Sonic-Pi-Tipps und -Tricks beibringen werden. Ich bin schon sehr gespannt darauf, was Du mir zeigen wirst.","title":"Hoffnung"},{"location":"#section-B-04","text":"Einer der aufregendsten Aspekte von Sonic Pi ist, dass Du von nun an Code als Musikinstrument verwenden kannst. Vor Publikum zu programmieren wird damit ein neuer Weg, um Musik aufzuf\u00fchren. Das nennen wir Live-Coding .","title":"10.4 Auftritte"},{"location":"#zeig-deinen-bildschirm","text":"Wenn Du live programmierst, empfehle ich Dir, Deinem Publikum Deinen Bildschirm zu zeigen . Beim Gitarrespielen versteckst Du ja auch nicht Deine Finger und die Saiten Deines Instruments. Wenn ich zu Hause \u00fcbe, verwende ich einen Raspberry Pi und projiziere den Bildschirm mit einem kleinen Beamer an meine Wohnzimmerwand. Du k\u00f6nntest auch Deinen Fernseher oder einen Projektor in der Schule/Arbeit verwenden und eine kleine Show geben. Versuch es, das macht eine Menge Spa\u00df.","title":"Zeig Deinen Bildschirm"},{"location":"#grunde-eine-band","text":"Don't just play on your own - form a live coding band! It's a lot of fun jamming with others. One person could do beats, another ambient background, etc. Use the live_audio functionality to combine code with traditional instruments such as a guitar or a microphone. See what interesting combinations of sounds you can create with code.","title":"Gr\u00fcnde eine Band"},{"location":"#toplap","text":"Live-Coding ist nicht wirklich neu - eine kleine Gruppe von Enthusiasten macht das schon seit Jahren, typischerweise mit selbstgebauten, individuellen Systemen. Bei TOPLAP erf\u00e4hrst Du mehr \u00fcber diese anderen Live-Coder und ihre Ger\u00e4te.","title":"TOPLAP"},{"location":"#algorave","text":"Einige Live-Coder spielen auch in Nightclubs. Mehr \u00fcber dieses spezielle Genre erf\u00e4hrst Du auf Algorave .","title":"Algorave"}]}